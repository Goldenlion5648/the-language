/* eslint-disable @typescript-eslint/naming-convention */
/* eslint-disable curly */
// TODO:
// [ ] Goto definition
// [ ] Find All References
// [ ] Rename
// [ ] Show current proc in status bar
// [ ] Show #dump of current proc
// [ ] Goto next error
// [ ] Add "autogenerated" notation to autogenerated files


import * as vscode from 'vscode';
import proc = require('child_process');
import path = require('path');
import fs = require('fs');
import { start } from 'repl';

import { languages } from "./languages";
import { resourceLimits } from 'worker_threads';

const SELECTOR: vscode.DocumentFilter = { language: 'jai', scheme: 'file' };

let timeout: NodeJS.Timer | undefined = undefined;
let selections: Array<vscode.Selection> = [];
let decorationRanges: vscode.Range [] = [];
let selectionsIntersectDecoration = false;


export function activate(context: vscode.ExtensionContext) {
	updateConfig();

	context.subscriptions.push(vscode.languages.registerReferenceProvider(SELECTOR, new JaiReferenceProvider()));
	context.subscriptions.push(vscode.languages.registerDefinitionProvider(SELECTOR, new JaiDefinitionProvider()));
	context.subscriptions.push(vscode.languages.registerRenameProvider(SELECTOR, new JaiRenameProvider()));

	if (activeEditor) {
		triggerUpdateDecorations();
	}

	context.subscriptions.push(vscode.workspace.onDidChangeConfiguration(e => {
		updateConfig();
	}));

	vscode.window.onDidChangeActiveTextEditor(editor => {
		activeEditor = editor;
		if (editor) {
			updateSelectionAndDecorations();
		}
	}, null, context.subscriptions);

	vscode.workspace.onDidChangeTextDocument(event => {
		if (activeEditor && event.document === activeEditor.document) {
			triggerUpdateDecorations();
		}
	}, null, context.subscriptions);

	vscode.window.onDidChangeTextEditorSelection(event => {
		if (activeEditor === event.textEditor) {
			selections = [];
			for(let i = 0; i < event.selections.length; i++)
				selections.push(event.selections[i]);
			selections.sort((r1,r2) => {
				if (r1.start.line > r2.start.line)
					return +1;
				else if (r1.start.line < r2.start.line)
					return -1;

				if (r1.start.character > r2.start.character)
					return +1;
				else if (r1.start.character < r2.start.character)
					return -1;

				return 0;
			});
			if (selectionsIntersectDecoration || areIntersecting(selections, decorationRanges)) {
				updateDecorations();
			}
		}
	});

}

export function deactivate() {}

function triggerUpdateDecorations() {
	if (timeout) {
		clearTimeout(timeout);
		timeout = undefined;
	}
	timeout = setTimeout(updateSelectionAndDecorations, 500);
}


let activeEditor = vscode.window.activeTextEditor;


function updateSelectionAndDecorations() {
	if (!activeEditor) return;

	selections = [];
	let s = activeEditor.selections;
	for(let i = 0; i < s.length; i++)
		selections.push(s[i]);

	updateDecorations();
}


function updateDecorations() {
	if (!activeEditor) return;

	decorate(activeEditor);
}


function makeDecoration(color: string): vscode.TextEditorDecorationType {
	return vscode.window.createTextEditorDecorationType({
		backgroundColor: color,
		isWholeLine: true,
	});
}


interface EmbedLanguageColor {
	language: string;
	color: string;
}


let decorateEmbeds : boolean | undefined = true;
let embedColorsConfig: EmbedLanguageColor[] | undefined;
let embedColors: { [language: string] : string};
let defaultEmbedColor = "#222222";
let embedDecorations: { [color: string] : vscode.TextEditorDecorationType } = {};


function updateConfig() {
	let config = vscode.workspace.getConfiguration('the-language');
	decorateEmbeds = config.get("decorateEmbeds");
	if (decorateEmbeds === undefined) decorateEmbeds = true;

	embedColorsConfig = config.get("embedColors");
	const isColor = /#[a-fA-F0-9]{6}/;
	if (embedColorsConfig !== undefined) {
		embedColors = {};
		for (let i = 0; i < embedColorsConfig.length; i++) {
			let embedColor = embedColorsConfig[i];
			if (embedColor.color.match(isColor)) {
				if (!(embedColor.color in embedDecorations))
					embedDecorations[embedColor.color] = makeDecoration(embedColor.color);
				if (embedColor.language.toLowerCase() === "default")
					defaultEmbedColor = embedColor.color;
				else
					embedColors[embedColor.language] = embedColor.color;
			}
		}
	}
	updateSelectionAndDecorations();
}


function areIntersecting(rangesA: vscode.Range [], rangesB: vscode.Range []): boolean {
	if (rangesA === undefined || rangesB === undefined) return false;

	for (let i = 0; i < rangesA.length; i++) {
		for (let j = 0; j < rangesB.length; j++) {
			if (rangesA[i] === undefined || rangesB[j] === undefined)
				return false;
			if (rangesA[i].intersection(rangesB[j]))
				return true;
		}
	}
	return false;
}


function subtract(range: vscode.Range, sorted_subtractors: vscode.Range []): [vscode.Range [], boolean] {
	let result: vscode.Range [] = [];
	let remainder: vscode.Range | undefined;
	remainder = range;
	let changed = false;

	for (let i = 0; i < sorted_subtractors.length; i++) {
		let to_remove = sorted_subtractors[i];
		if (to_remove.end.isBeforeOrEqual(remainder.start)) continue;
		if (to_remove.start.isAfterOrEqual(remainder.end)) continue;

		if (to_remove.start.isBeforeOrEqual(remainder.start)) {
			if (to_remove.end.isAfterOrEqual(remainder.end)) {
				changed = true;
				remainder = undefined;
				break;
			}
			else {
				changed = true;
				remainder = new vscode.Range(to_remove.end, remainder.end);
			}
		}
		else if (to_remove.end.isAfterOrEqual(remainder.end)) {
			changed = true;
			result.push(new vscode.Range(remainder.start, to_remove.start));
			remainder = undefined;
			break;
		}
		else { // to_subtract is strictly within range
			changed = true;
			result.push(new vscode.Range(remainder.start, to_remove.start));
			remainder = new vscode.Range(to_remove.end, remainder.end);
		}
	}

	if (remainder)
		result.push(remainder);

	return [result, changed];
}


function decorate(editor: vscode.TextEditor) {
	if (!decorateEmbeds) {
		for (let color in embedDecorations) {
			editor.setDecorations(embedDecorations[color], []);
		}
		return;
	}

	let sourceCode = editor.document.getText();
	let hereString = /#string\s+([a-zA-Z_]\w*)/;
	let docComment = /^\/\*\*/;

	let decorationsArrays: { [color: string] : vscode.DecorationOptions[] } = {};

	const sourceCodeArr = sourceCode.split('\n');

	let endToken : string | undefined;
	let decorationColor = defaultEmbedColor;
	let startLine = 0;
	let insideDocComment = false;
	decorationRanges = [];

	selectionsIntersectDecoration = false;

	for (let line = 0; line < sourceCodeArr.length; line++) {
		if (endToken !== undefined) {
			let match = sourceCodeArr[line].match(endToken);

			if (match !== null || line === sourceCodeArr.length - 1) {
				endToken = undefined;

				const eol = 99999;
				let endLine = insideDocComment ? line : line - 1;


				let range = new vscode.Range(
					new vscode.Position(startLine, 0),
					new vscode.Position(endLine, eol)
				);
				decorationRanges.push(range);

				if (!(decorationColor in decorationsArrays))
					decorationsArrays[decorationColor] = [];

				let [applicableRanges, changed] = subtract(range, selections); // @Note assumes selections are ordered and disjoint
				if (changed) selectionsIntersectDecoration = true;

				for (let i = 0; i < applicableRanges.length; i++) {
					range = applicableRanges[i];
					if (range.start.character !== 0) {
						if (range.start.line + 1 > range.end.line) continue;
						range = new vscode.Range(
							new vscode.Position(range.start.line + 1, 0),
							range.end
						);
					}
					if (range.end.character !== eol) {
						if (range.end.line - 1 < range.start.line) continue;
						range = new vscode.Range(
							range.start,
							new vscode.Position(range.end.line - 1, eol),
						);
					}

					let decoration = { range };
					decorationsArrays[decorationColor].push(decoration);
				}
			}
		}
		else {
			let match = sourceCodeArr[line].match(hereString);
			let isHereString = true;

			if (match === null || match.index === undefined) {
				match = sourceCodeArr[line].match(docComment);
				isHereString = false;
			}

			if (match !== null && match.index !== undefined) {
				let matchedLanguage: string;
				if (isHereString) {
					startLine = line + 1;
					insideDocComment = false;
					matchedLanguage = match[1];
					endToken = matchedLanguage;
				}
				else {
					startLine = line;
					insideDocComment = true;
					matchedLanguage = "md";
					endToken = "\\*\\/";
				}

				decorationColor = defaultEmbedColor;
				for (let i = 0; i < languages.length; i++) {
					let language = languages[i][0] as string;
					let pattern  = languages[i][1] as RegExp;
					if (matchedLanguage.match(pattern))
					{
						if (language in embedColors)
							decorationColor = embedColors[language];
						break;
					}
				}
			}
		}
	}

	for (let color in decorationsArrays) {
		editor.setDecorations(embedDecorations[color], decorationsArrays[color]);
	}

	for (let color in embedDecorations) {
		if (!(color in decorationsArrays))
			editor.setDecorations(embedDecorations[color], []);
	}
}



class JaiReferenceProvider implements vscode.ReferenceProvider {
	public provideReferences(document: vscode.TextDocument, position: vscode.Position,
							 options: { includeDeclaration: boolean }, token: vscode.CancellationToken):
	Thenable<vscode.Location[]> {
		return new Promise((resolve, reject) => {
			jaiLocate(document.fileName, position, "Reference").then(output => {
				if (output === undefined) {
					reject();
				}
				else {
					let locations = locationsFromString(output);
					resolve(locations);
				}
			});
		});
    }
}


class JaiDefinitionProvider implements vscode.DefinitionProvider {
	public provideDefinition(document: vscode.TextDocument, position: vscode.Position,
							 token: vscode.CancellationToken):
	vscode.ProviderResult<vscode.Definition | vscode.DefinitionLink[]> {
		return new Promise<vscode.Definition>((resolve, reject) => {
			jaiLocate(document.fileName, position, "Definition").then(output => {
				if (output === undefined) {
					reject();
				}
				else {
					let locations = locationsFromString(output, true);
					resolve(locations[0]);
				}
			});
		});
	}
}


class JaiRenameProvider implements vscode.RenameProvider {
	public provideRenameEdits(document: vscode.TextDocument, position: vscode.Position, newName: string,
							  token: vscode.CancellationToken):
	Thenable<vscode.WorkspaceEdit> {
		return new Promise<vscode.WorkspaceEdit>((resolve, reject) => {
			jaiLocate(document.fileName, position, "Rename").then(output => {
				if (output === undefined) {
					reject();
				}
				else {
					let locations = locationsFromString(output);
					let result = new vscode.WorkspaceEdit();
					for (let i = 0; i < locations.length; i++) {
						let location = locations[i];
						console.log(location.uri.fsPath);
						result.replace(location.uri, location.range, newName);
					}
					console.log(result);
					resolve(result);
				}
			});
		});
	}
}


async function jaiLocate(filepath: string, position: vscode.Position, operation: string): Promise<string | undefined> {
	let config = vscode.workspace.getConfiguration('the-language');
	let exe_path = config.get("pathToJaiExecutable");
	if (exe_path === undefined) return;

	let extension = vscode.extensions.getExtension("onelivesleft.the-language");
	if (extension === undefined) return;
	let modulepath = path.join(extension.extensionPath, "src", "modules").replace(/\//, '\\');

	let normalized = filepath.replace(/\\/g, '/');


	let args : string [] = [
		"-import_dir",
		modulepath,
		"-meta",
		"VSCodeLocate",
		filepath,
		"--",
		normalized,
		(position.line + 1).toString(),
		(position.character + 1).toString(),
		operation
	];

	return execCommand(exe_path as string, args);
}


function execCommand(exe_path: string, args: string[]): Promise<string | undefined> {
	return new Promise((resolve, reject) => {
		proc.execFile(exe_path, args, (error, stdout, stderr) => {
			if (error) {
				console.log(error);
				console.log(stderr);
				reject(error);
			}
			else {
				resolve(stdout);
			}
		});
	});
}


function locationsFromString(locations: string, firstLineOnly: boolean = false): vscode.Location[] {
	//console.log(locations);
	let result : vscode.Location[] = [];
	for (let row of locations.split("\n")) {
		if (!row.trim()) continue;
		let items = row.split("|");
		let uri = vscode.Uri.file(items[0]);
		let startPosition = new vscode.Position(parseInt(items[1]) - 1, parseInt(items[2]) - 1);
		let endPosition = new vscode.Position(parseInt(items[3]) - 1, parseInt(items[4]) - 1);
		let location = new vscode.Location(uri, new vscode.Range(startPosition, endPosition));
		result.push(location);
		if (firstLineOnly) break;
	}

	return result;
}
