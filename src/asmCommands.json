{

    "vpmovwb": {
        "detail": [
            "Down Convert Word to Byte"
        ],
        "documentation": [
            "VPMOVWB down converts 16-bit integers into packed bytes using truncation. VPMOVSWB converts signed 16-bit integers into packed signed bytes using signed saturation. VPMOVUSWB convert unsigned word values into unsigned byte values using unsigned saturation.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.",
            "Down-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.",
            "Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.x",
            "mem.q, reg.q, reg.x",
            "mem.q, reg.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVWB:VPMOVSWB:VPMOVUSWB.html"
        ]
    },
    "vfnmsubpd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "insertps": {
        "detail": [
            "Insert Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "(register source form)",
            "Copy a single-precision scalar floating-point element into a 128-bit vector register. The immediate operand has three fields, where the ZMask bits specify which elements of the destination will be set to zero, the Count_D bits specify which element of the destination will be overwritten with the scalar value, and for vector register sources the Count_S bits specify which element of the source will be copied. When the scalar source is a memory operand the Count_S bits are ignored.",
            "(memory source form)",
            "Load a floating-point element from a 32-bit memory location and destination operand it into the first source at the location indicated by the Count_D bits of the immediate operand. Store in the destination and zero out destination elements based on the ZMask bits of the immediate operand.",
            "128-bit Legacy SSE version: The first source register is an XMM register. The second source operand is either an XMM register or a 32-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "VEX.128 and EVEX encoded version: The destination and first source register is an XMM register. The second source operand is either an XMM register or a 32-bit memory location. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "If VINSERTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.d, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/INSERTPS.html"
        ]
    },
    "pcmpestri": {
        "detail": [
            "Packed Compare Explicit Length Strings, Return Index"
        ],
        "documentation": [
            "The instruction compares and processes data from two string fragments based on the encoded value in the Imm8 Control Byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates an index stored to the count register (ECX).",
            "Each string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). The second value is stored in an input length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length represents the number of bytes/words which are valid for the respective xmm/m128 data.",
            "The length of each input is interpreted as being the absolute-value of the value in the length register. The absolute-value computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value in the length register is greater than 16 (8) or less than -16 (-8).",
            "The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see Section 4.1). The index of the first (or last, according to imm8[6]) set bit of IntRes2 (see Section 4.1.4) is returned in ECX. If no bits are set in IntRes2, ECX is set to 16 (8).",
            "Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:",
            "CFlag – Reset if IntRes2 is equal to zero, set otherwise",
            "ZFlag – Set if absolute-value of EDX is < 16 (8), reset otherwise",
            "SFlag – Set if absolute-value of EAX is < 16 (8), reset otherwise",
            "OFlag – IntRes2[0]",
            "AFlag – Reset",
            "PFlag – Reset"
        ],
        "operands": [
            "reg.x, reg.x, imm.b, reg, reg, reg",
            "reg.x, mem.x, imm.b, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPESTRI.html"
        ]
    },
    "endbr64": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "pcmpestrm": {
        "detail": [
            "Packed Compare Explicit Length Strings, Return Mask"
        ],
        "documentation": [
            "The instruction compares data from two string fragments based on the encoded value in the imm8 contol byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates a mask stored to XMM0.",
            "Each string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). The second value is stored in an input length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length represents the number of bytes/words which are valid for the respective xmm/m128 data.",
            "The length of each input is interpreted as being the absolute-value of the value in the length register. The absolute-value computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value in the length register is greater than 16 (8) or less than -16 (-8).",
            "The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see Section 4.1). As defined by imm8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.",
            "Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:",
            "CFlag – Reset if IntRes2 is equal to zero, set otherwise",
            "ZFlag – Set if absolute-value of EDX is < 16 (8), reset otherwise",
            "SFlag – Set if absolute-value of EAX is < 16 (8), reset otherwise",
            "OFlag –IntRes2[0]",
            "AFlag – Reset",
            "PFlag – Reset",
            "Note: In VEX.128 encoded versions, bits (MAXVL-1:128) of XMM0 are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.x, reg.x, imm.b, reg, reg, reg.x",
            "reg.x, mem.x, imm.b, reg, reg, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPESTRM.html"
        ]
    },
    "blsfill": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://"
        ]
    },
    "fidivr": {
        "detail": [
            "Reverse Divide"
        ],
        "documentation": [
            "Divides the source operand by the destination operand and stores the result in the destination location. The destination operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format.",
            "These instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions. They are provided to support more efficient coding.",
            "The no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1) register. The one-operand version divides the contents of a memory location (either a floating-point or an integer value) by the contents of the ST(0) register. The two-operand version, divides the contents of the ST(i) register by the contents of the ST(0) register or vice versa.",
            "The FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIVR rather than FDIVRP.",
            "The FIDIVR instructions convert an integer source operand to double extended-precision floating-point format before performing the division.",
            "If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.",
            "The following table shows the results obtained when dividing various classes of numbers, assuming that neither overflow nor underflow occurs."
        ],
        "operands": [
            "reg.wq, mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FDIVR:FDIVRP:FIDIVR.html"
        ]
    },
    "fstp": {
        "detail": [
            "Store Floating Point Value"
        ],
        "documentation": [
            "The FST instruction copies the value in the ST(0) register to the destination operand, which can be a memory location or another register in the FPU register stack. When storing the value in memory, the value is converted to single-precision or double-precision floating-point format.",
            "The FSTP instruction performs the same operation as the FST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FSTP instruction can also store values in memory in double extended-precision floating-point format.",
            "If the destination operand is a memory location, the operand specifies the address where the first byte of the destination value is to be stored. If the destination operand is a register, the operand specifies a register in the register stack relative to the top of the stack.",
            "If the destination size is single-precision or double-precision, the significand of the value being stored is rounded to the width of the destination (according to the rounding mode specified by the RC field of the FPU control word), and the exponent is converted to the width and bias of the destination format. If the value being stored is too large for the destination format, a numeric overflow exception (#O) is generated and, if the exception is unmasked, no value is stored in the destination operand. If the value being stored is a denormal value, the denormal exception (#D) is not generated. This condition is simply signaled as a numeric underflow exception (#U) condition.",
            "If the value being stored is ±0, ±∞, or a NaN, the least-significant bits of the significand and the exponent are truncated to fit the destination format. This operation preserves the value’s identity as a 0, ∞, or NaN.",
            "If the destination operand is a non-empty register, the invalid-operation exception is not generated.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg",
            "mem.d, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FST:FSTP.html"
        ]
    },
    "vfnmsubps": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "fnstsw": {
        "detail": [
            "Store x87 FPU Status Word"
        ],
        "documentation": [
            "Stores the current value of the x87 FPU status word in the destination location. The destination operand can be either a two-byte memory location or the AX register. The FSTSW instruction checks for and handles pending unmasked floating-point exceptions before storing the status word; the FNSTSW instruction does not.",
            "The FNSTSW AX form of the instruction is used primarily in conditional branching (for instance, after an FPU comparison instruction or an FPREM, FPREM1, or FXAM instruction), where the direction of the branch depends on the state of the FPU condition code flags. (See the section titled “Branching and Conditional Moves on FPU Condition Codes” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.) This instruction can also be used to invoke exception handlers (by examining the exception flags) in environments that do not use interrupts. When the FNSTSW AX instruction is executed, the AX register is updated before the processor executes any further instructions. The status stored in the AX register is thus guaranteed to be from the completion of the prior FPU instruction.",
            "The assembler issues two instructions for the FSTSW instruction (an FWAIT instruction followed by an FNSTSW instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg, reg",
            "mem.w, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FSTSW:FNSTSW.html"
        ]
    },
    "xsaveopt64": {
        "detail": [
            "Save Processor Extended States Optimized"
        ],
        "documentation": [
            "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.",
            "The format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Section 13.9, “Operation of XSAVEOPT,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XSAVEOPT instruction. The following items provide a high-level outline:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.z[4096], reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XSAVEOPT.html"
        ]
    },
    "bndldx": {
        "detail": [
            "Load Extended Bounds Using Address Translation"
        ],
        "documentation": [
            "BNDLDX uses the linear address constructed from the base register and displacement of the SIB-addressing form of the memory operand (mib) to perform address translation to access a bound table entry and conditionally load the bounds in the BTE to the destination. The destination register is updated with the bounds in the BTE, if the content of the index register of mib matches the pointer value stored in the BTE.",
            "If the pointer value comparison fails, the destination is updated with INIT bounds (lb = 0x0, ub = 0x0) (note: as articulated earlier, the upper bound is represented using 1's complement, therefore, the 0x0 value of upper bound allows for access to full memory).",
            "This instruction does not cause memory access to the linear address of mib nor the effective address referenced by the base, and does not read or write any flags.",
            "Segment overrides apply to the linear address computation with the base of mib, and are used during address translation to generate the address of the bound table entry. By default, the address of the BTE is assumed to be linear address. There are no segmentation checks performed on the base of mib.",
            "The base of mib will not be checked for canonical address violation as it does not access memory.",
            "Any encoding of this instruction that does not specify base or index register will treat those registers as zero (constant). The reg-reg form of this instruction will remain a NOP.",
            "The scale field of the SIB byte has no effect on these instructions and is ignored.",
            "The bound register may be partially updated on memory faults. The order in which memory operands are loaded is implementation specific.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, mem.qx"
        ],
        "url": [
            "https://felixcloutier.com/x86/BNDLDX.html"
        ]
    },
    "pmaddubsw": {
        "detail": [
            "Multiply and Add Packed Signed and Unsigned Bytes"
        ],
        "documentation": [
            "(V)PMADDUBSW multiplies vertically each unsigned byte of the destination operand (first operand) with the corresponding signed byte of the source operand (second operand), producing intermediate signed 16-bit integers. Each adjacent pair of signed words is added and the saturated result is packed to the destination operand. For example, the lowest-order bytes (bits 7-0) in the source and destination operands are multiplied and the intermediate signed word result is added with the corresponding intermediate result from the 2nd lowest-order bytes (bits 15-8) of the operands; the sign-saturated result is stored in the lowest word of the destination register (15-0). The same operation is performed on the other pairs of adjacent bytes. Both operands can be MMX register or XMM registers. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "In 64-bit mode and not encoded with VEX/EVEX, use the REX prefix to access XMM8-XMM15.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX.512 encoded version: The second source operand can be an ZMM register or a 512-bit memory location. The first source and destination operands are ZMM registers."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMADDUBSW.html"
        ]
    },
    "fxsave": {
        "detail": [
            "Save x87 FPU, MMX Technology, and SSE State"
        ],
        "documentation": [
            "Saves the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory location specified in the destination operand. The content layout of the 512 byte region depends on whether the processor is operating in non-64-bit operating modes or 64-bit sub-mode of IA-32e mode.",
            "Bytes 464:511 are available to software use. The processor does not write to bytes 464:511 of an FXSAVE area.",
            "The operation of FXSAVE in non-64-bit modes is described first."
        ],
        "operands": [
            "mem.[4096], reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FXSAVE.html"
        ]
    },
    "pcmpgtb": {
        "detail": [
            "Compare Packed Signed Integers for Greater Than"
        ],
        "documentation": [
            "Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding date element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.",
            "The PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPGTD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "EVEX encoded VPCMPGTB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPGTB:PCMPGTW:PCMPGTD.html"
        ]
    },
    "sha256rnds2": {
        "detail": [
            "Perform Two Rounds of SHA256 Operation"
        ],
        "documentation": [
            "The SHA256RNDS2 instruction performs 2 rounds of SHA256 operation using an initial SHA256 state (C,D,G,H) from the first operand, an initial SHA256 state (A,B,E,F) from the second operand, and a pre-computed sum of the next 2 round message dwords and the corresponding round constants from the implicit operand xmm0. Note that only the two lower dwords of XMM0 are used by the instruction.",
            "The updated SHA256 state (A,B,E,F) is written to the first operand, and the second operand can be used as the updated state (C,D,G,H) in later rounds.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/SHA256RNDS2.html"
        ]
    },
    "pcmpgtd": {
        "detail": [
            "Compare Packed Signed Integers for Greater Than"
        ],
        "documentation": [
            "Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding date element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.",
            "The PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPGTD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "EVEX encoded VPCMPGTB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPGTB:PCMPGTW:PCMPGTD.html"
        ]
    },
    "fsub": {
        "detail": [
            "Subtract"
        ],
        "documentation": [
            "Subtracts the source operand from the destination operand and stores the difference in the destination location. The destination operand is always an FPU data register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.",
            "The no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floating-point or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.",
            "The FSUBP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUB rather than FSUBP.",
            "The FISUB instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.",
            "Table 3-38 shows the results obtained when subtracting various classes of numbers from one another, assuming that neither overflow nor underflow occurs. Here, the SRC value is subtracted from the DEST value (DEST − SRC = result).",
            "When the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.",
            "When one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalidoperation exception is generated."
        ],
        "operands": [
            "reg.wq, mem.d, reg",
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FSUB:FSUBP:FISUB.html"
        ]
    },
    "vphsubdq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "blsi": {
        "detail": [
            "Extract Lowest Set Isolated Bit"
        ],
        "documentation": [
            "Extracts the lowest set bit from the source operand and set the corresponding bit in the destination register. All other bits in the destination operand are zeroed. If no bits are set in the source operand, BLSI sets all the bits in the destination to 0 and sets ZF and CF.",
            "This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
            "Flags Affected:",
            "ZF and SF are updated based on the result. CF is set if the source is not zero. OF flags are cleared. AF and PF flags are undefined."
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/BLSI.html"
        ]
    },
    "loadiwkey": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.d, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "pmulhw": {
        "detail": [
            "Multiply Packed Signed Integers and Store High Result"
        ],
        "documentation": [
            "Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each intermediate 32-bit result in the destination operand. (Figure 4-12 shows this operation when using 64-bit operands.)",
            "n 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMULHW.html"
        ]
    },
    "pcmpgtq": {
        "detail": [
            "Compare Packed Data for Greater Than"
        ],
        "documentation": [
            "Performs an SIMD signed compare for the packed quadwords in the destination operand (first operand) and the source operand (second operand). If the data element in the first (destination) operand is greater than the corresponding element in the second (source) operand, the corresponding data element in the destination is set to all 1s; otherwise, it is set to 0s.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPGTD/Q: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPGTQ.html"
        ]
    },
    "movdiri": {
        "detail": [
            "Move Doubleword as Direct Store"
        ],
        "documentation": [
            "Moves the doubleword integer in the source operand (second operand) to the destination operand (first operand) using a direct-store operation. The source operand is a general purpose register. The destination operand is a 32-bit memory location. In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See summary chart at the beginning of this section for encoding data and limits.",
            "The direct-store is implemented by using write combining (WC) memory type protocol for writing data. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. If the destination address is cached, the line is written-back (if modified) and invalidated from the cache, before the direct-store. Unlike stores with non-temporal hint that allow uncached (UC) and write-protected (WP) memory-type for the destination to override the non-temporal hint, direct-stores always follow WC memory type protocol irrespective of the destination address memory type (including UC and WP types).",
            "Unlike WC stores and stores with non-temporal hint, direct-stores are eligible for immediate eviction from the write-combining buffer, and thus not combined with younger stores (including direct-stores) to the same address. Older WC and non-temporal stores held in the write-combing buffer may be combined with younger direct stores to the same address. Because WC protocol used by direct-stores follows a weakly-ordered memory consistency model, a fencing operation using SFENCE or MFENCE should follow the MOVDIRI instruction to enforce ordering when needed.",
            "Direct-stores issued by MOVDIRI to a destination aligned to a 4-byte boundary (8-byte boundary if used with REX.W prefix) guarantee 4-byte (8-byte with REX.W prefix) write-completion atomicity. This means that the data arrives at the destination in a single undivided 4-byte (or 8-byte) write transaction. If the destination is not aligned for the write size, the direct-stores issued by MOVDIRI are split and arrive at the destination in two parts. Each part of such split direct-store will not merge with younger stores but can arrive at the destination in either order. Availability of the MOVDIRI instruction is indicated by the presence of the CPUID feature flag MOVDIRI (bit 27 of the ECX register in leaf 07H, see “CPUID—CPU Identification” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A)."
        ],
        "operands": [
            "mem.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVDIRI.html"
        ]
    },
    "blsr": {
        "detail": [
            "Reset Lowest Set Bit"
        ],
        "documentation": [
            "Copies all bits from the source operand to the destination operand and resets (=0) the bit position in the destination operand that corresponds to the lowest set bit of the source operand. If the source operand is zero BLSR sets CF.",
            "This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
            "Flags Affected:",
            "ZF and SF flags are updated based on the result. CF is set if the source is zero. OF flag is cleared. AF and PF flags are undefined."
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/BLSR.html"
        ]
    },
    "pcmpgtw": {
        "detail": [
            "Compare Packed Signed Integers for Greater Than"
        ],
        "documentation": [
            "Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding date element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.",
            "The PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPGTD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "EVEX encoded VPCMPGTB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPGTB:PCMPGTW:PCMPGTD.html"
        ]
    },
    "kshiftlb": {
        "detail": [
            "Shift Left Mask Registers"
        ],
        "documentation": [
            "Shifts 8/16/32/64 bits in the second operand (source operand) left by the count specified in immediate byte and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/KSHIFTLW:KSHIFTLB:KSHIFTLQ:KSHIFTLD.html"
        ]
    },
    "kshiftld": {
        "detail": [
            "Shift Left Mask Registers"
        ],
        "documentation": [
            "Shifts 8/16/32/64 bits in the second operand (source operand) left by the count specified in immediate byte and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/KSHIFTLW:KSHIFTLB:KSHIFTLQ:KSHIFTLD.html"
        ]
    },
    "vpmultishiftqb": {
        "detail": [
            "Select Packed Unaligned Bytes from Quadword Sources"
        ],
        "documentation": [
            "This instruction selects eight unaligned bytes from each input qword element of the second source operand (the third operand) and writes eight assembled bytes for each qword element in the destination operand (the first operand). Each byte result is selected using a byte-granular shift control within the corresponding qword element of the first source operand (the second operand). Each byte result in the destination operand is updated under the writemask k1.",
            "Only the low 6 bits of each control byte are used to select an 8-bit slot to extract the output byte from the qword data in the second source operand. The starting bit of the 8-bit slot can be unaligned relative to any byte boundary and is extracted from the input qword source at the location specified in the low 6-bit of the control byte. If the 8-bit slot would exceed the qword boundary, the out-of-bound portion of the 8-bit slot is wrapped back to start from bit 0 of the input qword element.",
            "The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMULTISHIFTQB.html"
        ]
    },
    "fisubr": {
        "detail": [
            "Reverse Subtract"
        ],
        "documentation": [
            "Subtracts the destination operand from the source operand and stores the difference in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.",
            "These instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided to support more efficient coding.",
            "The no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.",
            "The FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point reverse subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUBR rather than FSUBRP.",
            "The FISUBR instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.",
            "The following table shows the results obtained when subtracting various classes of numbers from one another, assuming that neither overflow nor underflow occurs. Here, the DEST value is subtracted from the SRC value (SRC − DEST = result).",
            "When the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.",
            "When one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalidoperation exception is generated."
        ],
        "operands": [
            "reg.wq, mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FSUBR:FSUBRP:FISUBR.html"
        ]
    },
    "rdrand": {
        "detail": [
            "Read Random Number"
        ],
        "documentation": [
            "Loads a hardware generated random value and store it in the destination register. The size of the random value is determined by the destination register size and operating mode. The Carry Flag indicates whether a random value is available at the time the instruction is executed. CF=1 indicates that the data in the destination is valid. Otherwise CF=0 and the data in the destination operand will be returned as zeros for the specified width. All other flags are forced to 0 in either situation. Software must check the state of CF=1 for determining if a valid random value has been returned, otherwise it is expected to loop and retry execution of RDRAND (see Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, Section 7.3.17, “Random Number Generator Instructions”).",
            "This instruction is available at all privilege levels.",
            "In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.B permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit operands. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The CF flag is set according to the result (see the “Operation” section above). The OF, SF, ZF, AF, and PF flags are set to 0."
        ],
        "operands": [
            "reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/RDRAND.html"
        ]
    },
    "rmpadjust": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, reg, reg"
        ],
        "url": [
            "https://"
        ]
    },
    "kshiftlq": {
        "detail": [
            "Shift Left Mask Registers"
        ],
        "documentation": [
            "Shifts 8/16/32/64 bits in the second operand (source operand) left by the count specified in immediate byte and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/KSHIFTLW:KSHIFTLB:KSHIFTLQ:KSHIFTLD.html"
        ]
    },
    "vcvttpd2dq": {
        "detail": [
            "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers"
        ],
        "documentation": [
            "Converts two, four or eight packed double-precision floating-point values in the source operand (second operand) to two, four or eight packed signed doubleword integers in the destination operand (first operand).",
            "When a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM/XMM/XMM (low 64 bits) register conditionally updated with writemask k1. The upper bits (MAXVL-1:256) of the corresponding destination are zeroed.",
            "VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:64) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.y, reg.q, mem.z",
            "reg.y, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTTPD2DQ.html"
        ]
    },
    "kshiftlw": {
        "detail": [
            "Shift Left Mask Registers"
        ],
        "documentation": [
            "Shifts 8/16/32/64 bits in the second operand (source operand) left by the count specified in immediate byte and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/KSHIFTLW:KSHIFTLB:KSHIFTLQ:KSHIFTLD.html"
        ]
    },
    "vblendvpd": {
        "detail": [
            "Variable Blend Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Conditionally copy each quadword data element of double-precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each quadword element of the mask register.",
            "Each quadword element of the destination operand is copied from:"
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/BLENDVPD.html"
        ]
    },
    "vpmacssdqh": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpmacssdql": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "pblendw": {
        "detail": [
            "Blend Packed Words"
        ],
        "documentation": [
            "Words from the source operand (second operand) are conditionally written to the destination operand (first operand) depending on bits in the immediate operand (third operand). The immediate bits (bits 7:0) form a mask that determines whether the corresponding word in the destination is copied from the source. If a bit in the mask, corresponding to a word, is “1\", then the word is copied, else the word element in the destination operand is unchanged.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PBLENDW.html"
        ]
    },
    "vminsd": {
        "detail": [
            "Return Minimum Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Compares the low double-precision floating-point values in the first source operand and the second source operand, and returns the minimum value to the low quadword of the destination operand. When the source operand is a memory operand, only the 64 bits are accessed.",
            "If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, then SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second source) be returned, the action of MINSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.",
            "The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination operand is updated according to the writemask.",
            "Software should ensure VMINSD is encoded with VEX.L=0. Encoding VMINSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MINSD.html"
        ]
    },
    "clc": {
        "detail": [
            "Clear Carry Flag"
        ],
        "documentation": [
            "Clears the CF flag in the EFLAGS register. Operation is the same in all modes.",
            "Flags Affected:",
            "The CF flag is set to 0. The OF, ZF, SF, AF, and PF flags are unaffected."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/CLC.html"
        ]
    },
    "cld": {
        "detail": [
            "Clear Direction Flag"
        ],
        "documentation": [
            "Clears the DF flag in the EFLAGS register. When the DF flag is set to 0, string operations increment the index registers (ESI and/or EDI). Operation is the same in all modes.",
            "Flags Affected:",
            "The DF flag is set to 0. The CF, OF, ZF, SF, AF, and PF flags are unaffected."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/CLD.html"
        ]
    },
    "vblendvps": {
        "detail": [
            "Variable Blend Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Conditionally copy each dword data element of single-precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each dword element of the mask register.",
            "Each quadword element of the destination operand is copied from:"
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/BLENDVPS.html"
        ]
    },
    "prefetchw": {
        "detail": [
            "Prefetch Data into Caches in Anticipation of a Write"
        ],
        "documentation": [
            "Fetches the cache line of data from memory that contains the byte specified with the source operand to a location in the 1st or 2nd level cache and invalidates other cached instances of the line.",
            "The source operand is a byte memory location. If the line selected is already present in the lowest level cache and is already in an exclusively owned state, no data movement occurs. Prefetches from non-writeback memory are ignored.",
            "The PREFETCHW instruction is merely a hint and does not affect program behavior. If executed, this instruction moves data closer to the processor and invalidates other cached copies in anticipation of the line being written to in the future.",
            "The characteristic of prefetch locality hints is implementation-dependent, and can be overloaded or ignored by a processor implementation. The amount of data prefetched is also processor implementation-dependent. It will, however, be a minimum of 32 bytes. Additional details of the implementation-dependent locality hints are described in Section 7.4 of Intel® 64 and IA-32 Architectures Optimization Reference Manual.",
            "It should be noted that processors are free to speculatively fetch and cache data with exclusive ownership from system memory regions that permit such accesses (that is, the WB memory type). A PREFETCHW instruction is considered a hint to this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, a PREFETCHW instruction is not ordered with respect to the fence instructions (MFENCE, SFENCE, and LFENCE) or locked memory references. A PREFETCHW instruction is also unordered with respect to CLFLUSH and CLFLUSHOPT instructions, other PREFETCHW instructions, or any other general instruction",
            "It is ordered with respect to serializing instructions such as CPUID, WRMSR, OUT, and MOV CR.",
            "This instruction's operation is the same in non-64-bit modes and 64-bit mode.",
            "Flags Affected:",
            "All flags are affected."
        ],
        "operands": [
            "mem.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/PREFETCHW.html"
        ]
    },
    "cli": {
        "detail": [
            "Clear Interrupt Flag"
        ],
        "documentation": [
            "In most cases, CLI clears the IF flag in the EFLAGS register and no other flags are affected. Clearing the IF flag causes the processor to ignore maskable external interrupts. The IF flag and the CLI and STI instruction have no effect on the generation of exceptions and NMI interrupts.",
            "Operation is different in two modes defined as follows:",
            "Flags Affected:",
            "Either the IF flag or the VIF flag is cleared to 0. Other flags are unaffected."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/CLI.html"
        ]
    },
    "pcmpeqd": {
        "detail": [
            "Compare Packed Data for Equal"
        ],
        "documentation": [
            "Performs a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.",
            "The (V)PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the (V)PCMPEQW instruction compares the corresponding words in the destination and source operands; and the (V)PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPEQD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "EVEX encoded VPCMPEQB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html"
        ]
    },
    "pcmpeqb": {
        "detail": [
            "Compare Packed Data for Equal"
        ],
        "documentation": [
            "Performs a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.",
            "The (V)PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the (V)PCMPEQW instruction compares the corresponding words in the destination and source operands; and the (V)PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPEQD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "EVEX encoded VPCMPEQB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html"
        ]
    },
    "vrangepd": {
        "detail": [
            "Range Restriction Calculation For Packed Pairs of Float64 Values"
        ],
        "documentation": [
            "This instruction calculates 2/4/8 range operation outputs from two sets of packed input double-precision FP values in the first source operand (the second operand) and the second source operand (the third operand). The range outputs are written to the destination operand (the first operand) under the writemask k1.",
            "Bits7:4 of imm8 byte must be zero. The range operation output is performed in two parts, each configured by a two-bit control field within imm8[3:0]:"
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRANGEPD.html"
        ]
    },
    "vminss": {
        "detail": [
            "Return Minimum Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Compares the low single-precision floating-point values in the first source operand and the second source operand and returns the minimum value to the low doubleword of the destination operand.",
            "If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN in either source operand be returned, the action of MINSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.",
            "The second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL:32) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded version: The first source operand is an xmm register encoded by (E)VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination operand is updated according to the writemask.",
            "Software should ensure VMINSS is encoded with VEX.L=0. Encoding VMINSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/MINSS.html"
        ]
    },
    "blsmsk": {
        "detail": [
            "Get Mask Up to Lowest Set Bit"
        ],
        "documentation": [
            "Sets all the lower bits of the destination operand to “1” up to and including lowest set bit (=1) in the source operand. If source operand is zero, BLSMSK sets all bits of the destination operand to 1 and also sets CF to 1.",
            "This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
            "Flags Affected:",
            "SF is updated based on the result. CF is set if the source if zero. ZF and OF flags are cleared. AF and PF flag are undefined."
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/BLSMSK.html"
        ]
    },
    "popcnt": {
        "detail": [
            "Return the Count of Number of Bits Set to 1"
        ],
        "documentation": [
            "This instruction calculates the number of bits set to 1 in the second operand (source) and returns the count in the first operand (a destination register).",
            "Flags Affected:",
            "OF, SF, ZF, AF, CF, PF are all cleared. ZF is set if SRC = 0, otherwise ZF is cleared."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/POPCNT.html"
        ]
    },
    "pcmpeqq": {
        "detail": [
            "Compare Packed Qword Data for Equal"
        ],
        "documentation": [
            "Performs an SIMD compare for equality of the packed quadwords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination is set to all 1s; otherwise, it is set to 0s.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPEQQ: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPEQQ.html"
        ]
    },
    "lwpins": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.d, imm.d",
            "reg.d, mem.d, imm.d"
        ],
        "url": [
            "https://"
        ]
    },
    "vpavgb": {
        "detail": [
            "Average Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD average of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the results in the destination operand. For each corresponding pair of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary sum, and that result is shifted right one bit position.",
            "The (V)PAVGB instruction operates on packed unsigned bytes and the (V)PAVGW instruction operates on packed unsigned words.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register or a 512-bit memory location. The destination operand is a ZMM register.",
            "VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PAVGB:PAVGW.html"
        ]
    },
    "pcmpeqw": {
        "detail": [
            "Compare Packed Data for Equal"
        ],
        "documentation": [
            "Performs a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.",
            "The (V)PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the (V)PCMPEQW instruction compares the corresponding words in the destination and source operands; and the (V)PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPEQD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "EVEX encoded VPCMPEQB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html"
        ]
    },
    "vrangeps": {
        "detail": [
            "Range Restriction Calculation For Packed Pairs of Float32 Values"
        ],
        "documentation": [
            "This instruction calculates 4/8/16 range operation outputs from two sets of packed input single-precision FP values in the first source operand (the second operand) and the second source operand (the third operand). The range outputs are written to the destination operand (the first operand) under the writemask k1.",
            "Bits7:4 of imm8 byte must be zero. The range operation output is performed in two parts, each configured by a two-bit control field within imm8[3:0]:"
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRANGEPS.html"
        ]
    },
    "emms": {
        "detail": [
            "Empty MMX Technology State"
        ],
        "documentation": [
            "Sets the values of all the tags in the x87 FPU tag word to empty (all 1s). This operation marks the x87 FPU data registers (which are aliased to the MMX technology registers) as available for use by x87 FPU floating-point instructions. (See Figure 8-7 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for the format of the x87 FPU tag word.) All other MMX instructions (other than the EMMS instruction) set all the tags in x87 FPU tag word to valid (all 0s).",
            "The EMMS instruction must be used to clear the MMX technology state at the end of all MMX technology procedures or subroutines and before calling other procedures or subroutines that may execute x87 floating-point instructions. If a floating-point instruction loads one of the registers in the x87 FPU data register stack before the x87 FPU tag word has been reset by the EMMS instruction, an x87 floating-point register stack overflow can occur that will result in an x87 floating-point exception or incorrect result.",
            "EMMS operation is the same in non-64-bit modes and 64-bit mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/EMMS.html"
        ]
    },
    "aesencwide128kl": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.xy, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vperm2i128": {
        "detail": [
            "Permute Integer Values"
        ],
        "documentation": [
            "Permute 128 bit integer data from the first source operand (second operand) and second source operand (third operand) using bits in the 8-bit immediate and store results in the destination operand (first operand). The first source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and the destination operand is a YMM register."
        ],
        "operands": [
            "reg.y, reg.y, mem.y, imm.b",
            "reg.y, reg.y, reg.y, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERM2I128.html"
        ]
    },
    "vpavgw": {
        "detail": [
            "Average Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD average of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the results in the destination operand. For each corresponding pair of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary sum, and that result is shifted right one bit position.",
            "The (V)PAVGB instruction operates on packed unsigned bytes and the (V)PAVGW instruction operates on packed unsigned words.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register or a 512-bit memory location. The destination operand is a ZMM register.",
            "VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PAVGB:PAVGW.html"
        ]
    },
    "setb": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "bndstx": {
        "detail": [
            "Store Extended Bounds Using Address Translation"
        ],
        "documentation": [
            "BNDSTX uses the linear address constructed from the displacement and base register of the SIB-addressing form of the memory operand (mib) to perform address translation to store to a bound table entry. The bounds in the source operand bnd are written to the lower and upper bounds in the BTE. The content of the index register of mib is written to the pointer value field in the BTE.",
            "This instruction does not cause memory access to the linear address of mib nor the effective address referenced by the base, and does not read or write any flags.",
            "Segment overrides apply to the linear address computation with the base of mib, and are used during address translation to generate the address of the bound table entry. By default, the address of the BTE is assumed to be linear address. There are no segmentation checks performed on the base of mib.",
            "The base of mib will not be checked for canonical address violation as it does not access memory.",
            "Any encoding of this instruction that does not specify base or index register will treat those registers as zero (constant). The reg-reg form of this instruction will remain a NOP.",
            "The scale field of the SIB byte has no effect on these instructions and is ignored.",
            "The bound register may be partially updated on memory faults. The order in which memory operands are loaded is implementation specific.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "mem.qx, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/BNDSTX.html"
        ]
    },
    "setl": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "vroundpd": {
        "detail": [
            "Round Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Round the 2 double-precision floating-point values in the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the results in the destination operand (first operand). The rounding process rounds each input floating-point value to an integer value and returns the integer result as a double-precision floating-point value.",
            "The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-17 lists the encoded values for rounding-mode field).",
            "The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.",
            "128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/ROUNDPD.html"
        ]
    },
    "pi2fd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "setp": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "cmc": {
        "detail": [
            "Complement Carry Flag"
        ],
        "documentation": [
            "Complements the CF flag in the EFLAGS register. CMC operation is the same in non-64-bit modes and 64-bit mode.",
            "Flags Affected:",
            "The CF flag contains the complement of its original value. The OF, ZF, SF, AF, and PF flags are unaffected."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/CMC.html"
        ]
    },
    "seto": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "sets": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "vgf2p8affineqb": {
        "detail": [
            "Galois Field Affine Transformation"
        ],
        "documentation": [
            "The AFFINEB instruction computes an affine transformation in the Galois Field 28. For this instruction, an affine transformation is defined by A * x + b where “A” is an 8 by 8 bit matrix, and “x” and “b” are 8-bit vectors. One SIMD register (operand 1) holds “x” as either 16, 32 or 64 8-bit vectors. A second SIMD (operand 2) register or memory operand contains 2, 4, or 8 “A” values, which are operated upon by the correspondingly aligned 8 “x” values in the first register. The “b” vector is constant for all calculations and contained in the immediate byte.",
            "The SSE encoded forms of the instruction require16B alignment on their memory operations."
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/GF2P8AFFINEQB.html"
        ]
    },
    "vmcall": {
        "detail": [
            "Call to VM Monitor"
        ],
        "documentation": [
            "This instruction allows guest software can make a call for service into an underlying VM monitor. The details of the programming interface for such calls are VMM-specific; this instruction does nothing more than cause a VM exit, registering the appropriate exit reason.",
            "Use of this instruction in VMX root operation invokes an SMM monitor (see Section 34.15.2). This invocation will activate the dual-monitor treatment of system-management interrupts (SMIs) and system-management mode (SMM) if it is not already active (see Section 34.15.6).",
            "Flags Affected:",
            "See the operation section and Section 30.2."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/VMCALL.html"
        ]
    },
    "vucomisd": {
        "detail": [
            "Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS"
        ],
        "documentation": [
            "Performs an unordered compare of the double-precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).",
            "Operand 1 is an XMM register; operand 2 can be an XMM register or a 64 bit memory",
            "location.",
            "The UCOMISD instruction differs from the COMISD instruction in that it signals a SIMD floating-point invalid operation exception (#I) only when a source operand is an SNaN. The COMISD instruction signals an invalid numeric exception only if a source operand is either an SNaN or a QNaN.",
            "The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCOMISD is encoded with VEX.L=0. Encoding VCOMISD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q",
            "reg.x, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/UCOMISD.html"
        ]
    },
    "setz": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "rstorssp": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vroundps": {
        "detail": [
            "Round Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Round the 4 single-precision floating-point values in the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the results in the destination operand (first operand). The rounding process rounds each input floating-point value to an integer value and returns the integer result as a single-precision floating-point value.",
            "The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-17 lists the encoded values for rounding-mode field).",
            "The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.",
            "128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/ROUNDPS.html"
        ]
    },
    "cmp": {
        "detail": [
            "Compare Two Operands"
        ],
        "documentation": [
            "Compares the first source operand with the second source operand and sets the status flags in the EFLAGS register according to the results. The comparison is performed by subtracting the second operand from the first operand and then setting the status flags in the same manner as the SUB instruction. When an immediate value is used as an operand, it is sign-extended to the length of the first operand.",
            "The condition codes used by the Jcc, CMOVcc, and SETcc instructions are based on the results of a CMP instruction. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the relationship of the status flags and the condition codes.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The CF, OF, SF, ZF, AF, and PF flags are set according to the result."
        ],
        "operands": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMP.html"
        ]
    },
    "fst": {
        "detail": [
            "Store Floating Point Value"
        ],
        "documentation": [
            "The FST instruction copies the value in the ST(0) register to the destination operand, which can be a memory location or another register in the FPU register stack. When storing the value in memory, the value is converted to single-precision or double-precision floating-point format.",
            "The FSTP instruction performs the same operation as the FST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FSTP instruction can also store values in memory in double extended-precision floating-point format.",
            "If the destination operand is a memory location, the operand specifies the address where the first byte of the destination value is to be stored. If the destination operand is a register, the operand specifies a register in the register stack relative to the top of the stack.",
            "If the destination size is single-precision or double-precision, the significand of the value being stored is rounded to the width of the destination (according to the rounding mode specified by the RC field of the FPU control word), and the exponent is converted to the width and bias of the destination format. If the value being stored is too large for the destination format, a numeric overflow exception (#O) is generated and, if the exception is unmasked, no value is stored in the destination operand. If the value being stored is a denormal value, the denormal exception (#D) is not generated. This condition is simply signaled as a numeric underflow exception (#U) condition.",
            "If the value being stored is ±0, ±∞, or a NaN, the least-significant bits of the significand and the exponent are truncated to fit the destination format. This operation preserves the value’s identity as a 0, ∞, or NaN.",
            "If the destination operand is a non-empty register, the invalid-operation exception is not generated.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg.wq, reg",
            "mem.d, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FST:FSTP.html"
        ]
    },
    "vfnmsubsd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.q, mem.q",
            "reg.x, reg.q, reg.q, reg.q",
            "reg.x, reg.q, mem.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "aesenc256kl": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.z"
        ],
        "url": [
            "https://"
        ]
    },
    "pi2fw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vmovdqu16": {
        "detail": [
            "Move Unaligned Packed Integer Values"
        ],
        "documentation": [
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX encoded versions:",
            "Moves 128, 256 or 512 bits of packed byte/word/doubleword/quadword integer values from the source operand (the second operand) to the destination operand (first operand). This instruction can be used to load a vector register from a memory location, to store the contents of a vector register into a memory location, or to move data between two vector registers.",
            "The destination operand is updated at 8-bit (VMOVDQU8), 16-bit (VMOVDQU16), 32-bit (VMOVDQU32), or 64-bit (VMOVDQU64) granularity according to the writemask.",
            "VEX.256 encoded version:",
            "Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.",
            "Bits (MAXVL-1:256) of the destination register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "mem.x, reg.q, reg.x",
            "mem.x, reg.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html"
        ]
    },
    "vucomiss": {
        "detail": [
            "Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS"
        ],
        "documentation": [
            "Compares the single-precision floating-point values in the low doublewords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).",
            "Operand 1 is an XMM register; operand 2 can be an XMM register or a 32 bit memory location.",
            "The UCOMISS instruction differs from the COMISS instruction in that it signals a SIMD floating-point invalid operation exception (#I) only if a source operand is an SNaN. The COMISS instruction signals an invalid numeric exception when a source operand is either a QNaN or SNaN.",
            "The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCOMISS is encoded with VEX.L=0. Encoding VCOMISS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.d",
            "reg.x, mem.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/UCOMISS.html"
        ]
    },
    "vfnmsubss": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.d, reg.d, mem.d",
            "reg.x, reg.d, reg.d, reg.d",
            "reg.x, reg.d, mem.d, reg.d"
        ],
        "url": [
            "https://"
        ]
    },
    "pcmpestriq": {
        "detail": [
            "Packed Compare Explicit Length Strings, Return Index"
        ],
        "documentation": [
            "The instruction compares and processes data from two string fragments based on the encoded value in the Imm8 Control Byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates an index stored to the count register (ECX).",
            "Each string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). The second value is stored in an input length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length represents the number of bytes/words which are valid for the respective xmm/m128 data.",
            "The length of each input is interpreted as being the absolute-value of the value in the length register. The absolute-value computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value in the length register is greater than 16 (8) or less than -16 (-8).",
            "The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see Section 4.1). The index of the first (or last, according to imm8[6]) set bit of IntRes2 (see Section 4.1.4) is returned in ECX. If no bits are set in IntRes2, ECX is set to 16 (8).",
            "Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:",
            "CFlag – Reset if IntRes2 is equal to zero, set otherwise",
            "ZFlag – Set if absolute-value of EDX is < 16 (8), reset otherwise",
            "SFlag – Set if absolute-value of EAX is < 16 (8), reset otherwise",
            "OFlag – IntRes2[0]",
            "AFlag – Reset",
            "PFlag – Reset"
        ],
        "operands": [
            "reg.x, reg.x, imm.b, reg, reg, reg",
            "reg.x, mem.x, imm.b, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPESTRI.html"
        ]
    },
    "andnpd": {
        "detail": [
            "Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical AND NOT of the two, four or eight packed double-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ANDNPD.html"
        ]
    },
    "pmulhrw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "rdmsr": {
        "detail": [
            "Read from Model Specific Register"
        ],
        "documentation": [
            "Reads the contents of a 64-bit model specific register (MSR) specified in the ECX register into registers EDX:EAX. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If fewer than 64 bits are implemented in the MSR being read, the values returned to EDX:EAX in unimplemented bit locations are undefined.",
            "This instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) will be generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a general protection exception.",
            "The MSRs control functions for testability, execution tracing, performance-monitoring, and machine check errors. Chapter 2, “Model-Specific Registers (MSRs)” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 4, lists all the MSRs that can be read with this instruction and their addresses. Note that each processor family has its own set of MSRs.",
            "The CPUID instruction should be used to determine whether MSRs are supported (CPUID.01H:EDX[5] = 1) before using this instruction.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/RDMSR.html"
        ]
    },
    "v4fmaddps": {
        "detail": [
            "Packed Single-Precision Floating-Point Fused Multiply-Add (4-iterations)"
        ],
        "documentation": [
            "This instruction computes 4 sequential packed fused single-precision floating-point multiply-add instructions with a sequentially selected memory operand in each of the four steps.",
            "In the above box, the notation of “+3” is used to denote that the instruction accesses 4 source registers based on that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.",
            "This instruction supports memory fault suppression. The entire memory operand is loaded if any of the 16 lowest significant mask bits is set to 1 or if a “no masking” encoding is used.",
            "The tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction.",
            "Rounding is performed at every FMA (fused multiply and add) boundary. Exceptions are also taken sequentially. Pre- and post-computational exceptions of the first FMA take priority over the pre- and post-computational exceptions of the second FMA, etc."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.z, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/V4FMADDPS:V4FNMADDPS.html"
        ]
    },
    "blendvpd": {
        "detail": [
            "Variable Blend Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Conditionally copy each quadword data element of double-precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each quadword element of the mask register.",
            "Each quadword element of the destination operand is copied from:"
        ],
        "operands": [
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/BLENDVPD.html"
        ]
    },
    "andnps": {
        "detail": [
            "Bitwise Logical AND NOT of Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical AND NOT of the four, eight or sixteen packed single-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ANDNPS.html"
        ]
    },
    "vphaddubd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "mpsadbw": {
        "detail": [
            "Compute Multiple Packed Sums of Absolute Difference"
        ],
        "documentation": [
            "(V)MPSADBW calculates packed word results of sum-absolute-difference (SAD) of unsigned bytes from two blocks of 32-bit dword elements, using two select fields in the immediate byte to select the offsets of the two blocks within the first source operand and the second operand. Packed SAD word results are calculated within each 128-bit lane. Each SAD word result is calculated between a stationary block_2 (whose offset within the second source operand is selected by a two bit select control, multiplied by 32 bits) and a sliding block_1 at consecutive byte-granular position within the first source operand. The offset of the first 32-bit block of block_1 is selectable using a one bit select control, multiplied by 32 bits.",
            "128-bit Legacy SSE version: Imm8[1:0]*32 specifies the bit offset of block_2 within the second source operand. Imm[2]*32 specifies the initial bit offset of the block_1 within the first source operand. The first source operand and destination operand are the same. The first source and destination operands are XMM registers. The second source operand is either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. Bits 7:3 of the immediate byte are ignored.",
            "VEX.128 encoded version: Imm8[1:0]*32 specifies the bit offset of block_2 within the second source operand. Imm[2]*32 specifies the initial bit offset of the block_1 within the first source operand. The first source and destination operands are XMM registers. The second source operand is either an XMM register or a 128-bit memory location. Bits (127:128) of the corresponding YMM register are zeroed. Bits 7:3 of the immediate byte are ignored.",
            "VEX.256 encoded version: The sum-absolute-difference (SAD) operation is repeated 8 times for MPSADW between the same block_2 (fixed offset within the second source operand) and a variable block_1 (offset is shifted by 8 bits for each SAD operation) in the first source operand. Each 16-bit result of eight SAD operations between block_2 and block_1 is written to the respective word in the lower 128 bits of the destination operand.",
            "Additionally, VMPSADBW performs another eight SAD operations on block_4 of the second source operand and block_3 of the first source operand. (Imm8[4:3]*32 + 128) specifies the bit offset of block_4 within the second source operand. (Imm[5]*32+128) specifies the initial bit offset of the block_3 within the first source operand. Each 16-bit result of eight SAD operations between block_4 and block_3 is written to the respective word in the upper 128 bits of the destination operand.",
            "The first source operand is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Bits 7:6 of the immediate byte are ignored.",
            "Note: If VMPSADBW is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/MPSADBW.html"
        ]
    },
    "vphaddubq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "blendvps": {
        "detail": [
            "Variable Blend Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Conditionally copy each dword data element of single-precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each dword element of the mask register.",
            "Each quadword element of the destination operand is copied from:"
        ],
        "operands": [
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/BLENDVPS.html"
        ]
    },
    "vphaddubw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vcvtps2pd": {
        "detail": [
            "Convert Packed Single-Precision Floating-Point Values to Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Converts two, four or eight packed single-precision floating-point values in the source operand (second operand) to two, four or eight packed double-precision floating-point values in the destination operand (first operand).",
            "EVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64-bits) register, a 256/128/64-bit memory location or a 256/128/64-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.",
            "VEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination operand is a XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination operand is an XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTPS2PD.html"
        ]
    },
    "vmovsd": {
        "detail": [
            "Move or Merge Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Moves a scalar double-precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be XMM registers or 64-bit memory locations. This instruction can be used to move a double-precision floating-point value to and from the low quadword of an XMM register and a 64-bit memory location, or to move a double-precision floating-point value between the low quadwords of two XMM registers. The instruction cannot be used to transfer data between memory locations.",
            "Legacy version: When the source and destination operands are XMM registers, bits MAXVL:64 of the destination operand remains unchanged. When the source operand is a memory location and destination operand is an XMM registers, the quadword at bits 127:64 of the destination operand is cleared to all 0s, bits MAXVL:128 of the destination operand remains unchanged.",
            "VEX and EVEX encoded register-register syntax: Moves a scalar double-precision floating-point value from the second source operand (the third operand) to the low quadword element of the destination operand (the first operand). Bits 127:64 of the destination operand are copied from the first source operand (the second operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX and EVEX encoded memory store syntax: When the source operand is a memory location and destination operand is an XMM registers, bits MAXVL:64 of the destination operand is cleared to all 0s.",
            "EVEX encoded versions: The low quadword of the destination is updated according to the writemask.",
            "Note: For VMOVSD (memory store and load forms), VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instruction will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.q, mem.q",
            "mem.q, reg.q, reg.x",
            "mem.q, reg.q",
            "reg.x, reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVSD.html"
        ]
    },
    "vcvtps2ph": {
        "detail": [
            "Convert Single-Precision FP value to 16-bit FP value"
        ],
        "documentation": [
            "Convert packed single-precision floating values in the source operand to half-precision (16-bit) floating-point values and store to the destination operand. The rounding mode is specified using the immediate field (imm8).",
            "Underflow results (i.e., tiny results) are converted to denormals. MXCSR.FTZ is ignored. If a source element is denormal relative to the input format with DM masked and at least one of PM or UM unmasked; a SIMD exception will be raised with DE, UE and PE set.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "mem.y, reg.q, reg.z, imm.b",
            "reg.y, reg.z, imm.b",
            "reg.y, reg.q, reg.z, imm.b",
            "mem.y, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTPS2PH.html"
        ]
    },
    "vpsrlvd": {
        "detail": [
            "Variable Bit Shift Right Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords or quadword) in the first source operand to the right by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0).",
            "The count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for word), 31 (for doublewords), or 63 (for a quadword), then the destination data element are written with 0.",
            "VEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded VPSRLVD/Q: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.",
            "EVEX encoded VPSRLVW: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is conditionally updated with writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPSRLVW:VPSRLVD:VPSRLVQ.html"
        ]
    },
    "fimul": {
        "detail": [
            "Multiply"
        ],
        "documentation": [
            "Multiplies the destination and source operands and stores the product in the destination location. The destination operand is always an FPU data register; the source operand can be an FPU data register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.",
            "The no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0) register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0) register by the contents of a memory location (either a floating point or an integer value) and stores the product in the ST(0) register. The two-operand version, multiplies the contents of the ST(0) register by the contents of the ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the destination operand).",
            "The FMULP instructions perform the additional operation of popping the FPU register stack after storing the product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FMUL rather than FMULP.",
            "The FIMUL instructions convert an integer source operand to double extended-precision floating-point format before performing the multiplication.",
            "The sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multiplied is 0 or ∞. When the source operand is an integer 0, it is treated as a +0.",
            "The following table shows the results obtained when multiplying various classes of numbers, assuming that neither overflow nor underflow occurs."
        ],
        "operands": [
            "reg.wq, mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FMUL:FMULP:FIMUL.html"
        ]
    },
    "vhaddpd": {
        "detail": [
            "Packed Double-FP Horizontal Add"
        ],
        "documentation": [
            "Adds the double-precision floating-point values in the high and low quadwords of the destination operand and stores the result in the low quadword of the destination operand.",
            "Adds the double-precision floating-point values in the high and low quadwords of the source operand and stores the result in the high quadword of the destination operand.",
            "In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
            "See Figure 3-16 for HADDPD; see Figure 3-17 for VHADDPD."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/HADDPD.html"
        ]
    },
    "vmovddup": {
        "detail": [
            "Replicate Double FP Values"
        ],
        "documentation": [
            "For 256-bit or higher versions: Duplicates even-indexed double-precision floating-point values from the source operand (the second operand) and into adjacent pair and store to the destination operand (the first operand).",
            "For 128-bit versions: Duplicates the low double-precision floating-point value from the source operand (the second operand) and store to the destination operand (the first operand).",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register are unchanged. The source operand is XMM register or a 64-bit memory location.",
            "VEX.128 and EVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. The source operand is XMM register or a 64-bit memory location. The destination is updated conditionally under the writemask for EVEX version.",
            "VEX.256 and EVEX.256 encoded version: Bits (MAXVL-1:256) of the destination register are zeroed. The source operand is YMM register or a 256-bit memory location. The destination is updated conditionally under the writemask for EVEX version.",
            "EVEX.512 encoded version: The destination is updated according to the writemask. The source operand is ZMM register or a 512-bit memory location.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVDDUP.html"
        ]
    },
    "vmovss": {
        "detail": [
            "Move or Merge Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Moves a scalar single-precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be XMM registers or 32-bit memory locations. This instruction can be used to move a single-precision floating-point value to and from the low doubleword of an XMM register and a 32-bit memory location, or to move a single-precision floating-point value between the low doublewords of two XMM registers. The instruction cannot be used to transfer data between memory locations.",
            "Legacy version: When the source and destination operands are XMM registers, bits (MAXVL-1:32) of the corresponding destination register are unmodified. When the source operand is a memory location and destination operand is an XMM registers, Bits (127:32) of the destination operand is cleared to all 0s, bits MAXVL:128 of the destination operand remains unchanged.",
            "VEX and EVEX encoded register-register syntax: Moves a scalar single-precision floating-point value from the second source operand (the third operand) to the low doubleword element of the destination operand (the first operand). Bits 127:32 of the destination operand are copied from the first source operand (the second operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX and EVEX encoded memory load syntax: When the source operand is a memory location and destination operand is an XMM registers, bits MAXVL:32 of the destination operand is cleared to all 0s.",
            "EVEX encoded versions: The low doubleword of the destination is updated according to the writemask.",
            "Note: For memory store form instruction “VMOVSS m32, xmm1”, VEX.vvvv is reserved and must be 1111b otherwise instruction will #UD. For memory store form instruction “VMOVSS mv {k1}, xmm1”, EVEX.vvvv is reserved and must be 1111b otherwise instruction will #UD.",
            "Software should ensure VMOVSS is encoded with VEX.L=0. Encoding VMOVSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.q, mem.d",
            "mem.d, reg.q, reg.x",
            "mem.d, reg.d",
            "reg.x, reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVSS.html"
        ]
    },
    "vpsrlvq": {
        "detail": [
            "Variable Bit Shift Right Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords or quadword) in the first source operand to the right by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0).",
            "The count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for word), 31 (for doublewords), or 63 (for a quadword), then the destination data element are written with 0.",
            "VEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded VPSRLVD/Q: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.",
            "EVEX encoded VPSRLVW: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is conditionally updated with writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPSRLVW:VPSRLVD:VPSRLVQ.html"
        ]
    },
    "vcvtss2usi": {
        "detail": [
            "Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer"
        ],
        "documentation": [
            "Converts a single-precision floating-point value in the source operand (the second operand) to an unsigned double-word integer (or unsigned quadword integer if operand size is 64 bits) in the destination operand (the first operand). The source operand can be an XMM register or a memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w – 1 is returned, where w represents the number of bits in the destination format.",
            "VEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.",
            "Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTSS2USI.html"
        ]
    },
    "jnbe": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "vhaddps": {
        "detail": [
            "Packed Single-FP Horizontal Add"
        ],
        "documentation": [
            "Adds the single-precision floating-point values in the first and second dwords of the destination operand and stores the result in the first dword of the destination operand.",
            "Adds single-precision floating-point values in the third and fourth dword of the destination operand and stores the result in the second dword of the destination operand.",
            "Adds single-precision floating-point values in the first and second dword of the source operand and stores the result in the third dword of the destination operand.",
            "Adds single-precision floating-point values in the third and fourth dword of the source operand and stores the result in the fourth dword of the destination operand.",
            "In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
            "See Figure 3-18 for HADDPS; see Figure 3-19 for VHADDPS."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/HADDPS.html"
        ]
    },
    "vpsrlvw": {
        "detail": [
            "Variable Bit Shift Right Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords or quadword) in the first source operand to the right by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0).",
            "The count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for word), 31 (for doublewords), or 63 (for a quadword), then the destination data element are written with 0.",
            "VEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded VPSRLVD/Q: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.",
            "EVEX encoded VPSRLVW: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is conditionally updated with writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPSRLVW:VPSRLVD:VPSRLVQ.html"
        ]
    },
    "vcvttsd2si": {
        "detail": [
            "Convert with Truncation Scalar Double-Precision Floating-Point Value to Signed Integer"
        ],
        "documentation": [
            "Converts a double-precision floating-point value in the source operand (the second operand) to a signed double-word integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.",
            "If a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode with REX.W/VEX.W/EVEX.W=0), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.",
            "If a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and REX.W/VEX.W/EVEX.W = 1), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000_00000000H) is returned.",
            "Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation. See the summary chart at the beginning of this section for encoding data and limits.",
            "VEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCVTTSD2SI is encoded with VEX.L=0. Encoding VCVTTSD2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.q",
            "reg.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTTSD2SI.html"
        ]
    },
    "vpshufb": {
        "detail": [
            "Packed Shuffle Bytes"
        ],
        "documentation": [
            "PSHUFB performs in-place shuffles of bytes in the destination operand (the first operand) according to the shuffle control mask in the source operand (the second operand). The instruction permutes the data in the destination operand, leaving the shuffle mask unaffected. If the most significant bit (bit[7]) of each byte of the shuffle control mask is set, then constant zero is written in the result byte. Each byte in the shuffle control mask forms an index to permute the corresponding byte in the destination operand. The value of each index is the least significant 4 bits (128-bit operation) or 3 bits (64-bit operation) of the shuffle control byte. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "In 64-bit mode and not encoded with VEX/EVEX, use the REX prefix to access XMM8-XMM15 registers.",
            "Legacy SSE version 64-bit operand: Both operands can be MMX registers.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The destination operand is the first operand, the first source operand is the second operand, the second source operand is the third operand. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: Bits (255:128) of the destination YMM register stores the 16-byte shuffle result of the upper 16 bytes of the first source operand, using the upper 16-bytes of the second source operand as control mask.",
            "The value of each index is for the high 128-bit lane is the least significant 4 bits of the respective shuffle control byte. The index value selects a source data element within each 128-bit lane.",
            "EVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "EVEX and VEX encoded version: Four/two in-lane 128-bit shuffles."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSHUFB.html"
        ]
    },
    "vpshufd": {
        "detail": [
            "Shuffle Packed Doublewords"
        ],
        "documentation": [
            "Copies doublewords from source operand (second operand) and inserts them in the destination operand (first operand) at the locations selected with the order operand (third operand). Figure 4-16 shows the operation of the 256-bit VPSHUFD instruction and the encoding of the order operand. Each 2-bit field in the order operand selects the contents of one doubleword location within a 128-bit lane and copy to the target element in the destination operand. For example, bits 0 and 1 of the order operand targets the first doubleword element in the low and high 128-bit lane of the destination operand for 256-bit VPSHUFD. The encoded value of bits 1:0 of the order operand (see the field encoding in Figure 4-16) determines which doubleword element (from the respective 128-bit lane) of the source operand will be copied to doubleword 0 of the destination operand.",
            "For 128-bit operation, only the low 128-bit lane are operative. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The order operand is an 8-bit immediate. Note that this instruction permits a doubleword in the source operand to be copied to more than one doubleword location in the destination operand.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSHUFD.html"
        ]
    },
    "punpckhwd": {
        "detail": [
            "Unpack High Data"
        ],
        "documentation": [
            "Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. Figure 4-20 shows the unpack operation for bytes in 64-bit operands. The low-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html"
        ]
    },
    "vgetexppd": {
        "detail": [
            "Convert Exponents of Packed DP FP Values to DP FP Values"
        ],
        "documentation": [
            "Extracts the biased exponents from the normalized DP FP representation of each qword data element of the source operand (the second operand) as unbiased signed integer value, or convert the denormal representation of input data to unbiased negative integer values. Each integer value of the unbiased exponent is converted to double-precision FP value and written to the corresponding qword elements of the destination operand (the first operand) as DP FP numbers.",
            "The destination operand is a ZMM/YMM/XMM register and updated under the writemask. The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location.",
            "EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
            "Each GETEXP operation converts the exponent value into a FP number (permitting input value in denormal representation). Special cases of input values are listed in Table 5-14.",
            "The formula is:",
            "GETEXP(x) = floor(log2(|x|))",
            "Notation floor(x) stands for the greatest integer not exceeding real number x."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGETEXPPD.html"
        ]
    },
    "vpternlogd": {
        "detail": [
            "Bitwise Ternary Logic"
        ],
        "documentation": [
            "VPTERNLOGD/Q takes three bit vectors of 512-bit length (in the first, second and third operand) as input data to form a set of 512 indices, each index is comprised of one bit from each input vector. The imm8 byte specifies a boolean logic table producing a binary value for each 3-bit index value. The final 512-bit boolean result is written to the destination operand (the first operand) using the writemask k1 with the granularity of doubleword element or quadword element into the destination.",
            "The destination operand is a ZMM (EVEX.512)/YMM (EVEX.256)/XMM (EVEX.128) register. The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location The destination operand is a ZMM register conditionally updated with writemask k1.",
            "Table 5-18 shows two examples of Boolean functions specified by immediate values 0xE2 and 0xE4, with the look up result listed in the fourth column following the three columns containing all possible values of the 3-bit index."
        ],
        "operands": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPTERNLOGD:VPTERNLOGQ.html"
        ]
    },
    "hreset": {
        "detail": [
            ""
        ],
        "operands": [
            "imm.b, reg.d"
        ],
        "url": [
            "https://"
        ]
    },
    "subpd": {
        "detail": [
            "Subtract Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD subtract of the two, four or eight packed double-precision floating-point values of the second Source operand from the first Source operand, and stores the packed double-precision floating-point results in the destination operand.",
            "VEX.128 and EVEX.128 encoded versions: The second source operand is an XMM register or an 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX.512 encoded version: The second source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The first source operand and destination operands are ZMM registers. The destination operand is conditionally updated according to the writemask.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/SUBPD.html"
        ]
    },
    "pmulld": {
        "detail": [
            "Multiply Packed Integers and Store Low Result"
        ],
        "documentation": [
            "Performs a SIMD signed multiply of the packed signed dword/qword integers from each element of the first source operand with the corresponding element in the second source operand. The low 32/64 bits of each 64/128-bit intermediate results are stored to the destination operand.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMULLD:PMULLQ.html"
        ]
    },
    "vpsrld": {
        "detail": [
            "Shift Packed Data Right Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-19 gives an example of shifting words in a 64-bit operand.",
            "Note that only the low 64-bits of a 128-bit count operand are checked to compute the count.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.z, reg.q, reg.z, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html"
        ]
    },
    "test": {
        "detail": [
            "Logical Compare"
        ],
        "documentation": [
            "Computes the bit-wise logical AND of first operand (source 1 operand) and the second operand (source 2 operand) and sets the SF, ZF, and PF status flags according to the result. The result is then discarded.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF and CF flags are set to 0. The SF, ZF, and PF flags are set according to the result (see the “Operation” section above). The state of the AF flag is undefined."
        ],
        "operands": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/TEST.html"
        ]
    },
    "vinserti128": {
        "detail": [
            "Insert Packed Integer Values"
        ],
        "documentation": [
            "VINSERTI32x4 and VINSERTI64x2 inserts 128-bits of packed integer values from the second source operand (the third operand) into the destination operand (the first operand) at an 128-bit granular offset multiplied by imm8[0] (256-bit) or imm8[1:0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit memory location. The high 6/7bits of the immediate are ignored. The destination operand is a ZMM/YMM register and updated at 32 and 64-bit granularity according to the writemask.",
            "VINSERTI32x8 and VINSERTI64x4 inserts 256-bits of packed integer values from the second source operand (the third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an YMM register or a 256-bit memory location. The upper bits of the immediate are ignored. The destination operand is a ZMM register and updated at 32 and 64-bit granularity according to the writemask.",
            "VINSERTI128 inserts 128-bits of packed integer data from the second source operand (the third operand) into the destination operand (the first operand) at a 128-bit granular offset multiplied by imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit memory location. The high 7 bits of the immediate are ignored. VEX.L must be 1, otherwise attempt to execute this instruction with VEX.L=0 will cause #UD."
        ],
        "operands": [
            "reg.y, reg.y, mem.x, imm.b",
            "reg.y, reg.y, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VINSERTI128:VINSERTI32x4:VINSERTI64x2:VINSERTI32x8:VINSERTI64x4.html"
        ]
    },
    "vpternlogq": {
        "detail": [
            "Bitwise Ternary Logic"
        ],
        "documentation": [
            "VPTERNLOGD/Q takes three bit vectors of 512-bit length (in the first, second and third operand) as input data to form a set of 512 indices, each index is comprised of one bit from each input vector. The imm8 byte specifies a boolean logic table producing a binary value for each 3-bit index value. The final 512-bit boolean result is written to the destination operand (the first operand) using the writemask k1 with the granularity of doubleword element or quadword element into the destination.",
            "The destination operand is a ZMM (EVEX.512)/YMM (EVEX.256)/XMM (EVEX.128) register. The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location The destination operand is a ZMM register conditionally updated with writemask k1.",
            "Table 5-18 shows two examples of Boolean functions specified by immediate values 0xE2 and 0xE4, with the look up result listed in the fourth column following the three columns containing all possible values of the 3-bit index."
        ],
        "operands": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPTERNLOGD:VPTERNLOGQ.html"
        ]
    },
    "vcvttpd2uqq": {
        "detail": [
            "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers"
        ],
        "documentation": [
            "Converts with truncation packed double-precision floating-point values in the source operand (second operand) to packed unsigned quadword integers in the destination operand (first operand).",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w – 1 is returned, where w represents the number of bits in the destination format.",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTTPD2UQQ.html"
        ]
    },
    "vgetexpps": {
        "detail": [
            "Convert Exponents of Packed SP FP Values to SP FP Values"
        ],
        "documentation": [
            "Extracts the biased exponents from the normalized SP FP representation of each dword element of the source operand (the second operand) as unbiased signed integer value, or convert the denormal representation of input data to unbiased negative integer values. Each integer value of the unbiased exponent is converted to single-precision FP value and written to the corresponding dword elements of the destination operand (the first operand) as SP FP numbers.",
            "The destination operand is a ZMM/YMM/XMM register and updated under the writemask. The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location.",
            "EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
            "Each GETEXP operation converts the exponent value into a FP number (permitting input value in denormal representation). Special cases of input values are listed in Table 5-15.",
            "The formula is:",
            "GETEXP(x) = floor(log2(|x|))",
            "Notation floor(x) stands for maximal integer not exceeding real number x.",
            "Software usage of VGETEXPxx and VGETMANTxx instructions generally involve a combination of GETEXP operation and GETMANT operation (see VGETMANTPD). Thus VGETEXPxx instruction do not require software to handle SIMD FP exceptions."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGETEXPPS.html"
        ]
    },
    "vrangesd": {
        "detail": [
            "Range Restriction Calculation From a pair of Scalar Float64 Values"
        ],
        "documentation": [
            "This instruction calculates a range operation output from two input double-precision FP values in the low qword element of the first source operand (the second operand) and second source operand (the third operand). The range output is written to the low qword element of the destination operand (the first operand) under the writemask k1.",
            "Bits7:4 of imm8 byte must be zero. The range operation output is performed in two parts, each configured by a two-bit control field within imm8[3:0]:"
        ],
        "operands": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRANGESD.html"
        ]
    },
    "subps": {
        "detail": [
            "Subtract Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed single-precision floating-point values in the second Source operand from the First Source operand, and stores the packed single-precision floating-point results in the destination operand.",
            "VEX.128 and EVEX.128 encoded versions: The second source operand is an XMM register or an 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX.512 encoded version: The second source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The first source operand and destination operands are ZMM registers. The destination operand is conditionally updated according to the writemask.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/SUBPS.html"
        ]
    },
    "vcvtps2qq": {
        "detail": [
            "Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values"
        ],
        "documentation": [
            "Converts eight packed single-precision floating-point values in the source operand to eight signed quadword integers in the destination operand.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.",
            "The source operand is a YMM/XMM/XMM (low 64- bits) register or a 256/128/64-bit memory location. The destination operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.q",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTPS2QQ.html"
        ]
    },
    "vscalefpd": {
        "detail": [
            "Scale Packed Float64 Values With Float64 Values"
        ],
        "documentation": [
            "Performs a floating-point scale of the packed double-precision floating-point values in the first source operand by multiplying it by 2 power of the double-precision floating-point values in second source operand.",
            "The equation of this operation is given by:",
            "zmm1 := zmm2*2floor(zmm3).",
            "Floor(zmm3) means maximum integer value ≤ zmm3.",
            "If the result cannot be represented in double precision, then the proper overflow response (for positive scaling operand), or the proper underflow response (for negative scaling operand) is issued. The overflow and underflow responses are dependent on the rounding mode (for IEEE-compliant rounding), as well as on other settings in MXCSR (exception mask bits, FTZ bit), and on the SAE bit.",
            "The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Handling of special-case input values are listed in Table 5-30 and Table 5-31."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCALEFPD.html"
        ]
    },
    "vpsrlq": {
        "detail": [
            "Shift Packed Data Right Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-19 gives an example of shifting words in a 64-bit operand.",
            "Note that only the low 64-bits of a 128-bit count operand are checked to compute the count.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.z, reg.q, reg.z, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html"
        ]
    },
    "vmovdqu32": {
        "detail": [
            "Move Unaligned Packed Integer Values"
        ],
        "documentation": [
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX encoded versions:",
            "Moves 128, 256 or 512 bits of packed byte/word/doubleword/quadword integer values from the source operand (the second operand) to the destination operand (first operand). This instruction can be used to load a vector register from a memory location, to store the contents of a vector register into a memory location, or to move data between two vector registers.",
            "The destination operand is updated at 8-bit (VMOVDQU8), 16-bit (VMOVDQU16), 32-bit (VMOVDQU32), or 64-bit (VMOVDQU64) granularity according to the writemask.",
            "VEX.256 encoded version:",
            "Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.",
            "Bits (MAXVL-1:256) of the destination register are zeroed."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html"
        ]
    },
    "vsqrtpd": {
        "detail": [
            "Square Root of Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD computation of the square roots of the two, four or eight packed double-precision floating-point values in the source operand (the second operand) stores the packed double-precision floating-point results in the destination operand (the first operand).",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/SQRTPD.html"
        ]
    },
    "gf2p8affineqb": {
        "detail": [
            "Galois Field Affine Transformation"
        ],
        "documentation": [
            "The AFFINEB instruction computes an affine transformation in the Galois Field 28. For this instruction, an affine transformation is defined by A * x + b where “A” is an 8 by 8 bit matrix, and “x” and “b” are 8-bit vectors. One SIMD register (operand 1) holds “x” as either 16, 32 or 64 8-bit vectors. A second SIMD (operand 2) register or memory operand contains 2, 4, or 8 “A” values, which are operated upon by the correspondingly aligned 8 “x” values in the first register. The “b” vector is constant for all calculations and contained in the immediate byte.",
            "The SSE encoded forms of the instruction require16B alignment on their memory operations."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/GF2P8AFFINEQB.html"
        ]
    },
    "movdir64b": {
        "detail": [
            "Move 64 Bytes as Direct Store"
        ],
        "documentation": [
            "Moves 64-bytes as direct-store with 64-byte write atomicity from source memory address to destination memory address. The source operand is a normal memory operand. The destination operand is a memory location specified in a general-purpose register. The register content is interpreted as an offset into ES segment without any segment override. In 64-bit mode, the register operand width is 64-bits (32-bits with 67H prefix). Outside of 64-bit mode, the register width is 32-bits when CS.D=1 (16-bits with 67H prefix), and 16-bits when CS.D=0 (32-bits with 67H prefix). MOVDIR64B requires the destination address to be 64-byte aligned. No alignment restriction is enforced for source operand.",
            "MOVDIR64B reads 64-bytes from the source memory address and performs a 64-byte direct-store operation to the destination address. The load operation follows normal read ordering based on source address memory-type. The direct-store is implemented by using the write combining (WC) memory type protocol for writing data. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. If the destination address is cached, the line is written-back (if modified) and invalidated from the cache, before the direct-store.",
            "Unlike stores with non-temporal hint which allow UC/WP memory-type for destination to override the non-temporal hint, direct-stores always follow WC memory type protocol irrespective of destination address memory type (including UC/WP types). Unlike WC stores and stores with non-temporal hint, direct-stores are eligible for immediate eviction from the write-combining buffer, and thus not combined with younger stores (including direct-stores) to the same address. Older WC and non-temporal stores held in the write-combing buffer may be combined with younger direct stores to the same address. Because WC protocol used by direct-stores follow weakly-ordered memory consistency model, fencing operation using SFENCE or MFENCE should follow the MOVDIR64B instruction to enforce ordering when needed.",
            "There is no atomicity guarantee provided for the 64-byte load operation from source address, and processor implementations may use multiple load operations to read the 64-bytes. The 64-byte direct-store issued by MOVDIR64B guarantees 64-byte write-completion atomicity. This means that the data arrives at the destination in a single undivided 64-byte write transaction.",
            "Availability of the MOVDIR64B instruction is indicated by the presence of the CPUID feature flag MOVDIR64B (bit 28 of the ECX register in leaf 07H, see “CPUID—CPU Identification” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A)."
        ],
        "operands": [
            "reg, mem.z, mem.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVDIR64B.html"
        ]
    },
    "vpmovm2b": {
        "detail": [
            "Convert a Mask Register to a Vector Register"
        ],
        "documentation": [
            "Converts a mask register to a vector register. Each element in the destination register is set to all 1’s or all 0’s depending on the value of the corresponding bit in the source mask register.",
            "The source operand is a mask register. The destination operand is a ZMM/YMM/XMM register.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVM2B:VPMOVM2W:VPMOVM2D:VPMOVM2Q.html"
        ]
    },
    "vpsrlw": {
        "detail": [
            "Shift Packed Data Right Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-19 gives an example of shifting words in a 64-bit operand.",
            "Note that only the low 64-bits of a 128-bit count operand are checked to compute the count.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, mem.x, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.x, reg.q, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html"
        ]
    },
    "vpmovm2d": {
        "detail": [
            "Convert a Mask Register to a Vector Register"
        ],
        "documentation": [
            "Converts a mask register to a vector register. Each element in the destination register is set to all 1’s or all 0’s depending on the value of the corresponding bit in the source mask register.",
            "The source operand is a mask register. The destination operand is a ZMM/YMM/XMM register.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVM2B:VPMOVM2W:VPMOVM2D:VPMOVM2Q.html"
        ]
    },
    "vrangess": {
        "detail": [
            "Range Restriction Calculation From a Pair of Scalar Float32 Values"
        ],
        "documentation": [
            "This instruction calculates a range operation output from two input single-precision FP values in the low dword element of the first source operand (the second operand) and second source operand (the third operand). The range output is written to the low dword element of the destination operand (the first operand) under the writemask k1.",
            "Bits7:4 of imm8 byte must be zero. The range operation output is performed in two parts, each configured by a two-bit control field within imm8[3:0]:"
        ],
        "operands": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRANGESS.html"
        ]
    },
    "clts": {
        "detail": [
            "Clear Task-Switched Flag in CR0"
        ],
        "documentation": [
            "Clears the task-switched (TS) flag in the CR0 register. This instruction is intended for use in operating-system procedures. It is a privileged instruction that can only be executed at a CPL of 0. It is allowed to be executed in real-address mode to allow initialization for protected mode.",
            "The processor sets the TS flag every time a task switch occurs. The flag is used to synchronize the saving of FPU context in multitasking applications. See the description of the TS flag in the section titled “Control Registers” in Chapter 2 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for more information about this flag.",
            "CLTS operation is the same in non-64-bit modes and 64-bit mode.",
            "See Chapter 25, “VMX Non-Root Operation,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation.",
            "Flags Affected:",
            "The TS flag in CR0 register is cleared."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/CLTS.html"
        ]
    },
    "paddd": {
        "detail": [
            "Add Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.",
            "The PADDB and VPADDB instructions add packed byte integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 8 bits (overflow), the result is wrapped around and the low 8 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDW and VPADDW instructions add packed word integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 16 bits (overflow), the result is wrapped around and the low 16 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDD and VPADDD instructions add packed doubleword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 32 bits (overflow), the result is wrapped around and the low 32 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDQ and VPADDQ instructions add packed quadword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When a quadword result is too",
            "large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination operand (that is, the carry is ignored).",
            "Note that the (V)PADDB, (V)PADDW, (V)PADDD and (V)PADDQ instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values operated on.",
            "EVEX encoded VPADDD/Q: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "EVEX encoded VPADDB/W: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. the upper bits (MAXVL-1:256) of the destination are cleared.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html"
        ]
    },
    "paddb": {
        "detail": [
            "Add Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.",
            "The PADDB and VPADDB instructions add packed byte integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 8 bits (overflow), the result is wrapped around and the low 8 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDW and VPADDW instructions add packed word integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 16 bits (overflow), the result is wrapped around and the low 16 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDD and VPADDD instructions add packed doubleword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 32 bits (overflow), the result is wrapped around and the low 32 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDQ and VPADDQ instructions add packed quadword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When a quadword result is too",
            "large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination operand (that is, the carry is ignored).",
            "Note that the (V)PADDB, (V)PADDW, (V)PADDD and (V)PADDQ instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values operated on.",
            "EVEX encoded VPADDD/Q: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "EVEX encoded VPADDB/W: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. the upper bits (MAXVL-1:256) of the destination are cleared.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html"
        ]
    },
    "vscalefps": {
        "detail": [
            "Scale Packed Float32 Values With Float32 Values"
        ],
        "documentation": [
            "Performs a floating-point scale of the packed single-precision floating-point values in the first source operand by multiplying it by 2 power of the float32 values in second source operand.",
            "The equation of this operation is given by:",
            "zmm1 := zmm2*2floor(zmm3).",
            "Floor(zmm3) means maximum integer value ≤ zmm3.",
            "If the result cannot be represented in single precision, then the proper overflow response (for positive scaling operand), or the proper underflow response (for negative scaling operand) is issued. The overflow and underflow responses are dependent on the rounding mode (for IEEE-compliant rounding), as well as on other settings in MXCSR (exception mask bits, FTZ bit), and on the SAE bit.",
            "EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register conditionally updated with writemask k1.",
            "EVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.",
            "EVEX.128 encoded version: The first source operand is an XMM register. The second source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.",
            "Handling of special-case input values are listed in Table 5-30 and Table 5-32."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCALEFPS.html"
        ]
    },
    "kandb": {
        "detail": [
            "Bitwise Logical AND Masks"
        ],
        "documentation": [
            "Performs a bitwise AND between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KANDW:KANDB:KANDQ:KANDD.html"
        ]
    },
    "kandd": {
        "detail": [
            "Bitwise Logical AND Masks"
        ],
        "documentation": [
            "Performs a bitwise AND between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KANDW:KANDB:KANDQ:KANDD.html"
        ]
    },
    "vsqrtps": {
        "detail": [
            "Square Root of Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD computation of the square roots of the four, eight or sixteen packed single-precision floating-point values in the source operand (second operand) stores the packed single-precision floating-point results in the destination operand.",
            "EVEX.512 encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/SQRTPS.html"
        ]
    },
    "movhlps": {
        "detail": [
            "Move Packed Single-Precision Floating-Point Values High to Low"
        ],
        "documentation": [
            "This instruction cannot be used for memory to register moves.",
            "128-bit two-argument form:",
            "Moves two packed single-precision floating-point values from the high quadword of the second XMM argument (second operand) to the low quadword of the first XMM register (first argument). The quadword at bits 127:64 of the destination operand is left unchanged. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "128-bit and EVEX three-argument form",
            "Moves two packed single-precision floating-point values from the high quadword of the third XMM argument (third operand) to the low quadword of the destination (first operand). Copies the high quadword from the second XMM argument (second operand) to the high quadword of the destination (first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "If VMOVHLPS is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVHLPS.html"
        ]
    },
    "vpmovm2q": {
        "detail": [
            "Convert a Mask Register to a Vector Register"
        ],
        "documentation": [
            "Converts a mask register to a vector register. Each element in the destination register is set to all 1’s or all 0’s depending on the value of the corresponding bit in the source mask register.",
            "The source operand is a mask register. The destination operand is a ZMM/YMM/XMM register.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVM2B:VPMOVM2W:VPMOVM2D:VPMOVM2Q.html"
        ]
    },
    "fdivrp": {
        "detail": [
            "Reverse Divide"
        ],
        "documentation": [
            "Divides the source operand by the destination operand and stores the result in the destination location. The destination operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format.",
            "These instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions. They are provided to support more efficient coding.",
            "The no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1) register. The one-operand version divides the contents of a memory location (either a floating-point or an integer value) by the contents of the ST(0) register. The two-operand version, divides the contents of the ST(i) register by the contents of the ST(0) register or vice versa.",
            "The FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIVR rather than FDIVRP.",
            "The FIDIVR instructions convert an integer source operand to double extended-precision floating-point format before performing the division.",
            "If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.",
            "The following table shows the results obtained when dividing various classes of numbers, assuming that neither overflow nor underflow occurs."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FDIVR:FDIVRP:FIDIVR.html"
        ]
    },
    "pmullw": {
        "detail": [
            "Multiply Packed Signed Integers and Store Low Result"
        ],
        "documentation": [
            "Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the low 16 bits of each intermediate 32-bit result in the destination operand. (Figure 4-12 shows this operation when using 64-bit operands.)",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMULLW.html"
        ]
    },
    "senduipi": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d"
        ],
        "url": [
            "https://"
        ]
    },
    "paddq": {
        "detail": [
            "Add Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.",
            "The PADDB and VPADDB instructions add packed byte integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 8 bits (overflow), the result is wrapped around and the low 8 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDW and VPADDW instructions add packed word integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 16 bits (overflow), the result is wrapped around and the low 16 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDD and VPADDD instructions add packed doubleword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 32 bits (overflow), the result is wrapped around and the low 32 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDQ and VPADDQ instructions add packed quadword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When a quadword result is too",
            "large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination operand (that is, the carry is ignored).",
            "Note that the (V)PADDB, (V)PADDW, (V)PADDD and (V)PADDQ instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values operated on.",
            "EVEX encoded VPADDD/Q: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "EVEX encoded VPADDB/W: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. the upper bits (MAXVL-1:256) of the destination are cleared.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html"
        ]
    },
    "vpmovm2w": {
        "detail": [
            "Convert a Mask Register to a Vector Register"
        ],
        "documentation": [
            "Converts a mask register to a vector register. Each element in the destination register is set to all 1’s or all 0’s depending on the value of the corresponding bit in the source mask register.",
            "The source operand is a mask register. The destination operand is a ZMM/YMM/XMM register.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVM2B:VPMOVM2W:VPMOVM2D:VPMOVM2Q.html"
        ]
    },
    "kandq": {
        "detail": [
            "Bitwise Logical AND Masks"
        ],
        "documentation": [
            "Performs a bitwise AND between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KANDW:KANDB:KANDQ:KANDD.html"
        ]
    },
    "paddw": {
        "detail": [
            "Add Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.",
            "The PADDB and VPADDB instructions add packed byte integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 8 bits (overflow), the result is wrapped around and the low 8 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDW and VPADDW instructions add packed word integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 16 bits (overflow), the result is wrapped around and the low 16 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDD and VPADDD instructions add packed doubleword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 32 bits (overflow), the result is wrapped around and the low 32 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDQ and VPADDQ instructions add packed quadword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When a quadword result is too",
            "large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination operand (that is, the carry is ignored).",
            "Note that the (V)PADDB, (V)PADDW, (V)PADDD and (V)PADDQ instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values operated on.",
            "EVEX encoded VPADDD/Q: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "EVEX encoded VPADDB/W: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. the upper bits (MAXVL-1:256) of the destination are cleared.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html"
        ]
    },
    "blsic": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://"
        ]
    },
    "fnop": {
        "detail": [
            "No Operation"
        ],
        "documentation": [
            "Performs no FPU operation. This instruction takes up space in the instruction stream but does not affect the FPU or machine context, except the EIP register and the FPU Instruction Pointer.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/FNOP.html"
        ]
    },
    "movdqa": {
        "detail": [
            "Move Aligned Packed Integer Values"
        ],
        "documentation": [
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX encoded versions:",
            "Moves 128, 256 or 512 bits of packed doubleword/quadword integer values from the source operand (the second operand) to the destination operand (the first operand). This instruction can be used to load a vector register from an int32/int64 memory location, to store the contents of a vector register into an int32/int64 memory location, or to move data between two ZMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16 (EVEX.128)/32(EVEX.256)/64(EVEX.512)-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction.",
            "The destination operand is updated at 32-bit (VMOVDQA32) or 64-bit (VMOVDQA64) granularity according to the writemask.",
            "VEX.256 encoded version:",
            "Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.",
            "When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "128-bit versions:",
            "Moves 128 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.",
            "When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVDQA:VMOVDQA32:VMOVDQA64.html"
        ]
    },
    "kandw": {
        "detail": [
            "Bitwise Logical AND Masks"
        ],
        "documentation": [
            "Performs a bitwise AND between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KANDW:KANDB:KANDQ:KANDD.html"
        ]
    },
    "cvtps2pd": {
        "detail": [
            "Convert Packed Single-Precision Floating-Point Values to Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Converts two, four or eight packed single-precision floating-point values in the source operand (second operand) to two, four or eight packed double-precision floating-point values in the destination operand (first operand).",
            "EVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64-bits) register, a 256/128/64-bit memory location or a 256/128/64-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.",
            "VEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination operand is a XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination operand is an XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTPS2PD.html"
        ]
    },
    "vphaddudq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "cvtps2pi": {
        "detail": [
            "Convert Packed Single-Precision FP Values to Packed Dword Integers"
        ],
        "documentation": [
            "Converts two packed single-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand).",
            "The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register. When the source operand is an XMM register, the two single-precision floating-point values are contained in the low quadword of the register. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.",
            "CVTPS2PI causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPS2PI instruction is executed.",
            "In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15)."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTPS2PI.html"
        ]
    },
    "vroundsd": {
        "detail": [
            "Round Scalar Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Round the DP FP value in the lower qword of the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the result in the destination operand (first operand). The rounding process rounds a double-precision floating-point input to an integer value and returns the integer result as a double precision floating-point value in the lowest position. The upper double precision floating-point value in the destination is retained.",
            "The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-17 lists the encoded values for rounding-mode field).",
            "The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:64) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/ROUNDSD.html"
        ]
    },
    "vunpcklpd": {
        "detail": [
            "Unpack and Interleave Low Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs an interleaved unpack of the low double-precision floating-point values from the first source operand and the second source operand.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.",
            "EVEX.128 encoded version: The first source operand is an XMM register. The second source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/UNPCKLPD.html"
        ]
    },
    "movdqu": {
        "detail": [
            "Move Unaligned Packed Integer Values"
        ],
        "documentation": [
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX encoded versions:",
            "Moves 128, 256 or 512 bits of packed byte/word/doubleword/quadword integer values from the source operand (the second operand) to the destination operand (first operand). This instruction can be used to load a vector register from a memory location, to store the contents of a vector register into a memory location, or to move data between two vector registers.",
            "The destination operand is updated at 8-bit (VMOVDQU8), 16-bit (VMOVDQU16), 32-bit (VMOVDQU32), or 64-bit (VMOVDQU64) granularity according to the writemask.",
            "VEX.256 encoded version:",
            "Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.",
            "Bits (MAXVL-1:256) of the destination register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html"
        ]
    },
    "vpgatherdd": {
        "detail": [
            "Gather Packed Dword, Packed Qword with Signed Dword Indices"
        ],
        "documentation": [
            "A set of 16 or 8 doubleword/quadword memory locations pointed to by base address BASE_ADDR and index vector VINDEX with scale SCALE are gathered. The result is written into vector zmm1. The elements are specified via the VSIB (i.e., the index register is a zmm, holding packed indices). Elements will only be loaded if their corresponding mask bit is one. If an element’s mask bit is not set, the corresponding element of the destination register (zmm1) is left unchanged. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register (k1) are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "If the data element size is less than the index element size, the higher part of the destination register and the mask register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may update these unused elements to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.",
            "Note that:"
        ],
        "operands": [
            "reg.z, reg.q, mem.d",
            "reg.y, mem.d, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPGATHERDD:VPGATHERDQ.html"
        ]
    },
    "vroundss": {
        "detail": [
            "Round Scalar Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Round the single-precision floating-point value in the lowest dword of the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the result in the destination operand (first operand). The rounding process rounds a single-precision floating-point input to an integer value and returns the result as a single-precision floating-point value in the lowest position. The upper three single-precision floating-point values in the destination are retained.",
            "The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-17 lists the encoded values for rounding-mode field).",
            "The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.d, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/ROUNDSS.html"
        ]
    },
    "vunpcklps": {
        "detail": [
            "Unpack and Interleave Low Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs an interleaved unpack of the low single-precision floating-point values from the first source operand and the second source operand.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/UNPCKLPS.html"
        ]
    },
    "clui": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.1"
        ],
        "url": [
            "https://"
        ]
    },
    "lock sbb": {
        "detail": [
            "Integer Subtraction with Borrow"
        ],
        "documentation": [
            "Adds the source operand (second operand) and the carry (CF) flag, and subtracts the result from the destination operand (first operand). The result of the subtraction is stored in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a borrow from a previous subtraction.",
            "When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.",
            "The SBB instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a borrow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.",
            "The SBB instruction is usually executed as part of a multibyte or multiword subtraction in which a SUB instruction is followed by a SBB instruction.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF, SF, ZF, AF, PF, and CF flags are set according to the result."
        ],
        "operands": [
            "mem.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SBB.html"
        ]
    },
    "xrstor": {
        "detail": [
            "Restore Processor Extended States"
        ],
        "documentation": [
            "Performs a full or partial restore of processor state components from the XSAVE area located at the memory address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.",
            "The format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Section 13.8, “Operation of XRSTOR,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XRSTOR instruction. The following items provide a highlevel outline:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.z[4096], reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XRSTOR.html"
        ]
    },
    "vpgatherdq": {
        "detail": [
            "Gather Packed Dword, Packed Qword with Signed Dword Indices"
        ],
        "documentation": [
            "A set of 16 or 8 doubleword/quadword memory locations pointed to by base address BASE_ADDR and index vector VINDEX with scale SCALE are gathered. The result is written into vector zmm1. The elements are specified via the VSIB (i.e., the index register is a zmm, holding packed indices). Elements will only be loaded if their corresponding mask bit is one. If an element’s mask bit is not set, the corresponding element of the destination register (zmm1) is left unchanged. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register (k1) are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "If the data element size is less than the index element size, the higher part of the destination register and the mask register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may update these unused elements to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.",
            "Note that:"
        ],
        "operands": [
            "reg.z, reg.q, mem.q",
            "reg.y, mem.q, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPGATHERDD:VPGATHERDQ.html"
        ]
    },
    "tpause": {
        "detail": [
            "Timed PAUSE"
        ],
        "documentation": [
            "TPAUSE instructs the processor to enter an implementation-dependent optimized state. There are two such optimized states to choose from: light-weight power/performance optimized state, and improved power/performance optimized state. The selection between the two is governed by the explicit input register bit[0] source operand.",
            "TPAUSE is available when CPUID.7.0:ECX.WAITPKG[bit 5] is enumerated as 1. TPAUSE may be executed at any privilege level. This instruction’s operation is the same in non-64-bit modes and in 64-bit mode.",
            "Unlike PAUSE, the TPAUSE instruction will not cause an abort when used inside a transactional region, described in the chapter Chapter 16, “Programming with Intel® Transactional Synchronization Extensions,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "The input register contains information such as the preferred optimized state the processor should enter as described in the following table. Bits other than bit 0 are reserved and will result in #GP if non-zero."
        ],
        "operands": [
            "reg.d, reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/TPAUSE.html"
        ]
    },
    "umonitor": {
        "detail": [
            "User Level Set Up Monitor Address"
        ],
        "documentation": [
            "The UMONITOR instruction arms address monitoring hardware using an address specified in the source register (the address range that the monitoring hardware checks for store operations can be determined by using the CPUID monitor leaf function, EAX=05H). A store to an address within the specified address range triggers the monitoring hardware. The state of monitor hardware is used by UMWAIT.",
            "The content of the source register is an effective address. By default, the DS segment is used to create a linear address that is monitored. Segment overrides can be used. The address range must use memory of the write-back type. Only write-back memory is guaranteed to correctly trigger the monitoring hardware. Additional information on determining what address range to use in order to prevent false wake-ups is described in Chapter 8, “MultipleProcessor Management” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.",
            "The UMONITOR instruction is ordered as a load operation with respect to other memory transactions. The instruction is subject to the permission checking and faults associated with a byte load. Like a load, UMONITOR sets the A-bit but not the D-bit in page tables.",
            "UMONITOR and UMWAIT are available when CPUID.7.0:ECX.WAITPKG[bit 5] is enumerated as 1. UMONITOR and UMWAIT may be executed at any privilege level. Except for the width of the source register, the instruction’s operation is the same in non-64-bit modes and in 64-bit mode.",
            "UMONITOR does not interoperate with the legacy MWAIT instruction. If UMONITOR was executed prior to executing MWAIT and following the most recent execution of the legacy MONITOR instruction, MWAIT will not enter an optimized state. Execution will continue to the instruction following MWAIT.",
            "The UMONITOR instruction causes a transactional abort when used inside a transactional region.",
            "The width of the source register (16b, 32b or 64b) is determined by the effective addressing width, which is affected in the standard way by the machine mode settings and 67 prefix."
        ],
        "operands": [
            "reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/UMONITOR.html"
        ]
    },
    "vmrun": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "pmulhuw": {
        "detail": [
            "Multiply Packed Unsigned Integers and Store High Result"
        ],
        "documentation": [
            "Performs a SIMD unsigned multiply of the packed unsigned word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each 32-bit intermediate results in the destination operand. (Figure 4-12 shows this operation when using 64-bit operands.)",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMULHUW.html"
        ]
    },
    "v4fmaddss": {
        "detail": [
            "Scalar Single-Precision Floating-Point Fused Multiply-Add (4-iterations)"
        ],
        "documentation": [
            "This instruction computes 4 sequential scalar fused single-precision floating-point multiply-add instructions with a sequentially selected memory operand in each of the four steps.",
            "In the above box, the notation of “+3” is used to denote that the instruction accesses 4 source registers based that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.",
            "This instruction supports memory fault suppression. The entire memory operand is loaded if the least significant mask bit is set to 1 or if a “no masking” encoding is used.",
            "The tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction.",
            "Rounding is performed at every FMA boundary. Exceptions are also taken sequentially. Pre- and post-computational exceptions of the first FMA take priority over the pre- and post-computational exceptions of the second FMA, etc."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.x, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/V4FMADDSS:V4FNMADDSS.html"
        ]
    },
    "xsusldtrk": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "tileloaddt1": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, mem"
        ],
        "url": [
            "https://"
        ]
    },
    "vpmacsdqh": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "cqo": {
        "detail": [
            "Convert Word to Doubleword/Convert Doubleword to Quadword"
        ],
        "documentation": [
            "Doubles the size of the operand in register AX, EAX, or RAX (depending on the operand size) by means of sign extension and stores the result in registers DX:AX, EDX:EAX, or RDX:RAX, respectively. The CWD instruction copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CQO instruction (available in 64-bit mode only) copies the sign (bit 63) of the value in the RAX register into every bit position in the RDX register.",
            "The CWD instruction can be used to produce a doubleword dividend from a word before word division. The CDQ instruction can be used to produce a quadword dividend from a doubleword before doubleword division. The CQO instruction can be used to produce a double quadword dividend from a quadword before a quadword division.",
            "The CWD and CDQ mnemonics reference the same opcode. The CWD instruction is intended for use when the operand-size attribute is 16 and the CDQ instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when CWD is used and to 32 when CDQ is used. Others may treat these mnemonics as synonyms (CWD/CDQ) and use the current setting of the operand-size attribute to determine the size of values to be converted, regardless of the mnemonic used.",
            "In 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. The CQO mnemonics reference the same opcode as CWD/CDQ. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/CWD:CDQ:CQO.html"
        ]
    },
    "vpmacsdql": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "pfsub": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vorpd": {
        "detail": [
            "Bitwise Logical OR of Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical OR of the two, four or eight packed double-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ORPD.html"
        ]
    },
    "movntpd": {
        "detail": [
            "Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint"
        ],
        "documentation": [
            "Moves the packed double-precision floating-point values in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register, YMM register or ZMM register, which is assumed to contain packed double-precision, floating-pointing data. The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.",
            "The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the IA-32 Intel Architecture Software Developer’s Manual, Volume 1.",
            "Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPD instructions if multiple processors might use different memory types to read/write the destination memory locations.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, VEX.L must be 0; otherwise instructions will #UD."
        ],
        "operands": [
            "mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVNTPD.html"
        ]
    },
    "vcomisd": {
        "detail": [
            "Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS"
        ],
        "documentation": [
            "Compares the double-precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).",
            "Operand 1 is an XMM register; operand 2 can be an XMM register or a 64 bit memory",
            "location. The COMISD instruction differs from the UCOMISD instruction in that it signals a SIMD floating-point invalid operation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISD instruction signals an invalid numeric exception only if a source operand is an SNaN.",
            "The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCOMISD is encoded with VEX.L=0. Encoding VCOMISD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.q, reg.q",
            "reg.q, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/COMISD.html"
        ]
    },
    "pcmpestrmq": {
        "detail": [
            "Packed Compare Explicit Length Strings, Return Mask"
        ],
        "documentation": [
            "The instruction compares data from two string fragments based on the encoded value in the imm8 contol byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates a mask stored to XMM0.",
            "Each string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). The second value is stored in an input length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length represents the number of bytes/words which are valid for the respective xmm/m128 data.",
            "The length of each input is interpreted as being the absolute-value of the value in the length register. The absolute-value computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value in the length register is greater than 16 (8) or less than -16 (-8).",
            "The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see Section 4.1). As defined by imm8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.",
            "Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:",
            "CFlag – Reset if IntRes2 is equal to zero, set otherwise",
            "ZFlag – Set if absolute-value of EDX is < 16 (8), reset otherwise",
            "SFlag – Set if absolute-value of EAX is < 16 (8), reset otherwise",
            "OFlag –IntRes2[0]",
            "AFlag – Reset",
            "PFlag – Reset",
            "Note: In VEX.128 encoded versions, bits (MAXVL-1:128) of XMM0 are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.x, reg.x, imm.b, reg, reg, reg.x",
            "reg.x, mem.x, imm.b, reg, reg, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPESTRM.html"
        ]
    },
    "kshiftrb": {
        "detail": [
            "Shift Right Mask Registers"
        ],
        "documentation": [
            "Shifts 8/16/32/64 bits in the second operand (source operand) right by the count specified in immediate and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/KSHIFTRW:KSHIFTRB:KSHIFTRQ:KSHIFTRD.html"
        ]
    },
    "kshiftrd": {
        "detail": [
            "Shift Right Mask Registers"
        ],
        "documentation": [
            "Shifts 8/16/32/64 bits in the second operand (source operand) right by the count specified in immediate and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/KSHIFTRW:KSHIFTRB:KSHIFTRQ:KSHIFTRD.html"
        ]
    },
    "pfmin": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vorps": {
        "detail": [
            "Bitwise Logical OR of Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical OR of the four, eight or sixteen packed single-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ORPS.html"
        ]
    },
    "vcomiss": {
        "detail": [
            "Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS"
        ],
        "documentation": [
            "Compares the single-precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).",
            "Operand 1 is an XMM register; operand 2 can be an XMM register or a 32 bit memory location.",
            "The COMISS instruction differs from the UCOMISS instruction in that it signals a SIMD floating-point invalid operation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISS instruction signals an invalid numeric exception only if a source operand is an SNaN.",
            "The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCOMISS is encoded with VEX.L=0. Encoding VCOMISS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/COMISS.html"
        ]
    },
    "kshiftrq": {
        "detail": [
            "Shift Right Mask Registers"
        ],
        "documentation": [
            "Shifts 8/16/32/64 bits in the second operand (source operand) right by the count specified in immediate and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/KSHIFTRW:KSHIFTRB:KSHIFTRQ:KSHIFTRD.html"
        ]
    },
    "movntps": {
        "detail": [
            "Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint"
        ],
        "documentation": [
            "Moves the packed single-precision floating-point values in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register, YMM register or ZMM register, which is assumed to contain packed single-precision, floating-pointing. The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.",
            "The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the IA-32 Intel Architecture Software Developer’s Manual, Volume 1.",
            "Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPS instructions if multiple processors might use different memory types to read/write the destination memory locations.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVNTPS.html"
        ]
    },
    "kshiftrw": {
        "detail": [
            "Shift Right Mask Registers"
        ],
        "documentation": [
            "Shifts 8/16/32/64 bits in the second operand (source operand) right by the count specified in immediate and place the least significant 8/16/32/64 bits of the result in the destination operand. The higher bits of the destination are zero-extended. The destination is set to zero if the count value is greater than 7 (for byte shift), 15 (for word shift), 31 (for doubleword shift) or 63 (for quadword shift).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/KSHIFTRW:KSHIFTRB:KSHIFTRQ:KSHIFTRD.html"
        ]
    },
    "psubsb": {
        "detail": [
            "Subtract Packed Signed Integers with Signed Saturation"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed signed integers of the source operand (second operand) from the packed signed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following paragraphs.",
            "The (V)PSUBSB instruction subtracts packed signed byte integers. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.",
            "The (V)PSUBSW instruction subtracts packed signed word integers. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBSB:PSUBSW.html"
        ]
    },
    "vp4dpwssds": {
        "detail": [
            "Dot Product of Signed Words with Dword Accumulation and Saturation (4-iterations)"
        ],
        "documentation": [
            "This instruction computes 4 sequential register source-block dot-products of two signed word operands with doubleword accumulation and signed saturation. The memory operand is sequentially selected in each of the four steps.",
            "In the above box, the notation of “+3” is used to denote that the instruction accesses 4 source registers based on that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.",
            "This instruction supports memory fault suppression. The entire memory operand is loaded if any bit of the lowest 16-bits of the mask is set to 1 or if a “no masking” encoding is used.",
            "The tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.z, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VP4DPWSSDS.html"
        ]
    },
    "unpcklpd": {
        "detail": [
            "Unpack and Interleave Low Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs an interleaved unpack of the low double-precision floating-point values from the first source operand and the second source operand.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.",
            "EVEX.128 encoded version: The first source operand is an XMM register. The second source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/UNPCKLPD.html"
        ]
    },
    "vfrczpd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vgetexpsd": {
        "detail": [
            "Convert Exponents of Scalar DP FP Values to DP FP Value"
        ],
        "documentation": [
            "Extracts the biased exponent from the normalized DP FP representation of the low qword data element of the source operand (the third operand) as unbiased signed integer value, or convert the denormal representation of input data to unbiased negative integer values. The integer value of the unbiased exponent is converted to double-precision FP value and written to the destination operand (the first operand) as DP FP numbers. Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand.",
            "The destination must be a XMM register, the source operand can be a XMM register or a float64 memory location. The low quadword element of the destination operand is conditionally updated with writemask k1.",
            "Each GETEXP operation converts the exponent value into a FP number (permitting input value in denormal representation). Special cases of input values are listed in Table 5-14.",
            "The formula is:",
            "GETEXP(x) = floor(log2(|x|))",
            "Notation floor(x) stands for maximal integer not exceeding real number x."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGETEXPSD.html"
        ]
    },
    "pmaddwd": {
        "detail": [
            "Multiply and Add Packed Integers"
        ],
        "documentation": [
            "Multiplies the individual signed words of the destination operand (first operand) by the corresponding signed words of the source operand (second operand), producing temporary signed, doubleword results. The adjacent double-word results are then summed and stored in the destination operand. For example, the corresponding low-order words (15-0) and (31-16) in the source and destination operands are multiplied by one another and the double-word results are added together and stored in the low doubleword of the destination register (31-0). The same operation is performed on the other pairs of adjacent words. (Figure 4-11 shows this operation when using 64-bit operands).",
            "The (V)PMADDWD instruction wraps around only in one situation: when the 2 pairs of words being operated on in a group are all 8000H. In this case, the result wraps around to 80000000H.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version: The first source and destination operands are MMX registers. The second source operand is an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX.512 encoded version: The second source operand can be an ZMM register or a 512-bit memory location. The first source and destination operands are ZMM registers.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMADDWD.html"
        ]
    },
    "vcvtne2ps2bf16": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpandnd": {
        "detail": [
            "Logical AND NOT"
        ],
        "documentation": [
            "Performs a bitwise logical NOT operation on the first source operand, then performs bitwise AND with second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bit in the first operand is 0 and the corresponding bit in the second operand is 1, otherwise it is set to 0.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 32/64-bit granularity.",
            "VEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/PANDN.html"
        ]
    },
    "subsd": {
        "detail": [
            "Subtract Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Subtract the low double-precision floating-point value in the second source operand from the first source operand and stores the double-precision floating-point result in the low quadword of the destination operand.",
            "The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded versions: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination operand is updated according to the writemask.",
            "Software should ensure VSUBSD is encoded with VEX.L=0. Encoding VSUBSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/SUBSD.html"
        ]
    },
    "vmaskmovdqu": {
        "detail": [
            "Conditional SIMD Packed Loads and Stores"
        ],
        "documentation": [
            "Conditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are specified in the first source operand.",
            "The mask bit for each data element is the most significant bit of that element in the first source operand. If a mask is 1, the corresponding data element is copied from the second source operand to the destination operand. If the mask is 0, the corresponding data element is set to zero in the load form of these instructions, and unmodified in the store form.",
            "The second source operand is a memory address for the load form of these instruction. The destination operand is a memory address for the store form of these instructions. The other operands are both XMM registers (for VEX.128 version) or YMM registers (for VEX.256 version).",
            "Faults occur only due to mask-bit required memory accesses that caused the faults. Faults will not occur due to referencing any memory location if the corresponding mask bit for that memory location is 0. For example, no faults will be detected if the mask bits are all zero.",
            "Unlike previous MASKMOV instructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to these instructions.",
            "Instruction behavior on alignment check reporting with mask bits of less than all 1s are the same as with mask bits of all 1s.",
            "VMASKMOV should not be used to access memory mapped I/O and un-cached memory as the access and the ordering of the individual loads or stores it does is implementation specific.",
            "In cases where mask bits indicate data should not be loaded or stored paging A and D bits will be set in an implementation dependent way. However, A and D bits are always set for pages where data is actually loaded/stored.",
            "Note: for load forms, the first source (the mask) is encoded in VEX.vvvv; the second source is encoded in rm_field, and the destination register is encoded in reg_field.",
            "Note: for store forms, the first source (the mask) is encoded in VEX.vvvv; the second source register is encoded in reg_field, and the destination memory location is encoded in rm_field."
        ],
        "operands": [
            "reg.x, reg.x, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VMASKMOV.html"
        ]
    },
    "and": {
        "detail": [
            "Logical AND"
        ],
        "documentation": [
            "Performs a bitwise AND operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is set to 1 if both corresponding bits of the first and second operands are 1; otherwise, it is set to 0.",
            "This instruction can be used with a LOCK prefix to allow the it to be executed atomically.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined."
        ],
        "operands": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/AND.html"
        ]
    },
    "vprold": {
        "detail": [
            "Bit Rotate Left"
        ],
        "documentation": [
            "Rotates the bits in the individual data elements (doublewords, or quadword) in the first source operand to the left by the number of bits specified in the count operand. If the value specified by the count operand is greater than 31 (for doublewords), or 63 (for a quadword), then the count operand modulo the data size (32 or 64) is used.",
            "EVEX.128 encoded version: The destination operand is a XMM register. The source operand is a XMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.",
            "EVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX.512 encoded version: The destination operand is a ZMM register updated according to the writemask. For the count operand in immediate form, the source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location, the count operand is an 8-bit immediate. For the count operand in variable form, the first source operand (the second operand) is a ZMM register and the counter operand (the third operand) is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location."
        ],
        "operands": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPROLD:VPROLVD:VPROLQ:VPROLVQ.html"
        ]
    },
    "unpcklps": {
        "detail": [
            "Unpack and Interleave Low Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs an interleaved unpack of the low single-precision floating-point values from the first source operand and the second source operand.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/UNPCKLPS.html"
        ]
    },
    "vfrczps": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vgetexpss": {
        "detail": [
            "Convert Exponents of Scalar SP FP Values to SP FP Value"
        ],
        "documentation": [
            "Extracts the biased exponent from the normalized SP FP representation of the low doubleword data element of the source operand (the third operand) as unbiased signed integer value, or convert the denormal representation of input data to unbiased negative integer values. The integer value of the unbiased exponent is converted to single-precision FP value and written to the destination operand (the first operand) as SP FP numbers. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand.",
            "The destination must be a XMM register, the source operand can be a XMM register or a float32 memory location. The the low doubleword element of the destination operand is conditionally updated with writemask k1.",
            "Each GETEXP operation converts the exponent value into a FP number (permitting input value in denormal representation). Special cases of input values are listed in Table 5-15.",
            "The formula is:",
            "GETEXP(x) = floor(log2(|x|))",
            "Notation floor(x) stands for maximal integer not exceeding real number x.",
            "Software usage of VGETEXPxx and VGETMANTxx instructions generally involve a combination of GETEXP operation and GETMANT operation (see VGETMANTPD). Thus VGETEXPxx instruction do not require software to handle SIMD FP exceptions."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGETEXPSS.html"
        ]
    },
    "clwb": {
        "detail": [
            "Cache Line Write Back"
        ],
        "documentation": [
            "Writes back to memory the cache line (if modified) that contains the linear address specified with the memory operand from any level of the cache hierarchy in the cache coherence domain. The line may be retained in the cache hierarchy in non-modified state. Retaining the line in the cache hierarchy is a performance optimization (treated as a hint by hardware) to reduce the possibility of cache miss on a subsequent access. Hardware may choose to retain the line at any of the levels in the cache hierarchy, and in some cases, may invalidate the line from the cache hierarchy. The source operand is a byte memory location.",
            "The availability of CLWB instruction is indicated by the presence of the CPUID feature flag CLWB (bit 24 of the EBX register, see “CPUID — CPU Identification” in this chapter). The aligned cache line size affected is also indicated with the CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).",
            "The memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It should be noted that processors are free to speculatively fetch and cache data from system memory regions that are assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types). PREFETCHh instructions can be used to provide the processor with hints for this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, the CLWB instruction is not ordered with respect to PREFETCHh instructions or any of the speculative fetching mechanisms (that is, data can be speculatively loaded into a cache line just before, during, or after the execution of a CLWB instruction that references the cache line).",
            "CLWB instruction is ordered only by store-fencing operations. For example, software can use an SFENCE, MFENCE, XCHG, or LOCK-prefixed instructions to ensure that previous stores are included in the write-back. CLWB instruction need not be ordered by another CLWB or CLFLUSHOPT instruction. CLWB is implicitly ordered with older stores executed by the logical processor to the same address.",
            "For usages that require only writing back modified data from cache lines to memory (do not require the line to be invalidated), and expect to subsequently access the data, software is recommended to use CLWB (with appropriate fencing) instead of CLFLUSH or CLFLUSHOPT for improved performance.",
            "The CLWB instruction can be used at all privilege levels and is subject to all permission checking and faults associated with a byte load. Like a load, the CLWB instruction sets the accessed flag but not the dirty flag in the page tables.",
            "In some implementations, the CLWB instruction may always cause transactional abort with Transactional Synchronization Extensions (TSX). CLWB instruction is not expected to be commonly used inside typical transactional regions. However, programmers must not rely on CLWB instruction to force a transactional abort, since whether they cause transactional abort is implementation dependent.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/CLWB.html"
        ]
    },
    "psubsw": {
        "detail": [
            "Subtract Packed Signed Integers with Signed Saturation"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed signed integers of the source operand (second operand) from the packed signed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following paragraphs.",
            "The (V)PSUBSB instruction subtracts packed signed byte integers. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.",
            "The (V)PSUBSW instruction subtracts packed signed word integers. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBSB:PSUBSW.html"
        ]
    },
    "vpandnq": {
        "detail": [
            "Logical AND NOT"
        ],
        "documentation": [
            "Performs a bitwise logical NOT operation on the first source operand, then performs bitwise AND with second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bit in the first operand is 0 and the corresponding bit in the second operand is 1, otherwise it is set to 0.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 32/64-bit granularity.",
            "VEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/PANDN.html"
        ]
    },
    "subss": {
        "detail": [
            "Subtract Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Subtract the low single-precision floating-point value from the second source operand and the first source operand and store the double-precision floating-point result in the low doubleword of the destination operand.",
            "The second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL-1:32) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded versions: Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination operand is updated according to the writemask.",
            "Software should ensure VSUBSS is encoded with VEX.L=0. Encoding VSUBSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/SUBSS.html"
        ]
    },
    "movq2dq": {
        "detail": [
            "Move Quadword from MMX Technology to XMM Register"
        ],
        "documentation": [
            "Moves the quadword from the source operand (second operand) to the low quadword of the destination operand (first operand). The source operand is an MMX technology register and the destination operand is an XMM register.",
            "This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the MOVQ2DQ instruction is executed.",
            "In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15)."
        ],
        "operands": [
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVQ2DQ.html"
        ]
    },
    "vscalefsd": {
        "detail": [
            "Scale Scalar Float64 Values With Float64 Values"
        ],
        "documentation": [
            "Performs a floating-point scale of the packed double-precision floating-point value in the first source operand by multiplying it by 2 power of the double-precision floating-point value in second source operand.",
            "The equation of this operation is given by:",
            "xmm1 := xmm2*2floor(xmm3).",
            "Floor(xmm3) means maximum integer value ≤ xmm3.",
            "If the result cannot be represented in double precision, then the proper overflow response (for positive scaling operand), or the proper underflow response (for negative scaling operand) is issued. The overflow and underflow responses are dependent on the rounding mode (for IEEE-compliant rounding), as well as on other settings in MXCSR (exception mask bits, FTZ bit), and on the SAE bit.",
            "EVEX encoded version: The first source operand is an XMM register. The second source operand is an XMM register or a memory location. The destination operand is an XMM register conditionally updated with writemask k1.",
            "Handling of special-case input values are listed in Table 5-30 and Table 5-31."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCALEFSD.html"
        ]
    },
    "vpbroadcastb": {
        "detail": [
            "Load with Broadcast Integer Data from General Purpose Register"
        ],
        "documentation": [
            "Broadcasts a 8-bit, 16-bit, 32-bit or 64-bit value from a general-purpose register (the second operand) to all the locations in the destination vector register (the first operand) using the writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.b",
            "reg.x, reg.b",
            "reg.x, reg.q, mem.b",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html"
        ]
    },
    "vprolq": {
        "detail": [
            "Bit Rotate Left"
        ],
        "documentation": [
            "Rotates the bits in the individual data elements (doublewords, or quadword) in the first source operand to the left by the number of bits specified in the count operand. If the value specified by the count operand is greater than 31 (for doublewords), or 63 (for a quadword), then the count operand modulo the data size (32 or 64) is used.",
            "EVEX.128 encoded version: The destination operand is a XMM register. The source operand is a XMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.",
            "EVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX.512 encoded version: The destination operand is a ZMM register updated according to the writemask. For the count operand in immediate form, the source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location, the count operand is an 8-bit immediate. For the count operand in variable form, the first source operand (the second operand) is a ZMM register and the counter operand (the third operand) is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location."
        ],
        "operands": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPROLD:VPROLVD:VPROLQ:VPROLVQ.html"
        ]
    },
    "vsqrtsd": {
        "detail": [
            "Compute Square Root of Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Computes the square root of the low double-precision floating-point value in the second source operand and stores the double-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. The quadword at bits 127:64 of the destination operand remains unchanged. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded versions: Bits 127:64 of the destination operand are copied from the corresponding bits of the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination operand is updated according to the writemask.",
            "Software should ensure VSQRTSD is encoded with VEX.L=0. Encoding VSQRTSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/SQRTSD.html"
        ]
    },
    "vpbroadcastd": {
        "detail": [
            "Load with Broadcast Integer Data from General Purpose Register"
        ],
        "documentation": [
            "Broadcasts a 8-bit, 16-bit, 32-bit or 64-bit value from a general-purpose register (the second operand) to all the locations in the destination vector register (the first operand) using the writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.d",
            "reg.x, reg.d",
            "reg.z, reg.q, mem.d",
            "reg.z, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html"
        ]
    },
    "vmovdqu64": {
        "detail": [
            "Move Unaligned Packed Integer Values"
        ],
        "documentation": [
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX encoded versions:",
            "Moves 128, 256 or 512 bits of packed byte/word/doubleword/quadword integer values from the source operand (the second operand) to the destination operand (first operand). This instruction can be used to load a vector register from a memory location, to store the contents of a vector register into a memory location, or to move data between two vector registers.",
            "The destination operand is updated at 8-bit (VMOVDQU8), 16-bit (VMOVDQU16), 32-bit (VMOVDQU32), or 64-bit (VMOVDQU64) granularity according to the writemask.",
            "VEX.256 encoded version:",
            "Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.",
            "Bits (MAXVL-1:256) of the destination register are zeroed."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html"
        ]
    },
    "vscalefss": {
        "detail": [
            "Scale Scalar Float32 Value With Float32 Value"
        ],
        "documentation": [
            "Performs a floating-point scale of the scalar single-precision floating-point value in the first source operand by multiplying it by 2 power of the float32 value in second source operand.",
            "The equation of this operation is given by:",
            "xmm1 := xmm2*2floor(xmm3).",
            "Floor(xmm3) means maximum integer value ≤ xmm3.",
            "If the result cannot be represented in single precision, then the proper overflow response (for positive scaling operand), or the proper underflow response (for negative scaling operand) is issued. The overflow and underflow responses are dependent on the rounding mode (for IEEE-compliant rounding), as well as on other settings in MXCSR (exception mask bits, FTZ bit), and on the SAE bit.",
            "EVEX encoded version: The first source operand is an XMM register. The second source operand is an XMM register or a memory location. The destination operand is an XMM register conditionally updated with writemask k1.",
            "Handling of special-case input values are listed in Table 5-30 and Table 5-32."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCALEFSS.html"
        ]
    },
    "vpbroadcastq": {
        "detail": [
            "Load with Broadcast Integer Data from General Purpose Register"
        ],
        "documentation": [
            "Broadcasts a 8-bit, 16-bit, 32-bit or 64-bit value from a general-purpose register (the second operand) to all the locations in the destination vector register (the first operand) using the writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.q",
            "reg.z, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html"
        ]
    },
    "vsqrtss": {
        "detail": [
            "Compute Square Root of Scalar Single-Precision Value"
        ],
        "documentation": [
            "Computes the square root of the low single-precision floating-point value in the second source operand and stores the single-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands is an XMM register.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 and EVEX encoded versions: Bits 127:32 of the destination operand are copied from the corresponding bits of the first source operand. Bits (MAXVL-1:128) of the destination ZMM register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination operand is updated according to the writemask.",
            "Software should ensure VSQRTSS is encoded with VEX.L=0. Encoding VSQRTSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/SQRTSS.html"
        ]
    },
    "vpbroadcastw": {
        "detail": [
            "Load with Broadcast Integer Data from General Purpose Register"
        ],
        "documentation": [
            "Broadcasts a 8-bit, 16-bit, 32-bit or 64-bit value from a general-purpose register (the second operand) to all the locations in the destination vector register (the first operand) using the writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.w",
            "reg.x, reg.w",
            "reg.x, reg.q, mem.w",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html"
        ]
    },
    "vpbroadcastmb2q": {
        "detail": [
            "Broadcast Mask to Vector Register"
        ],
        "documentation": [
            "Broadcasts the zero-extended 64/32 bit value of the low byte/word of the source operand (the second operand) to each 64/32 bit element of the destination operand (the first operand). The source operand is an opmask register. The destination operand is a ZMM register (EVEX.512), YMM register (EVEX.256), or XMM register (EVEX.128).",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPBROADCASTM.html"
        ]
    },
    "vpshrdd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "vpshrdq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "cmpxchg": {
        "detail": [
            "Compare and Exchange"
        ],
        "documentation": [
            "Compares the value in the AL, AX, EAX, or RAX register with the first operand (destination operand). If the two values are equal, the second operand (source operand) is loaded into the destination operand. Otherwise, the destination operand is loaded into the AL, AX, EAX or RAX register. RAX register is available only in 64-bit mode.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor’s bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The ZF flag is set if the values in the destination operand and register AL, AX, or EAX are equal; otherwise it is cleared. The CF, PF, AF, SF, and OF flags are set according to the results of the comparison operation."
        ],
        "operands": [
            "reg.b, reg.b, reg",
            "mem.b, reg.b, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPXCHG.html"
        ]
    },
    "xsave64": {
        "detail": [
            "Save Processor Extended States"
        ],
        "documentation": [
            "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.",
            "The format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Section 13.7, “Operation of XSAVE,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XSAVE instruction. The following items provide a high-level outline:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.z[4096], reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XSAVE.html"
        ]
    },
    "vpshrdw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "mulpd": {
        "detail": [
            "Multiply Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Multiply packed double-precision floating-point values from the first source operand with corresponding values in the second source operand, and stores the packed double-precision floating-point results in the destination operand.",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the destination YMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MULPD.html"
        ]
    },
    "sarx": {
        "detail": [
            "Shift Without Affecting Flags"
        ],
        "documentation": [
            "Shifts the bits of the first source operand (the second operand) to the left or right by a COUNT value specified in the second source operand (the third operand). The result is written to the destination operand (the first operand).",
            "The shift arithmetic right (SARX) and shift logical right (SHRX) instructions shift the bits of the destination operand to the right (toward less significant bit locations), SARX keeps and propagates the most significant bit (sign bit) while shifting.",
            "The logical shift left (SHLX) shifts the bits of the destination operand to the left (toward more significant bit locations).",
            "This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
            "If the value specified in the first source operand exceeds OperandSize -1, the COUNT value is masked.",
            "SARX,SHRX, and SHLX instructions do not update flags.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.d, reg.d, reg.d",
            "reg.d, mem.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/SARX:SHLX:SHRX.html"
        ]
    },
    "cpuid": {
        "detail": [
            "CPU Identification"
        ],
        "documentation": [
            "The ID flag (bit 21) in the EFLAGS register indicates support for the CPUID instruction. If a software procedure can set and clear this flag, the processor executing the procedure supports the CPUID instruction. This instruction operates the same in non-64-bit modes and 64-bit mode.",
            "CPUID returns processor identification and feature information in the EAX, EBX, ECX, and EDX registers.1 The instruction’s output is dependent on the contents of the EAX register upon execution (in some cases, ECX as well). For example, the following pseudocode loads EAX with 00H and causes CPUID to return a Maximum Return Value and the Vendor Identification String in the appropriate registers:",
            "MOV EAX, 00H",
            "CPUID",
            "Table 3-8 shows information returned, depending on the initial value loaded into the EAX register.",
            "Two types of information are returned: basic and extended function information. If a value entered for CPUID.EAX is higher than the maximum input value for basic or extended function for that processor then the data for the highest basic information leaf is returned. For example, using some Intel processors, the following is true:",
            "CPUID.EAX = 05H (* Returns MONITOR/MWAIT leaf. *)",
            "CPUID.EAX = 0AH (* Returns Architectural Performance Monitoring leaf. *) CPUID.EAX = 0BH (* Returns Extended Topology Enumeration leaf. *)2 CPUID.EAX =1FH (* Returns V2 Extended Topology Enumeration leaf. *)2",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/CPUID.html"
        ]
    },
    "vlddqu": {
        "detail": [
            "Load Unaligned Integer 128 Bits"
        ],
        "documentation": [
            "The instruction is functionally similar to (V)MOVDQU ymm/xmm, m256/m128 for loading from memory. That is: 32/16 bytes of data starting at an address specified by the source memory operand (second operand) are fetched from memory and placed in a destination register (first operand). The source operand need not be aligned on a 32/16-byte boundary. Up to 64/32 bytes may be loaded from memory; this is implementation dependent.",
            "This instruction may improve performance relative to (V)MOVDQU if the source operand crosses a cache line boundary. In situations that require the data loaded by (V)LDDQU be modified and stored to the same location, use (V)MOVDQU or (V)MOVDQA instead of (V)LDDQU. To move a double quadword to or from memory locations that are known to be aligned on 16-byte boundaries, use the (V)MOVDQA instruction."
        ],
        "operands": [
            "reg.x, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/LDDQU.html"
        ]
    },
    "mulps": {
        "detail": [
            "Multiply Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Multiply the packed single-precision floating-point values from the first source operand with the corresponding values in the second source operand, and stores the packed double-precision floating-point results in the destination operand.",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the destination YMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MULPS.html"
        ]
    },
    "vcvttps2uqq": {
        "detail": [
            "Convert with Truncation Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values"
        ],
        "documentation": [
            "Converts with truncation up to eight packed single-precision floating-point values in the source operand to unsigned quadword integers in the destination operand.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w – 1 is returned, where w represents the number of bits in the destination format.",
            "EVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64 bits) register or a 256/128/64-bit memory location. The destination operation is a vector register conditionally updated with writemask k1.",
            "Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.q",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTTPS2UQQ.html"
        ]
    },
    "tileloadd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, mem"
        ],
        "url": [
            "https://"
        ]
    },
    "lock xor": {
        "detail": [
            "Logical Exclusive OR"
        ],
        "documentation": [
            "Performs a bitwise exclusive OR (XOR) operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is 1 if the corresponding bits of the operands are different; each bit is 0 if the corresponding bits are the same.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined."
        ],
        "operands": [
            "mem.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/XOR.html"
        ]
    },
    "vpermt2pd": {
        "detail": [
            "Full Permute from Two Tables Overwriting one Table"
        ],
        "documentation": [
            "Permutes 16-bit/32-bit/64-bit values in the first operand and the third operand (the second source operand) using indices in the second operand (the first source operand) to select elements from the first and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.",
            "The first and second operands are ZMM/YMM/XMM registers. The second operand contains input indices to select elements from the two input tables in the 1st and 3rd operands. The first operand is also the destination of the result.",
            "D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).",
            "Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.",
            "Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.",
            "Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.",
            "Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. Note also that in this case, the same index can be reused for example for a second iteration, while the table elements being permuted are overwritten.",
            "Bits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMT2W:VPERMT2D:VPERMT2Q:VPERMT2PS:VPERMT2PD.html"
        ]
    },
    "mulx": {
        "detail": [
            "Unsigned Multiply Without Affecting Flags"
        ],
        "documentation": [
            "Performs an unsigned multiplication of the implicit source operand (EDX/RDX) and the specified source operand (the third operand) and stores the low half of the result in the second destination (second operand), the high half of the result in the first destination operand (first operand), without reading or writing the arithmetic flags. This enables efficient programming where the software can interleave add with carry operations and multiplications.",
            "If the first and second operand are identical, it will contain the high half of the multiplication result.",
            "This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.d, reg.d, reg.d, reg",
            "reg.d, reg.d, mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/MULX.html"
        ]
    },
    "sha1msg1": {
        "detail": [
            "Perform an Intermediate Calculation for the Next Four SHA1 Message Dwords"
        ],
        "documentation": [
            "The SHA1MSG1 instruction is one of two SHA1 message scheduling instructions. The instruction performs an intermediate calculation for the next four SHA1 message dwords.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/SHA1MSG1.html"
        ]
    },
    "sha1msg2": {
        "detail": [
            "Perform a Final Calculation for the Next Four SHA1 Message Dwords"
        ],
        "documentation": [
            "The SHA1MSG2 instruction is one of two SHA1 message scheduling instructions. The instruction performs the final calculation to derive the next four SHA1 message dwords.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/SHA1MSG2.html"
        ]
    },
    "repne lodsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "repne lodsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vpermt2ps": {
        "detail": [
            "Full Permute from Two Tables Overwriting one Table"
        ],
        "documentation": [
            "Permutes 16-bit/32-bit/64-bit values in the first operand and the third operand (the second source operand) using indices in the second operand (the first source operand) to select elements from the first and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.",
            "The first and second operands are ZMM/YMM/XMM registers. The second operand contains input indices to select elements from the two input tables in the 1st and 3rd operands. The first operand is also the destination of the result.",
            "D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).",
            "Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.",
            "Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.",
            "Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.",
            "Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. Note also that in this case, the same index can be reused for example for a second iteration, while the table elements being permuted are overwritten.",
            "Bits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMT2W:VPERMT2D:VPERMT2Q:VPERMT2PS:VPERMT2PD.html"
        ]
    },
    "bndmov": {
        "detail": [
            "Move Bounds"
        ],
        "documentation": [
            "BNDMOV moves a pair of lower and upper bound values from the source operand (the second operand) to the destination (the first operand). Each operation is 128-bit move. The exceptions are same as the MOV instruction. The memory format for loading/store bounds in 64-bit mode is shown in Figure 3-5.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, mem.x",
            "reg, reg",
            "mem.x, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/BNDMOV.html"
        ]
    },
    "xadd": {
        "detail": [
            "Exchange and Add"
        ],
        "documentation": [
            "Exchanges the first operand (destination operand) with the second operand (source operand), then loads the sum of the two values into the destination operand. The destination operand can be a register or a memory location; the source operand is a register.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "Flags Affected:",
            "The CF, PF, AF, SF, ZF, and OF flags are set according to the result of the addition, which is stored in the destination operand."
        ],
        "operands": [
            "reg.b, reg.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/XADD.html"
        ]
    },
    "xchg": {
        "detail": [
            "Exchange Register/Memory with Register"
        ],
        "documentation": [
            "Exchanges the contents of the destination (first) and source (second) operands. The operands can be two general-purpose registers or a register and a memory location. If a memory operand is referenced, the processor’s locking protocol is automatically implemented for the duration of the exchange operation, regardless of the presence or absence of the LOCK prefix or of the value of the IOPL. (See the LOCK prefix description in this chapter for more information on the locking protocol.)",
            "This instruction is useful for implementing semaphores or similar data structures for process synchronization. (See “Bus Locking” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for more information on bus locking.)",
            "The XCHG instruction can also be used instead of the BSWAP instruction for 16-bit operands.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b, reg.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/XCHG.html"
        ]
    },
    "repne lodsq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "repne lodsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.w, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "verr": {
        "detail": [
            "Verify a Segment for Reading or Writing"
        ],
        "documentation": [
            "Verifies whether the code or data segment specified with the source operand is readable (VERR) or writable (VERW) from the current privilege level (CPL). The source operand is a 16-bit register or a memory location that contains the segment selector for the segment to be verified. If the segment is accessible and readable (VERR) or writable (VERW), the ZF flag is set; otherwise, the ZF flag is cleared. Code segments are never verified as writable. This check cannot be performed on system segments.",
            "To set the ZF flag, the following conditions must be met:",
            "Flags Affected:",
            "The ZF flag is set to 1 if the segment is accessible and readable (VERR) or writable (VERW); otherwise, it is set to 0."
        ],
        "operands": [
            "reg.w",
            "mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/VERR:VERW.html"
        ]
    },
    "verw": {
        "detail": [
            "Verify a Segment for Reading or Writing"
        ],
        "documentation": [
            "Verifies whether the code or data segment specified with the source operand is readable (VERR) or writable (VERW) from the current privilege level (CPL). The source operand is a 16-bit register or a memory location that contains the segment selector for the segment to be verified. If the segment is accessible and readable (VERR) or writable (VERW), the ZF flag is set; otherwise, the ZF flag is cleared. Code segments are never verified as writable. This check cannot be performed on system segments.",
            "To set the ZF flag, the following conditions must be met:",
            "Flags Affected:",
            "The ZF flag is set to 1 if the segment is accessible and readable (VERR) or writable (VERW); otherwise, it is set to 0."
        ],
        "operands": [
            "reg.w",
            "mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/VERR:VERW.html"
        ]
    },
    "wrfsbase": {
        "detail": [
            "Write FS/GS Segment Base"
        ],
        "documentation": [
            "Loads the FS or GS segment base address with the general-purpose register indicated by the modR/M:r/m field.",
            "The source operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source register are ignored and upper 32 bits of the base address (for FS or GS) are cleared.",
            "This instruction is supported only in 64-bit mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/WRFSBASE:WRGSBASE.html"
        ]
    },
    "vpmacsdd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "movntsd": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "fidiv": {
        "detail": [
            "Divide"
        ],
        "documentation": [
            "Divides the destination operand by the source operand and stores the result in the destination location. The destination operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format.",
            "The no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0) register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location (either a floating-point or an integer value). The two-operand version, divides the contents of the ST(0) register by the contents of the ST(i) register or vice versa.",
            "The FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIV rather than FDIVP.",
            "The FIDIV instructions convert an integer source operand to double extended-precision floating-point format before performing the division. When the source operand is an integer 0, it is treated as a +0.",
            "If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.",
            "The following table shows the results obtained when dividing various classes of numbers, assuming that neither overflow nor underflow occurs."
        ],
        "operands": [
            "reg.wq, mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FDIV:FDIVP:FIDIV.html"
        ]
    },
    "bswap": {
        "detail": [
            "Byte Swap"
        ],
        "documentation": [
            "Reverses the byte order of a 32-bit or 64-bit (destination) register. This instruction is provided for converting little-endian values to big-endian format and vice versa. To swap bytes in a word value (16-bit register), use the XCHG instruction. When the BSWAP instruction references a 16-bit register, the result is undefined.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/BSWAP.html"
        ]
    },
    "adox": {
        "detail": [
            "Unsigned Integer Addition of Two Operands with Overflow Flag"
        ],
        "documentation": [
            "Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the overflow-flag (OF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of OF represents a carry from a previous addition. The instruction sets the OF flag with the carry generated by the unsigned addition of the operands.",
            "The ADOX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we execute an instruction to zero the OF (e.g. XOR).",
            "This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.",
            "In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64-bits.",
            "ADOX executes normally either inside or outside a transaction region.",
            "Note: ADOX defines the CF and OF flags differently than the ADD/ADC instructions as defined in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A.",
            "Flags Affected:",
            "OF is updated based on result. CF, SF, ZF, AF and PF flags are unmodified."
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADOX.html"
        ]
    },
    "pslldq": {
        "detail": [
            "Shift Double Quadword Left Logical"
        ],
        "documentation": [
            "Shifts the destination operand (first operand) to the left by the number of bytes specified in the count operand (second operand). The empty low-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate.",
            "128-bit Legacy SSE version: The source and destination operands are the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The source and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The source operand is YMM register. The destination operand is an YMM register. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed. The count operand applies to both the low and high 128-bit lanes.",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register. The count operand applies to each 128-bit lanes.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSLLDQ.html"
        ]
    },
    "movntss": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.d, reg.d"
        ],
        "url": [
            "https://"
        ]
    },
    "vgatherpf0qpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T0):"
        ],
        "operands": [
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGATHERPF0DPS:VGATHERPF0QPS:VGATHERPF0DPD:VGATHERPF0QPD.html"
        ]
    },
    "repe xcryptctr": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.b, reg, reg.d, reg, reg.q, mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vpunpcklwd": {
        "detail": [
            "Unpack Low Data"
        ],
        "documentation": [
            "Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-22 shows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html"
        ]
    },
    "fcmovbe": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "documentation": [
            "Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Description column above and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).",
            "The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.",
            "A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “COMISS—Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS” in this chapter). If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCMOVcc.html"
        ]
    },
    "vpmovsxbd": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "documentation": [
            "Legacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.d",
            "reg.x, reg.d",
            "reg.z, reg.q, mem.x",
            "reg.z, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVSX.html"
        ]
    },
    "vfrczsd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vgatherpf0qps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T0):"
        ],
        "operands": [
            "mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGATHERPF0DPS:VGATHERPF0QPS:VGATHERPF0DPD:VGATHERPF0QPD.html"
        ]
    },
    "movapd": {
        "detail": [
            "Move Aligned Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Moves 2, 4 or 8 double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM, YMM or ZMM register from an 128-bit, 256-bit or 512-bit memory location, to store the contents of an XMM, YMM or ZMM register into a 128-bit, 256-bit or 512-bit memory location, or to move data between two XMM, two YMM or two ZMM registers.",
            "When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte (128-bit versions), 32-byte (256-bit version) or 64-byte (EVEX.512 encoded version) boundary or a general-protection exception (#GP) will be generated. For EVEX encoded versions, the operand must be aligned to the size of the memory operand. To move double-precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX.512 encoded version:",
            "Moves 512 bits of packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a ZMM register from a 512-bit float64 memory location, to store the contents of a ZMM register into a 512-bit float64 memory location, or to move data between two ZMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 64-byte boundary or a general-protection exception (#GP) will be generated. To move single-precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.",
            "VEX.256 and EVEX.256 encoded versions:",
            "Moves 256 bits of packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary or a general-protection exception (#GP) will be generated. To move double-precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.",
            "128-bit versions:",
            "Moves 128 bits of packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. To move single-precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.",
            "(E)VEX.128 encoded version: Bits (MAXVL-1:128) of the destination ZMM register destination are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVAPD.html"
        ]
    },
    "vpmovsxbq": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "documentation": [
            "Legacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.w",
            "reg.x, reg.w",
            "reg.z, reg.q, mem.q",
            "reg.z, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVSX.html"
        ]
    },
    "fldl2e": {
        "detail": [
            "Load Constant"
        ],
        "documentation": [
            "Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, π, log102, and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.",
            "See the section titled “Approximation of Pi” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a description of the π constant.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FLD1:FLDL2T:FLDL2E:FLDPI:FLDLG2:FLDLN2:FLDZ.html"
        ]
    },
    "vpmovsxbw": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "documentation": [
            "Legacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.x, reg.q, mem.q",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVSX.html"
        ]
    },
    "bsf": {
        "detail": [
            "Bit Scan Forward"
        ],
        "documentation": [
            "Searches the source operand (second operand) for the least significant set bit (1 bit). If a least significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content of the source operand is 0, the content of the destination operand is undefined.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The ZF flag is set to 1 if the source operand is 0; otherwise, the ZF flag is cleared. The CF, OF, SF, AF, and PF flags are undefined."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/BSF.html"
        ]
    },
    "vfrczss": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.d",
            "reg.x, reg.d"
        ],
        "url": [
            "https://"
        ]
    },
    "movaps": {
        "detail": [
            "Move Aligned Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Moves 4, 8 or 16 single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM, YMM or ZMM register from an 128-bit, 256-bit or 512-bit memory location, to store the contents of an XMM, YMM or ZMM register into a 128-bit, 256-bit or 512-bit memory location, or to move data between two XMM, two YMM or two ZMM registers.",
            "When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary or a general-protection exception (#GP) will be generated. For EVEX.512 encoded versions, the operand must be aligned to the size of the memory operand. To move single-precision floating-point values to and from unaligned memory locations, use the VMOVUPS instruction.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX.512 encoded version:",
            "Moves 512 bits of packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a ZMM register from a 512-bit float32 memory location, to store the contents of a ZMM register into a float32 memory location, or to move data between two ZMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 64-byte boundary or a general-protection exception (#GP) will be generated. To move single-precision floating-point values to and from unaligned memory locations, use the VMOVUPS instruction.",
            "VEX.256 and EVEX.256 encoded version:",
            "Moves 256 bits of packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary or a general-protection exception (#GP) will be generated.",
            "128-bit versions:",
            "Moves 128 bits of packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. To move single-precision floating-point values to and from unaligned memory locations, use the VMOVUPS instruction.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.",
            "(E)VEX.128 encoded version: Bits (MAXVL-1:128) of the destination ZMM register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVAPS.html"
        ]
    },
    "fldl2t": {
        "detail": [
            "Load Constant"
        ],
        "documentation": [
            "Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, π, log102, and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.",
            "See the section titled “Approximation of Pi” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a description of the π constant.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FLD1:FLDL2T:FLDL2E:FLDPI:FLDLG2:FLDLN2:FLDZ.html"
        ]
    },
    "fiadd": {
        "detail": [
            "Add"
        ],
        "documentation": [
            "Adds the destination and source operands and stores the sum in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.",
            "The no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-operand version adds the contents of a memory location (either a floating-point or an integer value) to the contents of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice versa. The value in ST(0) can be doubled by coding:",
            "FADD ST(0), ST(0);",
            "The FADDP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. (The no-operand version of the floating-point add instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FADD rather than FADDP.)",
            "The FIADD instructions convert an integer source operand to double extended-precision floating-point format before performing the addition.",
            "The table on the following page shows the results obtained when adding various classes of numbers, assuming that neither overflow nor underflow occurs.",
            "When the sum of two operands with opposite signs is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. When the source operand is an integer 0, it is treated as a +0.",
            "When both operand are infinities of the same sign, the result is ∞ of the expected sign. If both operands are infinities of opposite signs, an invalid-operation exception is generated. See Table 3-18."
        ],
        "operands": [
            "reg.wq, mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FADD:FADDP:FIADD.html"
        ]
    },
    "vpmovsdb": {
        "detail": [
            "Down Convert DWord to Byte"
        ],
        "documentation": [
            "VPMOVDB down converts 32-bit integer elements in the source operand (the second operand) into packed bytes using truncation. VPMOVSDB converts signed 32-bit integers into packed signed bytes using signed saturation. VPMOVUSDB convert unsigned double-word values into unsigned byte values using unsigned saturation.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit memory location.",
            "Down-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:128/64/32) of the register destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.z",
            "mem.x, reg.q, reg.z",
            "mem.x, reg.z",
            "reg.x, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVDB:VPMOVSDB:VPMOVUSDB.html"
        ]
    },
    "vmovlpd": {
        "detail": [
            "Move Low Packed Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "This instruction cannot be used for register to register or memory to memory moves.",
            "128-bit Legacy SSE load:",
            "Moves a double-precision floating-point value from the source 64-bit memory operand and stores it in the low 64-bits of the destination XMM register. The upper 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.",
            "VEX.128 & EVEX encoded load:",
            "Loads a double-precision floating-point value from the source 64-bit memory operand (third operand), merges it with the upper 64-bits of the first source XMM register (second operand), and stores it in the low 128-bits of the destination XMM register (first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "128-bit store:",
            "Stores a double-precision floating-point value from the low 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).",
            "Note: VMOVLPD (store) (VEX.128.66.0F 13 /r) is legal and has the same behavior as the existing 66 0F 13 store. For VMOVLPD (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.",
            "If VMOVLPD is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.x, reg.x, mem.q",
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVLPD.html"
        ]
    },
    "ptest": {
        "detail": [
            "Logical Compare"
        ],
        "documentation": [
            "PTEST and VPTEST set the ZF flag if all bits in the result are 0 of the bitwise AND of the first source operand (first operand) and the second source operand (second operand). VPTEST sets the CF flag if all bits in the result are 0 of the bitwise AND of the second source operand (second operand) and the logical NOT of the destination operand.",
            "The first source register is specified by the ModR/M reg field.",
            "128-bit versions: The first source register is an XMM register. The second source register can be an XMM register or a 128-bit memory location. The destination register is not modified.",
            "VEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination register is not modified.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
            "Flags Affected:",
            "The 0F, AF, PF, SF flags are cleared and the ZF, CF flags are set according to the operation."
        ],
        "operands": [
            "reg.x, reg.x",
            "reg.x, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PTEST.html"
        ]
    },
    "bsr": {
        "detail": [
            "Bit Scan Reverse"
        ],
        "documentation": [
            "Searches the source operand (second operand) for the most significant set bit (1 bit). If a most significant 1 bit is found, its bit index is stored in the destination operand (first operand). The source operand can be a register or a memory location; the destination operand is a register. The bit index is an unsigned offset from bit 0 of the source operand. If the content source operand is 0, the content of the destination operand is undefined.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The ZF flag is set to 1 if the source operand is 0; otherwise, the ZF flag is cleared. The CF, OF, SF, AF, and PF flags are undefined."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/BSR.html"
        ]
    },
    "fxtract": {
        "detail": [
            "Extract Exponent and Significand"
        ],
        "documentation": [
            "Separates the source value in the ST(0) register into its exponent and significand, stores the exponent in ST(0), and pushes the significand onto the register stack. Following this operation, the new top-of-stack register ST(0) contains the value of the original significand expressed as a floating-point value. The sign and significand of this value are the same as those found in the source operand, and the exponent is 3FFFH (biased value for a true exponent of zero). The ST(1) register contains the value of the original operand’s true (unbiased) exponent expressed as a floating-point value. (The operation performed by this instruction is a superset of the IEEE-recommended logb(x) function.)",
            "This instruction and the F2XM1 instruction are useful for performing power and range scaling operations. The FXTRACT instruction is also useful for converting numbers in double extended-precision floating-point format to decimal representations (e.g., for printing or displaying).",
            "If the floating-point zero-divide exception (#Z) is masked and the source operand is zero, an exponent value of –∞ is stored in register ST(1) and 0 with the sign of the source operand is stored in register ST(0).",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FXTRACT.html"
        ]
    },
    "kunpckwd": {
        "detail": [
            "Unpack for Mask Registers"
        ],
        "documentation": [
            "Unpacks the lower 8/16/32 bits of the second and third operands (source operands) into the low part of the first operand (destination operand), starting from the low bytes. The result is zero-extended in the destination.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KUNPCKBW:KUNPCKWD:KUNPCKDQ.html"
        ]
    },
    "vmovlps": {
        "detail": [
            "Move Low Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "This instruction cannot be used for register to register or memory to memory moves.",
            "128-bit Legacy SSE load:",
            "Moves two packed single-precision floating-point values from the source 64-bit memory operand and stores them in the low 64-bits of the destination XMM register. The upper 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.",
            "VEX.128 & EVEX encoded load:",
            "Loads two packed single-precision floating-point values from the source 64-bit memory operand (the third operand), merges them with the upper 64-bits of the first source operand (the second operand), and stores them in the low 128-bits of the destination register (the first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "128-bit store:",
            "Loads two packed single-precision floating-point values from the low 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).",
            "Note: VMOVLPS (store) (VEX.128.0F 13 /r) is legal and has the same behavior as the existing 0F 13 store. For VMOVLPS (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.",
            "If VMOVLPS is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.x, reg.x, mem.q",
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVLPS.html"
        ]
    },
    "vpmovsdw": {
        "detail": [
            "Down Convert DWord to Word"
        ],
        "documentation": [
            "VPMOVDW down converts 32-bit integer elements in the source operand (the second operand) into packed words using truncation. VPMOVSDW converts signed 32-bit integers into packed signed words using signed saturation. VPMOVUSDW convert unsigned double-word values into unsigned word values using unsigned saturation.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.",
            "Down-converted word elements are written to the destination operand (the first operand) from the least-significant word. Word elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.y, reg.z",
            "mem.y, reg.q, reg.z",
            "mem.y, reg.z",
            "reg.y, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVDW:VPMOVSDW:VPMOVUSDW.html"
        ]
    },
    "vpmovmskb": {
        "detail": [
            "Move Byte Mask"
        ],
        "documentation": [
            "Creates a mask made up of the most significant bit of each byte of the source operand (second operand) and stores the result in the low byte or word of the destination operand (first operand).",
            "The byte mask is 8 bits for 64-bit source operand, 16 bits for 128-bit source operand and 32 bits for 256-bit source operand. The destination operand is a general-purpose register.",
            "In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.",
            "Legacy SSE version: The source operand is an MMX technology register.",
            "128-bit Legacy SSE version: The source operand is an XMM register.",
            "VEX.128 encoded version: The source operand is an XMM register.",
            "VEX.256 encoded version: The source operand is a YMM register.",
            "Note: VEX.vvvv is reserved and must be 1111b.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.d, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVMSKB.html"
        ]
    },
    "aesencwide256kl": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.z, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "sysret": {
        "detail": [
            "Return From Fast System Call"
        ],
        "documentation": [
            "SYSRET is a companion instruction to the SYSCALL instruction. It returns from an OS system-call handler to user code at privilege level 3. It does so by loading RIP from RCX and loading RFLAGS from R11.1 With a 64-bit operand size, SYSRET remains in 64-bit mode; otherwise, it enters compatibility mode and only the low 32 bits of the registers are loaded.",
            "Flags Affected:",
            "All."
        ],
        "operands": [
            "reg.q, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/SYSRET.html"
        ]
    },
    "vcvtpd2dq": {
        "detail": [
            "Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers"
        ],
        "documentation": [
            "Converts packed double-precision floating-point values in the source operand (second operand) to packed signed doubleword integers in the destination operand (first operand).",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1. The upper bits (MAXVL-1:256/128/64) of the corresponding destination are zeroed.",
            "VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:64) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.y, reg.q, mem.z",
            "reg.y, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTPD2DQ.html"
        ]
    },
    "vpermil2pd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x, imm.b",
            "reg.x, reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, mem.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "xsetbv": {
        "detail": [
            "Set Extended Control Register"
        ],
        "documentation": [
            "Writes the contents of registers EDX:EAX into the 64-bit extended control register (XCR) specified in the ECX register. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The contents of the EDX register are copied to high-order 32 bits of the selected XCR and the contents of the EAX register are copied to low-order 32 bits of the XCR. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are ignored.) Undefined or reserved bits in an XCR should be set to values previously read.",
            "This instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) is generated. Specifying a reserved or unimplemented XCR in ECX will also cause a general protection exception. The processor will also generate a general protection exception if software attempts to write to reserved bits in an XCR.",
            "Currently, only XCR0 is supported. Thus, all other values of ECX are reserved and will cause a #GP(0). Note that bit 0 of XCR0 (corresponding to x87 state) must be set to 1; the instruction will cause a #GP(0) if an attempt is made to clear this bit. In addition, the instruction causes a #GP(0) if an attempt is made to set XCR0[2] (AVX state) while clearing XCR0[1] (SSE state); it is necessary to set both bits to use AVX instructions; Section 13.3, “Enabling the XSAVE Feature Set and XSAVE-Enabled Features,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XSETBV.html"
        ]
    },
    "xend": {
        "detail": [
            "Transactional End"
        ],
        "documentation": [
            "The instruction marks the end of an RTM code region. If this corresponds to the outermost scope (that is, including this XEND instruction, the number of XBEGIN instructions is the same as number of XEND instructions), the logical processor will attempt to commit the logical processor state atomically. If the commit fails, the logical processor will rollback all architectural register and memory updates performed during the RTM execution. The logical processor will resume execution at the fallback address computed from the outermost XBEGIN instruction. The EAX register is updated to reflect RTM abort information.",
            "XEND executed outside a transactional region will cause a #GP (General Protection Fault).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/XEND.html"
        ]
    },
    "btc": {
        "detail": [
            "Bit Test and Complement"
        ],
        "documentation": [
            "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and complements the selected bit in the bit string. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:",
            "Flags Affected:",
            "The CF flag contains the value of the selected bit before it is complemented. The ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined."
        ],
        "operands": [
            "reg.w, reg.w",
            "mem.w, imm.b",
            "reg.w, imm.b",
            "mem.w, reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/BTC.html"
        ]
    },
    "mulsd": {
        "detail": [
            "Multiply Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Multiplies the low double-precision floating-point value in the second source operand by the low double-precision floating-point value in the first source operand, and stores the double-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source operand and the destination operands are XMM registers.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded version: The quadword at bits 127:64 of the destination operand is copied from the same bits of the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination operand is updated according to the writemask.",
            "Software should ensure VMULSD is encoded with VEX.L=0. Encoding VMULSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MULSD.html"
        ]
    },
    "vpermil2ps": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x, imm.b",
            "reg.x, reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, mem.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "rmpupdate": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, reg"
        ],
        "url": [
            "https://"
        ]
    },
    "btr": {
        "detail": [
            "Bit Test and Reset"
        ],
        "documentation": [
            "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and clears the selected bit in the bit string to 0. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:",
            "Flags Affected:",
            "The CF flag contains the value of the selected bit before it is cleared. The ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined."
        ],
        "operands": [
            "reg.w, reg.w",
            "mem.w, imm.b",
            "reg.w, imm.b",
            "mem.w, reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/BTR.html"
        ]
    },
    "bts": {
        "detail": [
            "Bit Test and Set"
        ],
        "documentation": [
            "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and sets the selected bit in the bit string to 1. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:",
            "Flags Affected:",
            "The CF flag contains the value of the selected bit before it is set. The ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined."
        ],
        "operands": [
            "reg.w, reg.w",
            "mem.w, imm.b",
            "reg.w, imm.b",
            "mem.w, reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/BTS.html"
        ]
    },
    "tzcnt": {
        "detail": [
            "Count the Number of Trailing Zero Bits"
        ],
        "documentation": [
            "TZCNT counts the number of trailing least significant zero bits in source operand (second operand) and returns the result in destination operand (first operand). TZCNT is an extension of the BSF instruction. The key difference between TZCNT and BSF instruction is that TZCNT provides operand size as output when source operand is zero while in the case of BSF instruction, if source operand is zero, the content of destination operand are undefined. On processors that do not support TZCNT, the instruction byte encoding is executed as BSF.",
            "Flags Affected:",
            "ZF is set to 1 in case of zero output (least significant bit of the source is set), and to 0 otherwise, CF is set to 1 if the input was zero and cleared otherwise. OF, SF, PF and AF flags are undefined."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/TZCNT.html"
        ]
    },
    "mulss": {
        "detail": [
            "Multiply Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Multiplies the low single-precision floating-point value from the second source operand by the low single-precision floating-point value in the first source operand, and stores the single-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 32-bit memory location. The first source operand and the destination operands are XMM registers.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 and EVEX encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The three high-order doublewords of the destination operand are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination operand is updated according to the writemask.",
            "Software should ensure VMULSS is encoded with VEX.L=0. Encoding VMULSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/MULSS.html"
        ]
    },
    "fild": {
        "detail": [
            "Load Integer"
        ],
        "documentation": [
            "Converts the signed-integer source operand into double extended-precision floating-point format and pushes the value onto the FPU register stack. The source operand can be a word, doubleword, or quadword integer. It is loaded without rounding errors. The sign of the source operand is preserved.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, mem.d, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FILD.html"
        ]
    },
    "seamops": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "pmovsxbd": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "documentation": [
            "Legacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.d",
            "reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVSX.html"
        ]
    },
    "vpmulhrsw": {
        "detail": [
            "Packed Multiply High with Round and Scale"
        ],
        "documentation": [
            "PMULHRSW multiplies vertically each signed 16-bit integer from the destination operand (first operand) with the corresponding signed 16-bit integer of the source operand (second operand), producing intermediate, signed 32-bit integers. Each intermediate 32-bit integer is truncated to the 18 most significant bits. Rounding is always performed by adding 1 to the least significant bit of the 18-bit intermediate result. The final result is obtained by selecting the 16 bits immediately to the right of the most significant bit of each 18-bit intermediate result and packed to the destination operand.",
            "When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "In 64-bit mode and not encoded with VEX/EVEX, use the REX prefix to access XMM8-XMM15 registers.",
            "Legacy SSE version 64-bit operand: Both operands can be MMX registers. The second source operand is an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMULHRSW.html"
        ]
    },
    "bt": {
        "detail": [
            "Bit Test"
        ],
        "documentation": [
            "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset (specified by the second operand) and stores the value of the bit in the CF flag. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:",
            "Flags Affected:",
            "The CF flag contains the value of the selected bit. The ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined."
        ],
        "operands": [
            "reg.w, reg.w",
            "mem.w, imm.b",
            "reg.w, imm.b",
            "mem.w, reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/BT.html"
        ]
    },
    "pmovsxbq": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "documentation": [
            "Legacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.w",
            "reg.x, reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVSX.html"
        ]
    },
    "pmovsxbw": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "documentation": [
            "Legacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVSX.html"
        ]
    },
    "pswapd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vpmovsxdq": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "documentation": [
            "Legacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVSX.html"
        ]
    },
    "fprem1": {
        "detail": [
            "Partial Remainder"
        ],
        "documentation": [
            "Computes the IEEE remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following value:",
            "Remainder ← ST(0) − (Q ∗ ST(1))",
            "Here, Q is an integer value that is obtained by rounding the floating-point number quotient of [ST(0) / ST(1)] toward the nearest integer value. The magnitude of the remainder is less than or equal to half the magnitude of the modulus, unless a partial remainder was computed (as described below).",
            "This instruction produces an exact result; the precision (inexact) exception does not occur and the rounding control has no effect. The following table shows the results obtained when computing the remainder of various classes of numbers, assuming that underflow does not occur."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FPREM1.html"
        ]
    },
    "cwd": {
        "detail": [
            "Convert Word to Doubleword/Convert Doubleword to Quadword"
        ],
        "documentation": [
            "Doubles the size of the operand in register AX, EAX, or RAX (depending on the operand size) by means of sign extension and stores the result in registers DX:AX, EDX:EAX, or RDX:RAX, respectively. The CWD instruction copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CQO instruction (available in 64-bit mode only) copies the sign (bit 63) of the value in the RAX register into every bit position in the RDX register.",
            "The CWD instruction can be used to produce a doubleword dividend from a word before word division. The CDQ instruction can be used to produce a quadword dividend from a doubleword before doubleword division. The CQO instruction can be used to produce a double quadword dividend from a quadword before a quadword division.",
            "The CWD and CDQ mnemonics reference the same opcode. The CWD instruction is intended for use when the operand-size attribute is 16 and the CDQ instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when CWD is used and to 32 when CDQ is used. Others may treat these mnemonics as synonyms (CWD/CDQ) and use the current setting of the operand-size attribute to determine the size of values to be converted, regardless of the mnemonic used.",
            "In 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. The CQO mnemonics reference the same opcode as CWD/CDQ. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/CWD:CDQ:CQO.html"
        ]
    },
    "wrussd": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.d, reg.d"
        ],
        "url": [
            "https://"
        ]
    },
    "slwpcb": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d"
        ],
        "url": [
            "https://"
        ]
    },
    "wrussq": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "roundpd": {
        "detail": [
            "Round Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Round the 2 double-precision floating-point values in the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the results in the destination operand (first operand). The rounding process rounds each input floating-point value to an integer value and returns the integer result as a double-precision floating-point value.",
            "The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-17 lists the encoded values for rounding-mode field).",
            "The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.",
            "128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/ROUNDPD.html"
        ]
    },
    "wrpkru": {
        "detail": [
            "Write Data to User Page Key Register"
        ],
        "documentation": [
            "Writes the value of EAX into PKRU. ECX and EDX must be 0 when WRPKRU is executed; otherwise, a general-protection exception (#GP) occurs.",
            "WRPKRU can be executed only if CR4.PKE = 1; otherwise, an invalid-opcode exception (#UD) occurs. Software can discover the value of CR4.PKE by examining CPUID.(EAX=07H,ECX=0H):ECX.OSPKE [bit 4].",
            "On processors that support the Intel 64 Architecture, the high-order 32-bits of RCX, RDX and RAX are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/WRPKRU.html"
        ]
    },
    "vmovd": {
        "detail": [
            "Move Doubleword/Move Quadword"
        ],
        "documentation": [
            "Copies a doubleword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be general-purpose registers, MMX technology registers, XMM registers, or 32-bit memory locations. This instruction can be used to move a doubleword to and from the low doubleword of an MMX technology register and a general-purpose register or a 32-bit memory location, or to and from the low doubleword of an XMM register and a general-purpose register or a 32-bit memory location. The instruction cannot be used to transfer data between MMX technology registers, between XMM registers, between general-purpose registers, or between memory locations.",
            "When the destination operand is an MMX technology register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 64 bits. When the destination operand is an XMM register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 128 bits.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.x, mem.d",
            "reg.x, reg.d",
            "mem.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVD:MOVQ.html"
        ]
    },
    "fmul": {
        "detail": [
            "Multiply"
        ],
        "documentation": [
            "Multiplies the destination and source operands and stores the product in the destination location. The destination operand is always an FPU data register; the source operand can be an FPU data register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.",
            "The no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0) register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0) register by the contents of a memory location (either a floating point or an integer value) and stores the product in the ST(0) register. The two-operand version, multiplies the contents of the ST(0) register by the contents of the ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the destination operand).",
            "The FMULP instructions perform the additional operation of popping the FPU register stack after storing the product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FMUL rather than FMULP.",
            "The FIMUL instructions convert an integer source operand to double extended-precision floating-point format before performing the multiplication.",
            "The sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multiplied is 0 or ∞. When the source operand is an integer 0, it is treated as a +0.",
            "The following table shows the results obtained when multiplying various classes of numbers, assuming that neither overflow nor underflow occurs."
        ],
        "operands": [
            "reg.wq, mem.d, reg",
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FMUL:FMULP:FIMUL.html"
        ]
    },
    "wrssd": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.d, reg.d"
        ],
        "url": [
            "https://"
        ]
    },
    "pmovmskb": {
        "detail": [
            "Move Byte Mask"
        ],
        "documentation": [
            "Creates a mask made up of the most significant bit of each byte of the source operand (second operand) and stores the result in the low byte or word of the destination operand (first operand).",
            "The byte mask is 8 bits for 64-bit source operand, 16 bits for 128-bit source operand and 32 bits for 256-bit source operand. The destination operand is a general-purpose register.",
            "In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.",
            "Legacy SSE version: The source operand is an MMX technology register.",
            "128-bit Legacy SSE version: The source operand is an XMM register.",
            "VEX.128 encoded version: The source operand is an XMM register.",
            "VEX.256 encoded version: The source operand is a YMM register.",
            "Note: VEX.vvvv is reserved and must be 1111b.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVMSKB.html"
        ]
    },
    "ucomisd": {
        "detail": [
            "Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS"
        ],
        "documentation": [
            "Performs an unordered compare of the double-precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).",
            "Operand 1 is an XMM register; operand 2 can be an XMM register or a 64 bit memory",
            "location.",
            "The UCOMISD instruction differs from the COMISD instruction in that it signals a SIMD floating-point invalid operation exception (#I) only when a source operand is an SNaN. The COMISD instruction signals an invalid numeric exception only if a source operand is either an SNaN or a QNaN.",
            "The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCOMISD is encoded with VEX.L=0. Encoding VCOMISD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.q, reg.q",
            "reg.q, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/UCOMISD.html"
        ]
    },
    "roundps": {
        "detail": [
            "Round Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Round the 4 single-precision floating-point values in the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the results in the destination operand (first operand). The rounding process rounds each input floating-point value to an integer value and returns the integer result as a single-precision floating-point value.",
            "The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-17 lists the encoded values for rounding-mode field).",
            "The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.",
            "128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/ROUNDPS.html"
        ]
    },
    "vphsubd": {
        "detail": [
            "Packed Horizontal Subtract"
        ],
        "documentation": [
            "(V)PHSUBW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands, and packs the signed 16-bit results to the destination operand (first operand). (V)PHSUBD performs horizontal subtraction on each adjacent pair of 32-bit signed integers by subtracting the most significant doubleword from the least significant doubleword of each pair, and packs the signed 32-bit result to the destination operand. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "In 64-bit mode, use the REX prefix to access additional registers.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.",
            "Note: VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PHSUBW:PHSUBD.html"
        ]
    },
    "vmovq": {
        "detail": [
            "Move Quadword"
        ],
        "documentation": [
            "Copies a quadword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be MMX technology registers, XMM registers, or 64-bit memory locations. This instruction can be used to move a quadword between two MMX technology registers or between an MMX technology register and a 64-bit memory location, or to move data between two XMM registers or between an XMM register and a 64-bit memory location. The instruction cannot be used to transfer data between memory locations.",
            "When the source operand is an XMM register, the low quadword is moved; when the destination operand is an XMM register, the quadword is stored to the low quadword of the register, and the high quadword is cleared to all 0s.",
            "In 64-bit mode and if not encoded using VEX/EVEX, use of the REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "If VMOVQ is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVQ.html"
        ]
    },
    "cvtpd2dq": {
        "detail": [
            "Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers"
        ],
        "documentation": [
            "Converts packed double-precision floating-point values in the source operand (second operand) to packed signed doubleword integers in the destination operand (first operand).",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1. The upper bits (MAXVL-1:256/128/64) of the corresponding destination are zeroed.",
            "VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:64) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTPD2DQ.html"
        ]
    },
    "fldcw": {
        "detail": [
            "Load x87 FPU Control Word"
        ],
        "documentation": [
            "Loads the 16-bit source operand into the FPU control word. The source operand is a memory location. This instruction is typically used to establish or change the FPU’s mode of operation.",
            "If one or more exception flags are set in the FPU status word prior to loading a new FPU control word and the new control word unmasks one or more of those exceptions, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled “Software Exception Handling” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). To avoid raising exceptions when changing FPU operating modes, clear any pending exceptions (using the FCLEX or FNCLEX instruction) before loading the new control word.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "mem.w, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FLDCW.html"
        ]
    },
    "wrssq": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "cmpxchg16b": {
        "detail": [
            "Compare and Exchange Bytes"
        ],
        "documentation": [
            "Compares the 64-bit value in EDX:EAX (or 128-bit value in RDX:RAX if operand size is 128 bits) with the operand (destination operand). If the values are equal, the 64-bit value in ECX:EBX (or 128-bit value in RCX:RBX) is stored in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX (or RDX:RAX). The destination operand is an 8-byte memory location (or 16-byte memory location if operand size is 128 bits). For the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the low-order 32 bits of a 64-bit value. For the RDX:RAX and RCX:RBX register pairs, RDX and RCX contain the high-order 64 bits and RAX and RBX contain the low-order 64bits of a 128-bit value.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor’s bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)",
            "In 64-bit mode, default operation size is 64 bits. Use of the REX.W prefix promotes operation to 128 bits. Note that CMPXCHG16B requires that the destination (memory) operand be 16-byte aligned. See the summary chart at the beginning of this section for encoding data and limits. For information on the CPUID flag that indicates CMPXCHG16B, see page 3-213.",
            "Flags Affected:",
            "The ZF flag is set if the destination operand and EDX:EAX are equal; otherwise it is cleared. The CF, PF, AF, SF, and OF flags are unaffected."
        ],
        "operands": [
            "mem.x, reg, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPXCHG8B:CMPXCHG16B.html"
        ]
    },
    "tilerelease": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "vgatherpf1qpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T1):"
        ],
        "operands": [
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGATHERPF1DPS:VGATHERPF1QPS:VGATHERPF1DPD:VGATHERPF1QPD.html"
        ]
    },
    "ucomiss": {
        "detail": [
            "Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS"
        ],
        "documentation": [
            "Compares the single-precision floating-point values in the low doublewords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).",
            "Operand 1 is an XMM register; operand 2 can be an XMM register or a 32 bit memory location.",
            "The UCOMISS instruction differs from the COMISS instruction in that it signals a SIMD floating-point invalid operation exception (#I) only if a source operand is an SNaN. The COMISS instruction signals an invalid numeric exception when a source operand is either a QNaN or SNaN.",
            "The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCOMISS is encoded with VEX.L=0. Encoding VCOMISS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/UCOMISS.html"
        ]
    },
    "vpdpwssds": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vphsubw": {
        "detail": [
            "Packed Horizontal Subtract"
        ],
        "documentation": [
            "(V)PHSUBW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands, and packs the signed 16-bit results to the destination operand (first operand). (V)PHSUBD performs horizontal subtraction on each adjacent pair of 32-bit signed integers by subtracting the most significant doubleword from the least significant doubleword of each pair, and packs the signed 32-bit result to the destination operand. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "In 64-bit mode, use the REX prefix to access additional registers.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.",
            "Note: VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PHSUBW:PHSUBD.html"
        ]
    },
    "vgatherpf1qps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T1):"
        ],
        "operands": [
            "mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGATHERPF1DPS:VGATHERPF1QPS:VGATHERPF1DPD:VGATHERPF1QPD.html"
        ]
    },
    "vshufpd": {
        "detail": [
            "Packed Interleave Shuffle of Pairs of Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Selects a double-precision floating-point value of an input pair using a bit control and move to a designated element of the destination operand. The low-to-high order of double-precision element of the destination operand is interleaved between the first source operand and the second source operand at the granularity of input pair of 128 bits. Each bit in the imm8 byte, starting from bit 0, is the select control of the corresponding element of the destination to received the shuffled result of an input pair.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location The destination operand is a ZMM/YMM/XMM register updated according to the writemask. The select controls are the lower 8/4/2 bits of the imm8 byte.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The select controls are the bit 3:0 of the imm8 byte, imm8[7:4) are ignored.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed. The select controls are the bit 1:0 of the imm8 byte, imm8[7:2) are ignored.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination operand and the first source operand is the same and is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. The select controls are the bit 1:0 of the imm8 byte, imm8[7:2) are ignored."
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SHUFPD.html"
        ]
    },
    "vpsadbw": {
        "detail": [
            "Compute Sum of Absolute Differences"
        ],
        "documentation": [
            "Computes the absolute value of the difference of 8 unsigned byte integers from the source operand (second operand) and from the destination operand (first operand). These 8 differences are then summed to produce an unsigned word integer result that is stored in the destination operand. Figure 4-14 shows the operation of the PSADBW instruction when using 64-bit operands.",
            "When operating on 64-bit operands, the word integer result is stored in the low word of the destination operand, and the remaining bytes in the destination operand are cleared to all 0s.",
            "When operating on 128-bit operands, two packed results are computed. Here, the 8 low-order bytes of the source and destination operands are operated on to produce a word result that is stored in the low word of the destination operand, and the 8 high-order bytes are operated on to produce a word result that is stored in bits 64 through 79 of the destination operand. The remaining bytes of the destination operand are cleared.",
            "For 256-bit version, the third group of 8 differences are summed to produce an unsigned word in bits[143:128] of the destination register and the fourth group of 8 differences are summed to produce an unsigned word in bits[207:192] of the destination register. The remaining words of the destination are set to 0.",
            "For 512-bit version, the fifth group result is stored in bits [271:256] of the destination. The result from the sixth group is stored in bits [335:320]. The results for the seventh and eighth group are stored respectively in bits [399:384] and bits [463:447], respectively. The remaining bits in the destination are set to 0.",
            "In 64-bit mode and not encoded by VEX/EVEX prefix, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The first source operand and destination register are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: The first source operand and destination register are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: The first source operand and destination register are YMM registers. The second source operand is an YMM register or a 256-bit memory location. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX.512 encoded version: The first source operand and destination register are ZMM registers. The second source operand is a ZMM register or a 512-bit memory location.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSADBW.html"
        ]
    },
    "lodsd": {
        "detail": [
            "Load String"
        ],
        "documentation": [
            "Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be overridden with a segment override prefix.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the LODS mnemonic) allows the source operand to be specified explicitly. Here, the source operand should be a symbol that indicates the size and location of the source value. The destination operand is then automatically selected to match the size of the source operand (the AL register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI registers, which must be loaded correctly before the load string instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the LODS instructions. Here also DS:(E)SI is assumed to be the source operand and the AL, AX, or EAX register is assumed to be the destination operand. The size of the source and destination operands is selected with the mnemonic: LODSB (byte loaded into register AL), LODSW (word loaded into AX), or LODSD (doubleword loaded into EAX).",
            "After the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.",
            "In 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. LODS/LODSQ load the quadword at address (R)SI into RAX. The (R)SI register is then incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.",
            "The LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because further processing of the data moved into the register is usually necessary before the next transfer can be made. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for a description of the REP prefix.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, mem.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/LODS:LODSB:LODSW:LODSD:LODSQ.html"
        ]
    },
    "vunpckhpd": {
        "detail": [
            "Unpack and Interleave High Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs an interleaved unpack of the high double-precision floating-point values from the first source operand and the second source operand. See Figure 4-15 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.",
            "EVEX.128 encoded version: The first source operand is a XMM register. The second source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/UNPCKHPD.html"
        ]
    },
    "vprord": {
        "detail": [
            "Bit Rotate Right"
        ],
        "documentation": [
            "Rotates the bits in the individual data elements (doublewords, or quadword) in the first source operand to the right by the number of bits specified in the count operand. If the value specified by the count operand is greater than 31 (for doublewords), or 63 (for a quadword), then the count operand modulo the data size (32 or 64) is used.",
            "EVEX.128 encoded version: The destination operand is a XMM register. The source operand is a XMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.",
            "EVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX.512 encoded version: The destination operand is a ZMM register updated according to the writemask. For the count operand in immediate form, the source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location, the count operand is an 8-bit immediate. For the count operand in variable form, the first source operand (the second operand) is a ZMM register and the counter operand (the third operand) is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location."
        ],
        "operands": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPRORD:VPRORVD:VPRORQ:VPRORVQ.html"
        ]
    },
    "lodsb": {
        "detail": [
            "Load String"
        ],
        "documentation": [
            "Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be overridden with a segment override prefix.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the LODS mnemonic) allows the source operand to be specified explicitly. Here, the source operand should be a symbol that indicates the size and location of the source value. The destination operand is then automatically selected to match the size of the source operand (the AL register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI registers, which must be loaded correctly before the load string instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the LODS instructions. Here also DS:(E)SI is assumed to be the source operand and the AL, AX, or EAX register is assumed to be the destination operand. The size of the source and destination operands is selected with the mnemonic: LODSB (byte loaded into register AL), LODSW (word loaded into AX), or LODSD (doubleword loaded into EAX).",
            "After the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.",
            "In 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. LODS/LODSQ load the quadword at address (R)SI into RAX. The (R)SI register is then incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.",
            "The LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because further processing of the data moved into the register is usually necessary before the next transfer can be made. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for a description of the REP prefix.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/LODS:LODSB:LODSW:LODSD:LODSQ.html"
        ]
    },
    "vpshab": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpcmpestri": {
        "detail": [
            "Packed Compare Explicit Length Strings, Return Index"
        ],
        "documentation": [
            "The instruction compares and processes data from two string fragments based on the encoded value in the Imm8 Control Byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates an index stored to the count register (ECX).",
            "Each string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). The second value is stored in an input length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length represents the number of bytes/words which are valid for the respective xmm/m128 data.",
            "The length of each input is interpreted as being the absolute-value of the value in the length register. The absolute-value computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value in the length register is greater than 16 (8) or less than -16 (-8).",
            "The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see Section 4.1). The index of the first (or last, according to imm8[6]) set bit of IntRes2 (see Section 4.1.4) is returned in ECX. If no bits are set in IntRes2, ECX is set to 16 (8).",
            "Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:",
            "CFlag – Reset if IntRes2 is equal to zero, set otherwise",
            "ZFlag – Set if absolute-value of EDX is < 16 (8), reset otherwise",
            "SFlag – Set if absolute-value of EAX is < 16 (8), reset otherwise",
            "OFlag – IntRes2[0]",
            "AFlag – Reset",
            "PFlag – Reset"
        ],
        "operands": [
            "reg.x, reg.x, imm.b, reg, reg, reg",
            "reg.x, mem.x, imm.b, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPESTRI.html"
        ]
    },
    "vpshad": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpcmpestrm": {
        "detail": [
            "Packed Compare Explicit Length Strings, Return Mask"
        ],
        "documentation": [
            "The instruction compares data from two string fragments based on the encoded value in the imm8 contol byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates a mask stored to XMM0.",
            "Each string fragment is represented by two values. The first value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). The second value is stored in an input length register. The input length register is EAX/RAX (for xmm1) or EDX/RDX (for xmm2/m128). The length represents the number of bytes/words which are valid for the respective xmm/m128 data.",
            "The length of each input is interpreted as being the absolute-value of the value in the length register. The absolute-value computation saturates to 16 (for bytes) and 8 (for words), based on the value of imm8[bit3] when the value in the length register is greater than 16 (8) or less than -16 (-8).",
            "The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see Section 4.1). As defined by imm8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.",
            "Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:",
            "CFlag – Reset if IntRes2 is equal to zero, set otherwise",
            "ZFlag – Set if absolute-value of EDX is < 16 (8), reset otherwise",
            "SFlag – Set if absolute-value of EAX is < 16 (8), reset otherwise",
            "OFlag –IntRes2[0]",
            "AFlag – Reset",
            "PFlag – Reset",
            "Note: In VEX.128 encoded versions, bits (MAXVL-1:128) of XMM0 are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.x, reg.x, imm.b, reg, reg, reg.x",
            "reg.x, mem.x, imm.b, reg, reg, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPESTRM.html"
        ]
    },
    "vprorq": {
        "detail": [
            "Bit Rotate Right"
        ],
        "documentation": [
            "Rotates the bits in the individual data elements (doublewords, or quadword) in the first source operand to the right by the number of bits specified in the count operand. If the value specified by the count operand is greater than 31 (for doublewords), or 63 (for a quadword), then the count operand modulo the data size (32 or 64) is used.",
            "EVEX.128 encoded version: The destination operand is a XMM register. The source operand is a XMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.",
            "EVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX.512 encoded version: The destination operand is a ZMM register updated according to the writemask. For the count operand in immediate form, the source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location, the count operand is an 8-bit immediate. For the count operand in variable form, the first source operand (the second operand) is a ZMM register and the counter operand (the third operand) is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location."
        ],
        "operands": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPRORD:VPRORVD:VPRORQ:VPRORVQ.html"
        ]
    },
    "serialize": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "vshufps": {
        "detail": [
            "Packed Interleave Shuffle of Quadruplets of Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Selects a single-precision floating-point value of an input quadruplet using a two-bit control and move to a designated element of the destination operand. Each 64-bit element-pair of a 128-bit lane of the destination operand is interleaved between the corresponding lane of the first source operand and the second source operand at the granularity 128 bits. Each two bits in the imm8 byte, starting from bit 0, is the select control of the corresponding element of a 128-bit lane of the destination to received the shuffled result of an input quadruplet. The two lower elements of a 128-bit lane in the destination receives shuffle results from the quadruple of the first source operand. The next two elements of the destination receives shuffle results from the quadruple of the second source operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask. Imm8[7:0] provides 4 select controls for each applicable 128-bit lane of the destination.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Imm8[7:0] provides 4 select controls for the high and low 128-bit of the destination.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed. Imm8[7:0] provides 4 select controls for each element of the destination.",
            "128-bit Legacy SSE version: The source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. Imm8[7:0] provides 4 select controls for each element of the destination."
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SHUFPS.html"
        ]
    },
    "vunpckhps": {
        "detail": [
            "Unpack and Interleave High Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs an interleaved unpack of the high single-precision floating-point values from the first source operand and the second source operand.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "VEX.256 encoded version: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/UNPCKHPS.html"
        ]
    },
    "vpinsrb": {
        "detail": [
            "Insert Byte/Dword/Qword"
        ],
        "documentation": [
            "Copies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other elements in the destination register are left untouched.) The source operand can be a general-purpose register or a memory location. (When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destination operand is an XMM register. The count operand is an 8-bit immediate. When specifying a qword[dword, byte] location in an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose registers.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. VEX.L must be 0, otherwise the instruction will #UD. Attempt to execute VPINSRQ in non-64-bit mode will cause #UD.",
            "EVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. EVEX.L’L must be 0, otherwise the instruction will #UD.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, mem.b, imm.b",
            "reg.x, reg.x, reg.d, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PINSRB:PINSRD:PINSRQ.html"
        ]
    },
    "vfmadd213pd": {
        "detail": [
            "Fused Multiply-Add of Packed Double- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a set of SIMD multiply-add computation on packed double-precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.",
            "VFMADD132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source operand to the two, four or eight packed double-precision floating-point values in the third source operand, adds the infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMADD213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source operand to the two, four or eight packed double-precision floating-point values in the first source operand, adds the infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMADD231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source to the two, four or eight packed double-precision floating-point values in the third source operand, adds the infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) is a ZMM register and encoded in reg_field. The second source operand is a ZMM register and encoded in EVEX.vvvv. The third source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADD132PD:VFMADD213PD:VFMADD231PD.html"
        ]
    },
    "vpinsrd": {
        "detail": [
            "Insert Byte/Dword/Qword"
        ],
        "documentation": [
            "Copies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other elements in the destination register are left untouched.) The source operand can be a general-purpose register or a memory location. (When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destination operand is an XMM register. The count operand is an 8-bit immediate. When specifying a qword[dword, byte] location in an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose registers.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. VEX.L must be 0, otherwise the instruction will #UD. Attempt to execute VPINSRQ in non-64-bit mode will cause #UD.",
            "EVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. EVEX.L’L must be 0, otherwise the instruction will #UD.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.d, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PINSRB:PINSRD:PINSRQ.html"
        ]
    },
    "jnle": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "lodsw": {
        "detail": [
            "Load String"
        ],
        "documentation": [
            "Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be overridden with a segment override prefix.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the LODS mnemonic) allows the source operand to be specified explicitly. Here, the source operand should be a symbol that indicates the size and location of the source value. The destination operand is then automatically selected to match the size of the source operand (the AL register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI registers, which must be loaded correctly before the load string instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the LODS instructions. Here also DS:(E)SI is assumed to be the source operand and the AL, AX, or EAX register is assumed to be the destination operand. The size of the source and destination operands is selected with the mnemonic: LODSB (byte loaded into register AL), LODSW (word loaded into AX), or LODSD (doubleword loaded into EAX).",
            "After the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.",
            "In 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. LODS/LODSQ load the quadword at address (R)SI into RAX. The (R)SI register is then incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.",
            "The LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because further processing of the data moved into the register is usually necessary before the next transfer can be made. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for a description of the REP prefix.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/LODS:LODSB:LODSW:LODSD:LODSQ.html"
        ]
    },
    "lodsq": {
        "detail": [
            "Load String"
        ],
        "documentation": [
            "Loads a byte, word, or doubleword from the source operand into the AL, AX, or EAX register, respectively. The source operand is a memory location, the address of which is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The DS segment may be overridden with a segment override prefix.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the LODS mnemonic) allows the source operand to be specified explicitly. Here, the source operand should be a symbol that indicates the size and location of the source value. The destination operand is then automatically selected to match the size of the source operand (the AL register for byte operands, AX for word operands, and EAX for doubleword operands). This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI registers, which must be loaded correctly before the load string instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the LODS instructions. Here also DS:(E)SI is assumed to be the source operand and the AL, AX, or EAX register is assumed to be the destination operand. The size of the source and destination operands is selected with the mnemonic: LODSB (byte loaded into register AL), LODSW (word loaded into AX), or LODSD (doubleword loaded into EAX).",
            "After the byte, word, or doubleword is transferred from the memory location into the AL, AX, or EAX register, the (E)SI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the ESI register is decremented.) The (E)SI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.",
            "In 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. LODS/LODSQ load the quadword at address (R)SI into RAX. The (R)SI register is then incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register.",
            "The LODS, LODSB, LODSW, and LODSD instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because further processing of the data moved into the register is usually necessary before the next transfer can be made. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for a description of the REP prefix.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/LODS:LODSB:LODSW:LODSD:LODSQ.html"
        ]
    },
    "vpshaq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vcvtsd2si": {
        "detail": [
            "Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer"
        ],
        "documentation": [
            "Converts a double-precision floating-point value in the source operand (the second operand) to a signed double-word integer in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.",
            "If a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode with REX.W/VEX.W/EVEX.W=0), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.",
            "If a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and REX.W/VEX.W/EVEX.W = 1), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000_00000000H) is returned.",
            "Legacy SSE instruction: Use of the REX.W prefix promotes the instruction to produce 64-bit data in 64-bit mode. See the summary chart at the beginning of this section for encoding data and limits.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCVTSD2SI is encoded with VEX.L=0. Encoding VCVTSD2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.q",
            "reg.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTSD2SI.html"
        ]
    },
    "pmulhrsw": {
        "detail": [
            "Packed Multiply High with Round and Scale"
        ],
        "documentation": [
            "PMULHRSW multiplies vertically each signed 16-bit integer from the destination operand (first operand) with the corresponding signed 16-bit integer of the source operand (second operand), producing intermediate, signed 32-bit integers. Each intermediate 32-bit integer is truncated to the 18 most significant bits. Rounding is always performed by adding 1 to the least significant bit of the 18-bit intermediate result. The final result is obtained by selecting the 16 bits immediately to the right of the most significant bit of each 18-bit intermediate result and packed to the destination operand.",
            "When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "In 64-bit mode and not encoded with VEX/EVEX, use the REX prefix to access XMM8-XMM15 registers.",
            "Legacy SSE version 64-bit operand: Both operands can be MMX registers. The second source operand is an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMULHRSW.html"
        ]
    },
    "movddup": {
        "detail": [
            "Replicate Double FP Values"
        ],
        "documentation": [
            "For 256-bit or higher versions: Duplicates even-indexed double-precision floating-point values from the source operand (the second operand) and into adjacent pair and store to the destination operand (the first operand).",
            "For 128-bit versions: Duplicates the low double-precision floating-point value from the source operand (the second operand) and store to the destination operand (the first operand).",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register are unchanged. The source operand is XMM register or a 64-bit memory location.",
            "VEX.128 and EVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. The source operand is XMM register or a 64-bit memory location. The destination is updated conditionally under the writemask for EVEX version.",
            "VEX.256 and EVEX.256 encoded version: Bits (MAXVL-1:256) of the destination register are zeroed. The source operand is YMM register or a 256-bit memory location. The destination is updated conditionally under the writemask for EVEX version.",
            "EVEX.512 encoded version: The destination is updated according to the writemask. The source operand is ZMM register or a 512-bit memory location.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVDDUP.html"
        ]
    },
    "vpshaw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpinsrq": {
        "detail": [
            "Insert Byte/Dword/Qword"
        ],
        "documentation": [
            "Copies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other elements in the destination register are left untouched.) The source operand can be a general-purpose register or a memory location. (When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destination operand is an XMM register. The count operand is an 8-bit immediate. When specifying a qword[dword, byte] location in an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose registers.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. VEX.L must be 0, otherwise the instruction will #UD. Attempt to execute VPINSRQ in non-64-bit mode will cause #UD.",
            "EVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. EVEX.L’L must be 0, otherwise the instruction will #UD.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PINSRB:PINSRD:PINSRQ.html"
        ]
    },
    "vfmadd213ps": {
        "detail": [
            "Fused Multiply-Add of Packed Single- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a set of SIMD multiply-add computation on packed single-precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.",
            "VFMADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the first source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting the four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) is a ZMM register and encoded in reg_field. The second source operand is a ZMM register and encoded in EVEX.vvvv. The third source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADD132PS:VFMADD213PS:VFMADD231PS.html"
        ]
    },
    "vcvtsd2ss": {
        "detail": [
            "Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Converts a double-precision floating-point value in the “convert-from” source operand (the second operand in SSE2 version, otherwise the third operand) to a single-precision floating-point value in the destination operand.",
            "When the “convert-from” operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register. The result is stored in the low doubleword of the destination operand. When the conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.",
            "128-bit Legacy SSE version: The “convert-from” source operand (the second operand) is an XMM register or memory location. Bits (MAXVL-1:32) of the corresponding destination register remain unchanged. The destination operand is an XMM register.",
            "VEX.128 and EVEX encoded versions: The “convert-from” source operand (the third operand) can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers. Bits (127:32) of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: the converted result in written to the low doubleword element of the destination under the writemask.",
            "Software should ensure VCVTSD2SS is encoded with VEX.L=0. Encoding VCVTSD2SS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTSD2SS.html"
        ]
    },
    "xsavec64": {
        "detail": [
            "Save Processor Extended States with Compaction"
        ],
        "documentation": [
            "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.",
            "The format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Section 13.10, “Operation of XSAVEC,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XSAVEC instruction. The following items provide a highlevel outline:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.z[4096], reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XSAVEC.html"
        ]
    },
    "vpinsrw": {
        "detail": [
            "Insert Word"
        ],
        "documentation": [
            "Copies a word from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other words in the destination register are left untouched.) The source operand can be a general-purpose register or a 16-bit memory location. (When the source operand is a general-purpose register, the low word of the register is copied.) The destination operand can be an MMX technology register or an XMM register. The count operand is an 8-bit immediate. When specifying a word location in an MMX technology register, the 2 least-significant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the location.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15).",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.",
            "EVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. EVEX.L’L must be 0, otherwise the instruction will #UD.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, mem.w, imm.b",
            "reg.x, reg.x, reg.d, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PINSRW.html"
        ]
    },
    "vpmaxsb": {
        "detail": [
            "Maximum of Packed Signed Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.",
            "EVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html"
        ]
    },
    "vpmaxsd": {
        "detail": [
            "Maximum of Packed Signed Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.",
            "EVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html"
        ]
    },
    "pfcmpeq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vcvttpd2qq": {
        "detail": [
            "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Quadword Integers"
        ],
        "documentation": [
            "Converts with truncation packed double-precision floating-point values in the source operand (second operand) to packed quadword integers in the destination operand (first operand).",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.",
            "Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTTPD2QQ.html"
        ]
    },
    "vpmaskmovd": {
        "detail": [
            "Conditional SIMD Integer Packed Loads and Stores"
        ],
        "documentation": [
            "Conditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are specified in the first source operand.",
            "The mask bit for each data element is the most significant bit of that element in the first source operand. If a mask is 1, the corresponding data element is copied from the second source operand to the destination operand. If the mask is 0, the corresponding data element is set to zero in the load form of these instructions, and unmodified in the store form.",
            "The second source operand is a memory address for the load form of these instructions. The destination operand is a memory address for the store form of these instructions. The other operands are either XMM registers (for VEX.128 version) or YMM registers (for VEX.256 version).",
            "Faults occur only due to mask-bit required memory accesses that caused the faults. Faults will not occur due to referencing any memory location if the corresponding mask bit for that memory location is 0. For example, no faults will be detected if the mask bits are all zero.",
            "Unlike previous MASKMOV instructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to these instructions.",
            "Instruction behavior on alignment check reporting with mask bits of less than all 1s are the same as with mask bits of all 1s.",
            "VMASKMOV should not be used to access memory mapped I/O as the ordering of the individual loads or stores it does is implementation specific.",
            "In cases where mask bits indicate data should not be loaded or stored paging A and D bits will be set in an implementation dependent way. However, A and D bits are always set for pages where data is actually loaded/stored.",
            "Note: for load forms, the first source (the mask) is encoded in VEX.vvvv; the second source is encoded in rm_field, and the destination register is encoded in reg_field.",
            "Note: for store forms, the first source (the mask) is encoded in VEX.vvvv; the second source register is encoded in reg_field, and the destination memory location is encoded in rm_field."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "mem.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMASKMOV.html"
        ]
    },
    "pmovsxdq": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "documentation": [
            "Legacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVSX.html"
        ]
    },
    "vpackssdw": {
        "detail": [
            "Pack with Signed Saturation"
        ],
        "documentation": [
            "Converts packed signed word integers into packed signed byte integers (PACKSSWB) or converts packed signed doubleword integers into packed signed word integers (PACKSSDW), using saturation to handle overflow conditions. See Figure 4-6 for an example of the packing operation."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PACKSSWB:PACKSSDW.html"
        ]
    },
    "vpmaxsq": {
        "detail": [
            "Maximum of Packed Signed Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.",
            "EVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html"
        ]
    },
    "vpmaddubsw": {
        "detail": [
            "Multiply and Add Packed Signed and Unsigned Bytes"
        ],
        "documentation": [
            "(V)PMADDUBSW multiplies vertically each unsigned byte of the destination operand (first operand) with the corresponding signed byte of the source operand (second operand), producing intermediate signed 16-bit integers. Each adjacent pair of signed words is added and the saturated result is packed to the destination operand. For example, the lowest-order bytes (bits 7-0) in the source and destination operands are multiplied and the intermediate signed word result is added with the corresponding intermediate result from the 2nd lowest-order bytes (bits 15-8) of the operands; the sign-saturated result is stored in the lowest word of the destination register (15-0). The same operation is performed on the other pairs of adjacent bytes. Both operands can be MMX register or XMM registers. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "In 64-bit mode and not encoded with VEX/EVEX, use the REX prefix to access XMM8-XMM15.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX.512 encoded version: The second source operand can be an ZMM register or a 512-bit memory location. The first source and destination operands are ZMM registers."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMADDUBSW.html"
        ]
    },
    "vpmaskmovq": {
        "detail": [
            "Conditional SIMD Integer Packed Loads and Stores"
        ],
        "documentation": [
            "Conditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are specified in the first source operand.",
            "The mask bit for each data element is the most significant bit of that element in the first source operand. If a mask is 1, the corresponding data element is copied from the second source operand to the destination operand. If the mask is 0, the corresponding data element is set to zero in the load form of these instructions, and unmodified in the store form.",
            "The second source operand is a memory address for the load form of these instructions. The destination operand is a memory address for the store form of these instructions. The other operands are either XMM registers (for VEX.128 version) or YMM registers (for VEX.256 version).",
            "Faults occur only due to mask-bit required memory accesses that caused the faults. Faults will not occur due to referencing any memory location if the corresponding mask bit for that memory location is 0. For example, no faults will be detected if the mask bits are all zero.",
            "Unlike previous MASKMOV instructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to these instructions.",
            "Instruction behavior on alignment check reporting with mask bits of less than all 1s are the same as with mask bits of all 1s.",
            "VMASKMOV should not be used to access memory mapped I/O as the ordering of the individual loads or stores it does is implementation specific.",
            "In cases where mask bits indicate data should not be loaded or stored paging A and D bits will be set in an implementation dependent way. However, A and D bits are always set for pages where data is actually loaded/stored.",
            "Note: for load forms, the first source (the mask) is encoded in VEX.vvvv; the second source is encoded in rm_field, and the destination register is encoded in reg_field.",
            "Note: for store forms, the first source (the mask) is encoded in VEX.vvvv; the second source register is encoded in reg_field, and the destination memory location is encoded in rm_field."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "mem.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMASKMOV.html"
        ]
    },
    "vpmaxsw": {
        "detail": [
            "Maximum of Packed Signed Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.",
            "EVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html"
        ]
    },
    "vbroadcasti32x2": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "documentation": [
            "VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).",
            "VEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4 load floating-point values as tuples from the source operand (the second operand) in memory or register and broadcast to all elements of the destination operand (the first operand). The destination operand is a YMM/ZMM register updated according to the writemask k1. The source operand is either a register or 64-bit/128-bit/256-bit memory location.",
            "VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as 256-bit and 512-bit wide versions and up. VBROADCASTSS is supported in 128-bit, 256-bit and 512-bit wide versions. F32x8 and F64x4 are only supported as 512-bit wide versions.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32-bit granularity. VBROADCASTF64X2 and VBROADCASTF64X4 have 64-bit granularity.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.q",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBROADCAST.html"
        ]
    },
    "fxsave64": {
        "detail": [
            "Save x87 FPU, MMX Technology, and SSE State"
        ],
        "documentation": [
            "Saves the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory location specified in the destination operand. The content layout of the 512 byte region depends on whether the processor is operating in non-64-bit operating modes or 64-bit sub-mode of IA-32e mode.",
            "Bytes 464:511 are available to software use. The processor does not write to bytes 464:511 of an FXSAVE area.",
            "The operation of FXSAVE in non-64-bit modes is described first."
        ],
        "operands": [
            "mem.[4096], reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FXSAVE.html"
        ]
    },
    "vbroadcasti32x4": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "documentation": [
            "VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).",
            "VEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4 load floating-point values as tuples from the source operand (the second operand) in memory or register and broadcast to all elements of the destination operand (the first operand). The destination operand is a YMM/ZMM register updated according to the writemask k1. The source operand is either a register or 64-bit/128-bit/256-bit memory location.",
            "VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as 256-bit and 512-bit wide versions and up. VBROADCASTSS is supported in 128-bit, 256-bit and 512-bit wide versions. F32x8 and F64x4 are only supported as 512-bit wide versions.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32-bit granularity. VBROADCASTF64X2 and VBROADCASTF64X4 have 64-bit granularity.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.z, mem.x",
            "reg.z, reg.q, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBROADCAST.html"
        ]
    },
    "vbroadcasti32x8": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "documentation": [
            "VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).",
            "VEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4 load floating-point values as tuples from the source operand (the second operand) in memory or register and broadcast to all elements of the destination operand (the first operand). The destination operand is a YMM/ZMM register updated according to the writemask k1. The source operand is either a register or 64-bit/128-bit/256-bit memory location.",
            "VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as 256-bit and 512-bit wide versions and up. VBROADCASTSS is supported in 128-bit, 256-bit and 512-bit wide versions. F32x8 and F64x4 are only supported as 512-bit wide versions.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32-bit granularity. VBROADCASTF64X2 and VBROADCASTF64X4 have 64-bit granularity.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.z, mem.y",
            "reg.z, reg.q, mem.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBROADCAST.html"
        ]
    },
    "vaeskeygenassist": {
        "detail": [
            "AES Round Key Generation Assist"
        ],
        "documentation": [
            "Assist in expanding the AES cipher key, by computing steps towards generating a round key for encryption, using 128-bit data specified in the source operand and an 8-bit round constant specified as an immediate, store the result in the destination operand.",
            "The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/AESKEYGENASSIST.html"
        ]
    },
    "wrgsbase": {
        "detail": [
            "Write FS/GS Segment Base"
        ],
        "documentation": [
            "Loads the FS or GS segment base address with the general-purpose register indicated by the modR/M:r/m field.",
            "The source operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source register are ignored and upper 32 bits of the base address (for FS or GS) are cleared.",
            "This instruction is supported only in 64-bit mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/WRFSBASE:WRGSBASE.html"
        ]
    },
    "vmovlhps": {
        "detail": [
            "Move Packed Single-Precision Floating-Point Values Low to High"
        ],
        "documentation": [
            "This instruction cannot be used for memory to register moves.",
            "128-bit two-argument form:",
            "Moves two packed single-precision floating-point values from the low quadword of the second XMM argument (second operand) to the high quadword of the first XMM register (first argument). The low quadword of the destination operand is left unchanged. Bits (MAXVL-1:128) of the corresponding destination register are unmodified.",
            "128-bit three-argument forms:",
            "Moves two packed single-precision floating-point values from the low quadword of the third XMM argument (third operand) to the high quadword of the destination (first operand). Copies the low quadword from the second XMM argument (second operand) to the low quadword of the destination (first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "If VMOVLHPS is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.x, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVLHPS.html"
        ]
    },
    "clrssbsy": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vcompresspd": {
        "detail": [
            "Store Sparse Packed Double-Precision Floating-Point Values into Dense Memory"
        ],
        "documentation": [
            "Compress (store) up to 8 double-precision floating-point values from the source operand (the second operand) as a contiguous vector to the destination operand (the first operand) The source operand is a ZMM/YMM/XMM register, the destination operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.",
            "The opmask register k1 selects the active elements (partial vector or possibly non-contiguous if less than 8 active elements) from the source operand to compress into a contiguous vector. The contiguous vector is written to the destination starting from the low element of the destination operand.",
            "Memory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z must be zero.",
            "Register destination version: If the vector length of the contiguous vector is less than that of the input vector in the source operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper bits are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector."
        ],
        "operands": [
            "reg.z, reg.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCOMPRESSPD.html"
        ]
    },
    "vpandd": {
        "detail": [
            "Logical AND"
        ],
        "documentation": [
            "Performs a bitwise logical AND operation on the first source operand and second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bits of the first and second operands are 1, otherwise it is set to 0.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 32/64-bit granularity.",
            "VEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/PAND.html"
        ]
    },
    "pxor": {
        "detail": [
            "Logical Exclusive OR"
        ],
        "documentation": [
            "Performs a bitwise logical exclusive-OR (XOR) operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is 1 if the corresponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding register destination are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PXOR.html"
        ]
    },
    "vpandn": {
        "detail": [
            "Logical AND NOT"
        ],
        "documentation": [
            "Performs a bitwise logical NOT operation on the first source operand, then performs bitwise AND with second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bit in the first operand is 0 and the corresponding bit in the second operand is 1, otherwise it is set to 0.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 32/64-bit granularity.",
            "VEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PANDN.html"
        ]
    },
    "vcompressps": {
        "detail": [
            "Store Sparse Packed Single-Precision Floating-Point Values into Dense Memory"
        ],
        "documentation": [
            "Compress (stores) up to 16 single-precision floating-point values from the source operand (the second operand) to the destination operand (the first operand). The source operand is a ZMM/YMM/XMM register, the destination operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.",
            "The opmask register k1 selects the active elements (a partial vector or possibly non-contiguous if less than 16 active elements) from the source operand to compress into a contiguous vector. The contiguous vector is written to the destination starting from the low element of the destination operand.",
            "Memory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z must be zero.",
            "Register destination version: If the vector length of the contiguous vector is less than that of the input vector in the source operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper bits are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector."
        ],
        "operands": [
            "reg.z, reg.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCOMPRESSPS.html"
        ]
    },
    "vpandq": {
        "detail": [
            "Logical AND"
        ],
        "documentation": [
            "Performs a bitwise logical AND operation on the first source operand and second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bits of the first and second operands are 1, otherwise it is set to 0.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 32/64-bit granularity.",
            "VEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/PAND.html"
        ]
    },
    "unpckhpd": {
        "detail": [
            "Unpack and Interleave High Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs an interleaved unpack of the high double-precision floating-point values from the first source operand and the second source operand. See Figure 4-15 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.",
            "EVEX.128 encoded version: The first source operand is a XMM register. The second source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/UNPCKHPD.html"
        ]
    },
    "repne cmpsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.b, mem.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "repne cmpsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.d, mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vdpbf16ps": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vprotb": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vprotd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "repne scasb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "repne scasd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "unpckhps": {
        "detail": [
            "Unpack and Interleave High Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs an interleaved unpack of the high single-precision floating-point values from the first source operand and the second source operand.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. When unpacking from a memory operand, an implementation may fetch only the appropriate 64 bits; however, alignment to 16-byte boundary and normal segment checking will still be enforced.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "VEX.256 encoded version: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/UNPCKHPS.html"
        ]
    },
    "repne cmpsq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.q, mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vpunpckhqdq": {
        "detail": [
            "Unpack High Data"
        ],
        "documentation": [
            "Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. Figure 4-20 shows the unpack operation for bytes in 64-bit operands. The low-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html"
        ]
    },
    "repne cmpsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.w, mem.w, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "roundsd": {
        "detail": [
            "Round Scalar Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Round the DP FP value in the lower qword of the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the result in the destination operand (first operand). The rounding process rounds a double-precision floating-point input to an integer value and returns the integer result as a double precision floating-point value in the lowest position. The upper double precision floating-point value in the destination is retained.",
            "The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-17 lists the encoded values for rounding-mode field).",
            "The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:64) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.q, reg.q, imm.b",
            "reg.q, mem.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/ROUNDSD.html"
        ]
    },
    "vphsubsw": {
        "detail": [
            "Packed Horizontal Subtract and Saturate"
        ],
        "documentation": [
            "(V)PHSUBSW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands. The signed, saturated 16-bit results are packed to the destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "In 64-bit mode, use the REX prefix to access additional registers.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.",
            "Note: VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PHSUBSW.html"
        ]
    },
    "cvtsd2si": {
        "detail": [
            "Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer"
        ],
        "documentation": [
            "Converts a double-precision floating-point value in the source operand (the second operand) to a signed double-word integer in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.",
            "If a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode with REX.W/VEX.W/EVEX.W=0), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.",
            "If a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and REX.W/VEX.W/EVEX.W = 1), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000_00000000H) is returned.",
            "Legacy SSE instruction: Use of the REX.W prefix promotes the instruction to produce 64-bit data in 64-bit mode. See the summary chart at the beginning of this section for encoding data and limits.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCVTSD2SI is encoded with VEX.L=0. Encoding VCVTSD2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.q",
            "reg.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTSD2SI.html"
        ]
    },
    "vphaddbd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "repne scasq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vprotq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vprotw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpaddusb": {
        "detail": [
            "Add Packed Unsigned Integers with Unsigned Saturation"
        ],
        "documentation": [
            "Performs a SIMD add of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs.",
            "(V)PADDUSB performs a SIMD add of the packed unsigned integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual byte result is beyond the range of an unsigned byte integer (that is, greater than FFH), the saturated value of FFH is written to the destination operand.",
            "(V)PADDUSW performs a SIMD add of the packed unsigned word integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual word result is beyond the range of an unsigned word integer (that is, greater than FFFFH), the saturated value of FFFFH is written to the destination operand.",
            "EVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination is an ZMM/YMM/XMM register.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding destination register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDUSB:PADDUSW.html"
        ]
    },
    "repne scasw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.w, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "cvtsd2ss": {
        "detail": [
            "Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Converts a double-precision floating-point value in the “convert-from” source operand (the second operand in SSE2 version, otherwise the third operand) to a single-precision floating-point value in the destination operand.",
            "When the “convert-from” operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register. The result is stored in the low doubleword of the destination operand. When the conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.",
            "128-bit Legacy SSE version: The “convert-from” source operand (the second operand) is an XMM register or memory location. Bits (MAXVL-1:32) of the corresponding destination register remain unchanged. The destination operand is an XMM register.",
            "VEX.128 and EVEX encoded versions: The “convert-from” source operand (the third operand) can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers. Bits (127:32) of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: the converted result in written to the low doubleword element of the destination under the writemask.",
            "Software should ensure VCVTSD2SS is encoded with VEX.L=0. Encoding VCVTSD2SS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.q",
            "reg.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTSD2SS.html"
        ]
    },
    "vphaddbq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "pfcmpge": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "lfence": {
        "detail": [
            "Load Fence"
        ],
        "documentation": [
            "Performs a serializing operation on all load-from-memory instructions that were issued prior the LFENCE instruction. Specifically, LFENCE does not execute until all prior instructions have completed locally, and no later instruction begins execution until LFENCE completes. In particular, an instruction that loads from memory and that precedes an LFENCE receives data from memory prior to completion of the LFENCE. (An LFENCE that follows an instruction that stores to memory might complete before the data being stored have become globally visible.) Instructions following an LFENCE may be fetched from memory before the LFENCE, but they will not execute (even speculatively) until the LFENCE completes.",
            "Weakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue and speculative reads. The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data. The LFENCE instruction provides a performance-efficient way of ensuring load ordering between routines that produce weakly-ordered results and routines that consume that data.",
            "Processors are free to fetch and cache data speculatively from regions of system memory that use the WB, WC, and WT memory types. This speculative fetching can occur at any time and is not tied to instruction execution. Thus, it is not ordered with respect to executions of the LFENCE instruction; data can be brought into the caches speculatively just before, during, or after the execution of an LFENCE instruction.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
            "Specification of the instruction's opcode above indicates a ModR/M byte of E8. For this instruction, the processor ignores the r/m field of the ModR/M byte. Thus, LFENCE is encoded by any opcode of the form 0F AE Ex, where x is in the range 8-F."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/LFENCE.html"
        ]
    },
    "roundss": {
        "detail": [
            "Round Scalar Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Round the single-precision floating-point value in the lowest dword of the source operand (second operand) using the rounding mode specified in the immediate operand (third operand) and place the result in the destination operand (first operand). The rounding process rounds a single-precision floating-point input to an integer value and returns the result as a single-precision floating-point value in the lowest position. The upper three single-precision floating-point values in the destination are retained.",
            "The immediate operand specifies control fields for the rounding operation, three bit fields are defined and shown in Figure 4-24. Bit 3 of the immediate byte controls processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Table 4-17 lists the encoded values for rounding-mode field).",
            "The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.d, reg.d, imm.b",
            "reg.d, mem.d, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/ROUNDSS.html"
        ]
    },
    "vphaddbw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "packssdw": {
        "detail": [
            "Pack with Signed Saturation"
        ],
        "documentation": [
            "Converts packed signed word integers into packed signed byte integers (PACKSSWB) or converts packed signed doubleword integers into packed signed word integers (PACKSSDW), using saturation to handle overflow conditions. See Figure 4-6 for an example of the packing operation."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PACKSSWB:PACKSSDW.html"
        ]
    },
    "vpmaxub": {
        "detail": [
            "Maximum of Packed Unsigned Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed unsigned byte, word integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMAXUB: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMAXUB:PMAXUW.html"
        ]
    },
    "vpmaxud": {
        "detail": [
            "Maximum of Packed Unsigned Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed unsigned dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMAXUD:PMAXUQ.html"
        ]
    },
    "lldt": {
        "detail": [
            "Load Local Descriptor Table Register"
        ],
        "documentation": [
            "Loads the source operand into the segment selector field of the local descriptor table register (LDTR). The source operand (a general-purpose register or a memory location) contains a segment selector that points to a local descriptor table (LDT). After the segment selector is loaded in the LDTR, the processor uses the segment selector to locate the segment descriptor for the LDT in the global descriptor table (GDT). It then loads the segment limit and base address for the LDT from the segment descriptor into the LDTR. The segment registers DS, ES, SS, FS, GS, and CS are not affected by this instruction, nor is the LDTR field in the task state segment (TSS) for the current task.",
            "If bits 2-15 of the source operand are 0, LDTR is marked invalid and the LLDT instruction completes silently. However, all subsequent references to descriptors in the LDT (except by the LAR, VERR, VERW or LSL instructions) cause a general protection exception (#GP).",
            "The operand-size attribute has no effect on this instruction.",
            "The LLDT instruction is provided for use in operating-system software; it should not be used in application programs. This instruction can only be executed in protected mode or 64-bit mode.",
            "In 64-bit mode, the operand size is fixed at 16 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.w, reg",
            "mem.w, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/LLDT.html"
        ]
    },
    "vpaddusw": {
        "detail": [
            "Add Packed Unsigned Integers with Unsigned Saturation"
        ],
        "documentation": [
            "Performs a SIMD add of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs.",
            "(V)PADDUSB performs a SIMD add of the packed unsigned integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual byte result is beyond the range of an unsigned byte integer (that is, greater than FFH), the saturated value of FFH is written to the destination operand.",
            "(V)PADDUSW performs a SIMD add of the packed unsigned word integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual word result is beyond the range of an unsigned word integer (that is, greater than FFFFH), the saturated value of FFFFH is written to the destination operand.",
            "EVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination is an ZMM/YMM/XMM register.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding destination register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDUSB:PADDUSW.html"
        ]
    },
    "pfcmpgt": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vpshufbitqmb": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.q, reg.x, mem.x",
            "reg.q, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpmaxuq": {
        "detail": [
            "Maximum of Packed Unsigned Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed unsigned dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMAXUD:PMAXUQ.html"
        ]
    },
    "xsaveopt": {
        "detail": [
            "Save Processor Extended States Optimized"
        ],
        "documentation": [
            "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.",
            "The format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Section 13.9, “Operation of XSAVEOPT,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XSAVEOPT instruction. The following items provide a high-level outline:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.z[4096], reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XSAVEOPT.html"
        ]
    },
    "vpmaxuw": {
        "detail": [
            "Maximum of Packed Unsigned Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed unsigned byte, word integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMAXUB: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMAXUB:PMAXUW.html"
        ]
    },
    "vgatherdpd": {
        "detail": [
            "Gather Packed Single, Packed Double with Signed Dword"
        ],
        "documentation": [
            "A set of single-precision/double-precision faulting-point memory locations pointed by base address BASE_ADDR and index vector V_INDEX with scale SCALE are gathered. The result is written into a vector register. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be loaded if their corresponding mask bit is one. If an element’s mask bit is not set, the corresponding element of the destination register is left unchanged. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the right most one with its mask bit set). When this happens, the destination register and the mask register (k1) are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "If the data element size is less than the index element size, the higher part of the destination register and the mask register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may update these unused elements to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.",
            "Note that:"
        ],
        "operands": [
            "reg.z, reg.q, mem.q",
            "reg.y, mem.q, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGATHERDPS:VGATHERDPD.html"
        ]
    },
    "vshufi32x4": {
        "detail": [
            "Shuffle Packed Values at 128-bit Granularity"
        ],
        "documentation": [
            "256-bit Version: Moves one of the two 128-bit packed single-precision floating-point values from the first source operand (second operand) into the low 128-bit of the destination operand (first operand); moves one of the two packed 128-bit floating-point values from the second source operand (third operand) into the high 128-bit of the destination operand. The selector operand (third operand) determines which values are moved to the destination operand.",
            "512-bit Version: Moves two of the four 128-bit packed single-precision floating-point values from the first source operand (second operand) into the low 256-bit of each double qword of the destination operand (first operand); moves two of the four packed 128-bit floating-point values from the second source operand (third operand) into the high 256-bit of the destination operand. The selector operand (third operand) determines which values are moved to the destination operand.",
            "The first source operand is a vector register. The second source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a vector register.",
            "The writemask updates the destination operand with the granularity of 32/64-bit data elements."
        ],
        "operands": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSHUFF32x4:VSHUFF64x2:VSHUFI32x4:VSHUFI64x2.html"
        ]
    },
    "vpslld": {
        "detail": [
            "Shift Packed Data Left Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-17 gives an example of shifting words in a 64-bit operand.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.z, reg.q, reg.z, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html"
        ]
    },
    "cmppd": {
        "detail": [
            "Compare Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed double-precision floating-point values in the second source operand and the first source operand and returns the results of the comparison to the destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands.",
            "EVEX encoded versions: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is an opmask register. Comparison results are written to the destination operand under the writemask k2. Each comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false).",
            "VEX.256 encoded version: The first source operand (second operand) is a YMM register. The second source operand (third operand) can be a YMM register or a 256-bit memory location. The destination operand (first operand) is a YMM register. Four comparisons are performed with results written to the destination operand. The result of each comparison is a quadword mask of all 1s (comparison true) or all 0s (comparison false).",
            "128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged. Two comparisons are performed with results written to bits 127:0 of the destination operand. The result of each comparison is a quadword mask of all 1s (comparison true) or all 0s (comparison false).",
            "VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. Two comparisons are performed with results written to bits 127:0 of the destination operand.",
            "The comparison predicate operand is an 8-bit immediate:"
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPPD.html"
        ]
    },
    "enqcmd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, mem.z"
        ],
        "url": [
            "https://"
        ]
    },
    "lock xadd": {
        "detail": [
            "Exchange and Add"
        ],
        "documentation": [
            "Exchanges the first operand (destination operand) with the second operand (source operand), then loads the sum of the two values into the destination operand. The destination operand can be a register or a memory location; the source operand is a register.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "Flags Affected:",
            "The CF, PF, AF, SF, ZF, and OF flags are set according to the result of the addition, which is stored in the destination operand."
        ],
        "operands": [
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/XADD.html"
        ]
    },
    "vgatherdps": {
        "detail": [
            "Gather Packed Single, Packed Double with Signed Dword"
        ],
        "documentation": [
            "A set of single-precision/double-precision faulting-point memory locations pointed by base address BASE_ADDR and index vector V_INDEX with scale SCALE are gathered. The result is written into a vector register. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be loaded if their corresponding mask bit is one. If an element’s mask bit is not set, the corresponding element of the destination register is left unchanged. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the right most one with its mask bit set). When this happens, the destination register and the mask register (k1) are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "If the data element size is less than the index element size, the higher part of the destination register and the mask register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may update these unused elements to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.",
            "Note that:"
        ],
        "operands": [
            "reg.z, reg.q, mem.d",
            "reg.y, mem.d, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGATHERDPS:VGATHERDPD.html"
        ]
    },
    "vfmadd213sd": {
        "detail": [
            "Fused Multiply-Add of Scalar Double- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD multiply-add computation on the low double-precision floating-point values using three source operands and writes the multiply-add result in the destination operand. The destination operand is also the first source operand. The first and second operand are XMM registers. The third source operand can be an XMM register or a 64-bit memory location.",
            "VFMADD132SD: Multiplies the low double-precision floating-point value from the first source operand to the low double-precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low double-precision floating-point values in the second source operand, performs rounding and stores the resulting double-precision floating-point value to the destination operand (first source operand).",
            "VFMADD213SD: Multiplies the low double-precision floating-point value from the second source operand to the low double-precision floating-point value in the first source operand, adds the infinite precision intermediate result to the low double-precision floating-point value in the third source operand, performs rounding and stores the resulting double-precision floating-point value to the destination operand (first source operand).",
            "VFMADD231SD: Multiplies the low double-precision floating-point value from the second source to the low double-precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low double-precision floating-point value in the first source operand, performs rounding and stores the resulting double-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination is updated according to the writemask."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADD132SD:VFMADD213SD:VFMADD231SD.html"
        ]
    },
    "vpsllq": {
        "detail": [
            "Shift Packed Data Left Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-17 gives an example of shifting words in a 64-bit operand.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.z, reg.q, reg.z, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html"
        ]
    },
    "loopne": {
        "detail": [
            "Loop According to ECX Counter"
        ],
        "documentation": [
            "Performs a loop operation using the RCX, ECX or CX register as a counter (depending on whether address size is 64 bits, 32 bits, or 16 bits). Note that the LOOP instruction ignores REX.W; but 64-bit address size can be over-ridden using a 67H prefix.",
            "Each time the LOOP instruction is executed, the count register is decremented, then checked for 0. If the count is 0, the loop is terminated and program execution continues with the instruction following the LOOP instruction. If the count is not zero, a near jump is performed to the destination (target) operand, which is presumably the instruction at the beginning of the loop.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the IP/EIP/RIP register). This offset is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit immediate value, which is added to the instruction pointer. Offsets of –128 to +127 are allowed with this instruction.",
            "Some forms of the loop instruction (LOOPcc) also accept the ZF flag as a condition for terminating the loop before the count reaches zero. With these forms of the instruction, a condition code (cc) is associated with each instruction to indicate the condition being tested for. Here, the LOOPcc instruction itself does not affect the state of the ZF flag; the ZF flag is changed by other instructions in the loop.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/LOOP:LOOPcc.html"
        ]
    },
    "vfnmaddpd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpsllw": {
        "detail": [
            "Shift Packed Data Left Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-17 gives an example of shifting words in a 64-bit operand.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, mem.x, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.x, reg.q, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html"
        ]
    },
    "cmpps": {
        "detail": [
            "Compare Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed single-precision floating-point values in the second source operand and the first source operand and returns the results of the comparison to the destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each of the pairs of packed values.",
            "EVEX encoded versions: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is an opmask register. Comparison results are written to the destination operand under the writemask k2. Each comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false).",
            "VEX.256 encoded version: The first source operand (second operand) is a YMM register. The second source operand (third operand) can be a YMM register or a 256-bit memory location. The destination operand (first operand) is a YMM register. Eight comparisons are performed with results written to the destination operand. The result of each comparison is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).",
            "128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged. Four comparisons are performed with results written to bits 127:0 of the destination operand. The result of each comparison is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).",
            "VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. Four comparisons are performed with results written to bits 127:0 of the destination operand.",
            "The comparison predicate operand is an 8-bit immediate:"
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPPS.html"
        ]
    },
    "vfmadd213ss": {
        "detail": [
            "Fused Multiply-Add of Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD multiply-add computation on single-precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The first and second operands are XMM registers. The third source operand can be a XMM register or a 32-bit memory location.",
            "VFMADD132SS: Multiplies the low single-precision floating-point value from the first source operand to the low single-precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low single-precision floating-point value in the second source operand, performs rounding and stores the resulting single-precision floating-point value to the destination operand (first source operand).",
            "VFMADD213SS: Multiplies the low single-precision floating-point value from the second source operand to the low single-precision floating-point value in the first source operand, adds the infinite precision intermediate result to the low single-precision floating-point value in the third source operand, performs rounding and stores the resulting single-precision floating-point value to the destination operand (first source operand).",
            "VFMADD231SS: Multiplies the low single-precision floating-point value from the second source operand to the low single-precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low single-precision floating-point value in the first source operand, performs rounding and stores the resulting single-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADD132SS:VFMADD213SS:VFMADD231SS.html"
        ]
    },
    "aesdecwide128kl": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.xy, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vfnmaddps": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vandpd": {
        "detail": [
            "Bitwise Logical AND of Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical AND of the two, four or eight packed double-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ANDPD.html"
        ]
    },
    "vpmuludq": {
        "detail": [
            "Multiply Packed Unsigned Doubleword Integers"
        ],
        "documentation": [
            "Multiplies the first operand (destination operand) by the second operand (source operand) and stores the result in the destination operand.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The source operand can be an unsigned doubleword integer stored in the low doubleword of an MMX technology register or a 64-bit memory location. The destination operand can be an unsigned doubleword integer stored in the low doubleword an MMX technology register. The result is an unsigned",
            "quadword integer stored in the destination an MMX technology register. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).",
            "For 64-bit memory operands, 64 bits are fetched from memory, but only the low doubleword is used in the computation.",
            "128-bit Legacy SSE version: The second source operand is two packed unsigned doubleword integers stored in the first (low) and third doublewords of an XMM register or a 128-bit memory location. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation. The first source operand is two packed unsigned doubleword integers stored in the first and third doublewords of an XMM register. The destination contains two packed unsigned quadword integers stored in an XMM register. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is two packed unsigned doubleword integers stored in the first (low) and third doublewords of an XMM register or a 128-bit memory location. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation. The first source operand is two packed unsigned doubleword integers stored in the first and third doublewords of an XMM register. The destination contains two packed unsigned quadword integers stored in an XMM register. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The second source operand is four packed unsigned doubleword integers stored in the first (low), third, fifth and seventh doublewords of a YMM register or a 256-bit memory location. For 256-bit memory operands, 256 bits are fetched from memory, but only the first, third, fifth and seventh doublewords are used in the computation. The first source operand is four packed unsigned doubleword integers stored in the first, third, fifth and seventh doublewords of an YMM register. The destination contains four packed unaligned quadword integers stored in an YMM register.",
            "EVEX encoded version: The input unsigned doubleword integers are taken from the even-numbered elements of the source operands. The first source operand is a ZMM/YMM/XMM registers. The second source operand can be an ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination is a ZMM/YMM/XMM register, and updated according to the writemask at 64-bit granularity.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMULUDQ.html"
        ]
    },
    "vandps": {
        "detail": [
            "Bitwise Logical AND of Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical AND of the four, eight or sixteen packed single-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ANDPS.html"
        ]
    },
    "xstore": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.b, reg, reg.d, reg.d"
        ],
        "url": [
            "https://"
        ]
    },
    "insb": {
        "detail": [
            "Input from Port to String"
        ],
        "documentation": [
            "Copies the data from the I/O port specified with the source operand (second operand) to the destination operand (first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The ES segment cannot be overridden with a segment override prefix.) The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the INS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand must be “DX,” and the destination operand should be a symbol that indicates the size of the I/O port and the destination address. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers, which must be loaded correctly before the INS instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the INS instructions. Here also DX is assumed by the processor to be the source operand and ES:(E)DI is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic: INSB (byte), INSW (word), or INSD (doubleword).",
            "After the byte, word, or doubleword is transfer from the I/O port to the memory location, the DI/EDI/RDI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.",
            "The INS, INSB, INSW, and INSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for a description of the REP prefix.",
            "These instructions are only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 18, “Input/Output,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.",
            "In 64-bit mode, default address size is 64 bits, 32 bit address size is supported using the prefix 67H. The address of the memory destination is specified by RDI or EDI. 16-bit address size is not supported in 64-bit mode. The operand size is not promoted.",
            "These instructions may read from the I/O port without writing to the memory location if an exception or VM exit occurs due to the write (e.g. #PF). If this would be problematic, for example because the I/O port read has side-effects, software should ensure the write to the memory location does not cause an exception or VM exit.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "mem.b, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/INS:INSB:INSW:INSD.html"
        ]
    },
    "cdqe": {
        "detail": [
            "Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword"
        ],
        "documentation": [
            "Double the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to double-word) instruction copies the sign (bit 15) of the word in the AX register into the high 16 bits of the EAX register.",
            "CBW and CWDE reference the same opcode. The CBW instruction is intended for use when the operand-size attribute is 16; CWDE is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size. Others may treat these two mnemonics as synonyms (CBW/CWDE) and use the setting of the operand-size attribute to determine the size of values to be converted.",
            "In 64-bit mode, the default operation size is the size of the destination register. Use of the REX.W prefix promotes this instruction (CDQE when promoted) to operate on 64-bit operands. In which case, CDQE copies the sign (bit 31) of the doubleword in the EAX register into the high 32 bits of RAX.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/CBW:CWDE:CDQE.html"
        ]
    },
    "insd": {
        "detail": [
            "Input from Port to String"
        ],
        "documentation": [
            "Copies the data from the I/O port specified with the source operand (second operand) to the destination operand (first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The ES segment cannot be overridden with a segment override prefix.) The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the INS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand must be “DX,” and the destination operand should be a symbol that indicates the size of the I/O port and the destination address. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers, which must be loaded correctly before the INS instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the INS instructions. Here also DX is assumed by the processor to be the source operand and ES:(E)DI is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic: INSB (byte), INSW (word), or INSD (doubleword).",
            "After the byte, word, or doubleword is transfer from the I/O port to the memory location, the DI/EDI/RDI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.",
            "The INS, INSB, INSW, and INSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for a description of the REP prefix.",
            "These instructions are only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 18, “Input/Output,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.",
            "In 64-bit mode, default address size is 64 bits, 32 bit address size is supported using the prefix 67H. The address of the memory destination is specified by RDI or EDI. 16-bit address size is not supported in 64-bit mode. The operand size is not promoted.",
            "These instructions may read from the I/O port without writing to the memory location if an exception or VM exit occurs due to the write (e.g. #PF). If this would be problematic, for example because the I/O port read has side-effects, software should ensure the write to the memory location does not cause an exception or VM exit.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/INS:INSB:INSW:INSD.html"
        ]
    },
    "movdq2q": {
        "detail": [
            "Move Quadword from XMM to MMX Technology Register"
        ],
        "documentation": [
            "Moves the low quadword from the source operand (second operand) to the destination operand (first operand). The source operand is an XMM register and the destination operand is an MMX technology register.",
            "This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the MOVDQ2Q instruction is executed.",
            "In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15)."
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVDQ2Q.html"
        ]
    },
    "ficom": {
        "detail": [
            "Compare Integer"
        ],
        "documentation": [
            "Compares the value in ST(0) with an integer source operand and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results (see table below). The integer value is converted to double extended-precision floating-point format before the comparison is made."
        ],
        "operands": [
            "reg.wq, mem.w, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FICOM:FICOMP.html"
        ]
    },
    "vpord": {
        "detail": [
            "Bitwise Logical OR"
        ],
        "documentation": [
            "Performs a bitwise logical OR operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is set to 1 if either or both of the corresponding bits of the first and second operands are 1; otherwise, it is set to 0.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source and destination operands can be XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source and destination operands can be XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source and destination operands can be YMM registers.",
            "EVEX encoded version: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 32/64-bit granularity.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/POR.html"
        ]
    },
    "vphadddq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "stac": {
        "detail": [
            "Set AC Flag in EFLAGS Register"
        ],
        "documentation": [
            "Sets the AC flag bit in EFLAGS register. This may enable alignment checking of user-mode data accesses. This allows explicit supervisor-mode data accesses to user-mode pages even if the SMAP bit is set in the CR4 register.",
            "This instruction's operation is the same in non-64-bit modes and 64-bit mode. Attempts to execute STAC when CPL > 0 cause #UD.",
            "Flags Affected:",
            "AC set. Other flags are unaffected."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/STAC.html"
        ]
    },
    "insw": {
        "detail": [
            "Input from Port to String"
        ],
        "documentation": [
            "Copies the data from the I/O port specified with the source operand (second operand) to the destination operand (first operand). The source operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The destination operand is a memory location, the address of which is read from either the ES:DI, ES:EDI or the RDI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The ES segment cannot be overridden with a segment override prefix.) The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the INS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand must be “DX,” and the destination operand should be a symbol that indicates the size of the I/O port and the destination address. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI registers, which must be loaded correctly before the INS instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the INS instructions. Here also DX is assumed by the processor to be the source operand and ES:(E)DI is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic: INSB (byte), INSW (word), or INSD (doubleword).",
            "After the byte, word, or doubleword is transfer from the I/O port to the memory location, the DI/EDI/RDI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented.) The (E)DI register is incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.",
            "The INS, INSB, INSW, and INSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for a description of the REP prefix.",
            "These instructions are only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 18, “Input/Output,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.",
            "In 64-bit mode, default address size is 64 bits, 32 bit address size is supported using the prefix 67H. The address of the memory destination is specified by RDI or EDI. 16-bit address size is not supported in 64-bit mode. The operand size is not promoted.",
            "These instructions may read from the I/O port without writing to the memory location if an exception or VM exit occurs due to the write (e.g. #PF). If this would be problematic, for example because the I/O port read has side-effects, software should ensure the write to the memory location does not cause an exception or VM exit.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "mem.w, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/INS:INSB:INSW:INSD.html"
        ]
    },
    "vporq": {
        "detail": [
            "Bitwise Logical OR"
        ],
        "documentation": [
            "Performs a bitwise logical OR operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is set to 1 if either or both of the corresponding bits of the first and second operands are 1; otherwise, it is set to 0.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source and destination operands can be XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source and destination operands can be XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source and destination operands can be YMM registers.",
            "EVEX encoded version: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 32/64-bit granularity.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/POR.html"
        ]
    },
    "blcmsk": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://"
        ]
    },
    "fabs": {
        "detail": [
            "Absolute Value"
        ],
        "documentation": [
            "Clears the sign bit of ST(0) to create the absolute value of the operand. The following table shows the results obtained when creating the absolute value of various classes of numbers."
        ],
        "operands": [
            "reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FABS.html"
        ]
    },
    "vpunpckhwd": {
        "detail": [
            "Unpack High Data"
        ],
        "documentation": [
            "Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. Figure 4-20 shows the unpack operation for bytes in 64-bit operands. The low-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html"
        ]
    },
    "lock cmpxchg16b": {
        "detail": [
            "Compare and Exchange Bytes"
        ],
        "documentation": [
            "Compares the 64-bit value in EDX:EAX (or 128-bit value in RDX:RAX if operand size is 128 bits) with the operand (destination operand). If the values are equal, the 64-bit value in ECX:EBX (or 128-bit value in RCX:RBX) is stored in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX (or RDX:RAX). The destination operand is an 8-byte memory location (or 16-byte memory location if operand size is 128 bits). For the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the low-order 32 bits of a 64-bit value. For the RDX:RAX and RCX:RBX register pairs, RDX and RCX contain the high-order 64 bits and RAX and RBX contain the low-order 64bits of a 128-bit value.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor’s bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)",
            "In 64-bit mode, default operation size is 64 bits. Use of the REX.W prefix promotes operation to 128 bits. Note that CMPXCHG16B requires that the destination (memory) operand be 16-byte aligned. See the summary chart at the beginning of this section for encoding data and limits. For information on the CPUID flag that indicates CMPXCHG16B, see page 3-213.",
            "Flags Affected:",
            "The ZF flag is set if the destination operand and EDX:EAX are equal; otherwise it is cleared. The CF, PF, AF, SF, and OF flags are unaffected."
        ],
        "operands": [
            "mem.x, reg, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPXCHG8B:CMPXCHG16B.html"
        ]
    },
    "vpscatterdd": {
        "detail": [
            "Scatter Packed Dword, Packed Qword with Signed Dword, Signed Qword Indices"
        ],
        "documentation": [
            "Stores up to 16 elements (8 elements for qword indices) in doubleword vector or 8 elements in quadword vector to the memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register are partially updated. If any traps or interrupts are pending from already scattered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "Note that:"
        ],
        "operands": [
            "mem.d, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPSCATTERDD:VPSCATTERDQ:VPSCATTERQD:VPSCATTERQQ.html"
        ]
    },
    "int3": {
        "detail": [
            "Call to Interrupt Procedure"
        ],
        "documentation": [
            "The INT n instruction generates a call to the interrupt or exception handler specified with the destination operand (see the section titled “Interrupts and Exceptions” in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). The destination operand specifies a vector from 0 to 255, encoded as an 8-bit unsigned intermediate value. Each vector provides an index to a gate descriptor in the IDT. The first 32 vectors are reserved by Intel for system use. Some of these vectors are used for internally generated exceptions.",
            "The INT n instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The INTO instruction is a special mnemonic for calling overflow exception (#OF), exception 4. The overflow interrupt checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1. (The INTO instruction cannot be used in 64-bit mode.)",
            "The INT3 instruction uses a one-byte opcode (CC) and is intended for calling the debug exception handler with a breakpoint exception (#BP). (This one-byte form is useful because it can replace the first byte of any instruction at which a breakpoint is desired, including other one-byte instructions, without overwriting other instructions.)",
            "The INT1 instruction also uses a one-byte opcode (F1) and generates a debug exception (#DB) without setting any bits in DR6.1 Hardware vendors may use the INT1 instruction for hardware debug. For that reason, Intel recommends software vendors instead use the INT3 instruction for software breakpoints.",
            "Flags Affected:",
            "The EFLAGS register is pushed onto the stack. The IF, TF, NT, AC, RF, and VM flags may be cleared, depending on the mode of operation of the processor when the INT instruction is executed (see the “Operation” section). If the interrupt uses a task gate, any flags may be set or cleared, controlled by the EFLAGS image in the new task’s TSS."
        ],
        "operands": [
            "reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/INTn:INTO:INT3:INT1.html"
        ]
    },
    "fnclex": {
        "detail": [
            "Clear Exceptions"
        ],
        "documentation": [
            "Clears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE), the exception summary status flag (ES), the stack fault flag (SF), and the busy flag (B) in the FPU status word. The FCLEX instruction checks for and handles any pending unmasked floating-point exceptions before clearing the exception flags; the FNCLEX instruction does not.",
            "The assembler issues two instructions for the FCLEX instruction (an FWAIT instruction followed by an FNCLEX instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception."
        ],
        "operands": [
            "reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCLEX:FNCLEX.html"
        ]
    },
    "vpscatterdq": {
        "detail": [
            "Scatter Packed Dword, Packed Qword with Signed Dword, Signed Qword Indices"
        ],
        "documentation": [
            "Stores up to 16 elements (8 elements for qword indices) in doubleword vector or 8 elements in quadword vector to the memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register are partially updated. If any traps or interrupts are pending from already scattered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "Note that:"
        ],
        "operands": [
            "mem.q, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPSCATTERDD:VPSCATTERDQ:VPSCATTERQD:VPSCATTERQQ.html"
        ]
    },
    "vpgatherqd": {
        "detail": [
            "Gather Packed Dword, Packed Qword with Signed Qword Indices"
        ],
        "documentation": [
            "A set of 8 doubleword/quadword memory locations pointed to by base address BASE_ADDR and index vector VINDEX with scale SCALE are gathered. The result is written into a vector register. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be loaded if their corresponding mask bit is one. If an element’s mask bit is not set, the corresponding element of the destination register is left unchanged. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register (k1) are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "If the data element size is less than the index element size, the higher part of the destination register and the mask register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may update these unused elements to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.",
            "Note that:"
        ],
        "operands": [
            "reg.y, reg.q, mem.d",
            "reg.x, mem.d, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPGATHERQD:VPGATHERQQ.html"
        ]
    },
    "maskmovq": {
        "detail": [
            "Store Selected Bytes of Quadword"
        ],
        "documentation": [
            "Stores selected bytes from the source operand (first operand) into a 64-bit memory location. The mask operand (second operand) selects which bytes from the source operand are written to memory. The source and mask operands are MMX technology registers. The memory location specified by the effective address in the DI/EDI/RDI register (the default segment register is DS, but this may be overridden with a segment-override prefix). The memory location does not need to be aligned on a natural boundary. (The size of the store address depends on the address-size attribute.)",
            "The most significant bit in each byte of the mask operand determines whether the corresponding byte in the source operand is written to the corresponding byte location in memory: 0 indicates no write and 1 indicates write.",
            "The MASKMOVQ instruction generates a non-temporal hint to the processor to minimize cache pollution. The non-temporal hint is implemented by using a write combining (WC) memory type protocol (see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10, of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MASKMOVQ instructions if multiple processors might use different memory types to read/write the destination memory locations.",
            "This instruction causes a transition from x87 FPU to MMX technology state (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]).",
            "The behavior of the MASKMOVQ instruction with a mask of all 0s is as follows:"
        ],
        "operands": [
            "reg.q, reg.q, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MASKMOVQ.html"
        ]
    },
    "vdivpd": {
        "detail": [
            "Divide Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD divide of the double-precision floating-point values in the first source operand by the floating-point values in the second source operand (the third operand). Results are written to the destination operand (the first operand).",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand (the second operand) is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding destination are zeroed.",
            "VEX.128 encoded version: The first source operand (the second operand) is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding destination are zeroed.",
            "128-bit Legacy SSE version: The second source operand (the second operand) can be an XMM register or an 128-bit memory location. The destination is the same as the first source operand. The upper bits (MAXVL-1:128) of the corresponding destination are unmodified."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/DIVPD.html"
        ]
    },
    "vextracti32x4": {
        "detail": [
            "Extract packed Integer Values"
        ],
        "documentation": [
            "VEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of doubleword integer values from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand). The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor. The destination may be either a vector register or an 128-bit memory location.",
            "VEXTRACTI32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the writemask.",
            "VEXTRACTI64x2: The low 128-bit of the destination operand is updated at 64-bit granularity according to the writemask.",
            "VEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of quadword integer values from the source operand (the second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor The destination may be either a vector register or a 256-bit memory location.",
            "VEXTRACTI32x8: The low 256-bit of the destination operand is updated at 32-bit granularity according to the writemask.",
            "VEXTRACTI64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the writemask.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "The high 7 bits (6 bits in EVEX.512) of the immediate are ignored.",
            "If VEXTRACTI128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "mem.x, reg.q, reg.z, imm.b",
            "reg.x, reg.z, imm.b",
            "reg.x, reg.q, reg.z, imm.b",
            "mem.x, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html"
        ]
    },
    "vextracti32x8": {
        "detail": [
            "Extract packed Integer Values"
        ],
        "documentation": [
            "VEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of doubleword integer values from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand). The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor. The destination may be either a vector register or an 128-bit memory location.",
            "VEXTRACTI32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the writemask.",
            "VEXTRACTI64x2: The low 128-bit of the destination operand is updated at 64-bit granularity according to the writemask.",
            "VEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of quadword integer values from the source operand (the second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor The destination may be either a vector register or a 256-bit memory location.",
            "VEXTRACTI32x8: The low 256-bit of the destination operand is updated at 32-bit granularity according to the writemask.",
            "VEXTRACTI64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the writemask.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "The high 7 bits (6 bits in EVEX.512) of the immediate are ignored.",
            "If VEXTRACTI128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "mem.y, reg.q, reg.z, imm.b",
            "reg.y, reg.z, imm.b",
            "reg.y, reg.q, reg.z, imm.b",
            "mem.y, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html"
        ]
    },
    "vmovhpd": {
        "detail": [
            "Move High Packed Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "This instruction cannot be used for register to register or memory to memory moves.",
            "128-bit Legacy SSE load:",
            "Moves a double-precision floating-point value from the source 64-bit memory operand and stores it in the high 64-bits of the destination XMM register. The lower 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.",
            "VEX.128 & EVEX encoded load:",
            "Loads a double-precision floating-point value from the source 64-bit memory operand (the third operand) and stores it in the upper 64-bits of the destination XMM register (first operand). The low 64-bits from the first source operand (second operand) are copied to the low 64-bits of the destination. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "128-bit store:",
            "Stores a double-precision floating-point value from the high 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).",
            "Note: VMOVHPD (store) (VEX.128.66.0F 17 /r) is legal and has the same behavior as the existing 66 0F 17 store. For VMOVHPD (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.",
            "If VMOVHPD is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.x, reg.q, mem.q",
            "mem.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVHPD.html"
        ]
    },
    "vpgatherqq": {
        "detail": [
            "Gather Packed Dword, Packed Qword with Signed Qword Indices"
        ],
        "documentation": [
            "A set of 8 doubleword/quadword memory locations pointed to by base address BASE_ADDR and index vector VINDEX with scale SCALE are gathered. The result is written into a vector register. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be loaded if their corresponding mask bit is one. If an element’s mask bit is not set, the corresponding element of the destination register is left unchanged. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register (k1) are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "If the data element size is less than the index element size, the higher part of the destination register and the mask register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may update these unused elements to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.",
            "Note that:"
        ],
        "operands": [
            "reg.z, reg.q, mem.q",
            "reg.y, mem.q, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPGATHERQD:VPGATHERQQ.html"
        ]
    },
    "lock neg": {
        "detail": [
            "Two's Complement Negation"
        ],
        "documentation": [
            "Replaces the value of operand (the destination operand) with its two's complement. (This operation is equivalent to subtracting the operand from 0.) The destination operand is located in a general-purpose register or a memory location.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The CF flag set to 0 if the source operand is 0; otherwise it is set to 1. The OF, SF, ZF, AF, and PF flags are set according to the result."
        ],
        "operands": [
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/NEG.html"
        ]
    },
    "vdivps": {
        "detail": [
            "Divide Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD divide of the four, eight or sixteen packed single-precision floating-point values in the first source operand (the second operand) by the four, eight or sixteen packed single-precision floating-point values in the second source operand (the third operand). Results are written to the destination operand (the first operand).",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/DIVPS.html"
        ]
    },
    "vrsqrtps": {
        "detail": [
            "Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD computation of the approximate reciprocals of the square roots of the four packed single-precision floating-point values in the source operand (second operand) and stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD single-precision floating-point operation.",
            "The relative error for this approximation is:",
            "|Relative Error| ≤ 1.5 ∗ 2−12",
            "The RSQRTPS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). When a source value is a negative value (other than −0.0), a floating-point indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/RSQRTPS.html"
        ]
    },
    "call": {
        "detail": [
            "Call Procedure"
        ],
        "documentation": [
            "Saves procedure linking information on the stack and branches to the called procedure specified using the target operand. The target operand specifies the address of the first instruction in the called procedure. The operand can be an immediate value, a general-purpose register, or a memory location.",
            "This instruction can be used to execute four types of calls:",
            "Flags Affected:",
            "All flags are affected if a task switch occurs; no flags are affected if a task switch does not occur."
        ],
        "operands": [
            "reg.q, reg.q, reg.q, mem.q",
            "mem.q, reg.q, reg.q, mem.q",
            "relbr.d, reg.q, reg.q, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/CALL.html"
        ]
    },
    "vmaxpd": {
        "detail": [
            "Maximum of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed double-precision floating-point values in the first source operand and the second source operand and returns the maximum value for each pair of values to the destination operand.",
            "If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MAXPD can be emulated using a sequence of instructions, such as a comparison followed by AND, ANDN and OR.",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MAXPD.html"
        ]
    },
    "vmovhps": {
        "detail": [
            "Move High Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "This instruction cannot be used for register to register or memory to memory moves.",
            "128-bit Legacy SSE load:",
            "Moves two packed single-precision floating-point values from the source 64-bit memory operand and stores them in the high 64-bits of the destination XMM register. The lower 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.",
            "VEX.128 & EVEX encoded load:",
            "Loads two single-precision floating-point values from the source 64-bit memory operand (the third operand) and stores it in the upper 64-bits of the destination XMM register (first operand). The low 64-bits from the first source operand (the second operand) are copied to the lower 64-bits of the destination. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "128-bit store:",
            "Stores two packed single-precision floating-point values from the high 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).",
            "Note: VMOVHPS (store) (VEX.128.0F 17 /r) is legal and has the same behavior as the existing 0F 17 store. For VMOVHPS (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.",
            "If VMOVHPS is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.x, reg.q, mem.q",
            "mem.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVHPS.html"
        ]
    },
    "pfmul": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "in": {
        "detail": [
            "Input from Port"
        ],
        "documentation": [
            "Copies the value from the I/O port specified with the second operand (source operand) to the destination operand (first operand). The source operand can be a byte-immediate or the DX register; the destination operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively). Using the DX register as a source operand allows I/O port addresses from 0 to 65,535 to be accessed; using a byte immediate allows I/O port addresses 0 to 255 to be accessed.",
            "When accessing an 8-bit I/O port, the opcode determines the port size; when accessing a 16- and 32-bit I/O port, the operand-size attribute determines the port size. At the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0.",
            "This instruction is only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 18, “Input/Output,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, reg",
            "reg, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/IN.html"
        ]
    },
    "invlpgb": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, reg, reg"
        ],
        "url": [
            "https://"
        ]
    },
    "fist": {
        "detail": [
            "Store Integer"
        ],
        "documentation": [
            "The FIST instruction converts the value in the ST(0) register to a signed integer and stores the result in the destination operand. Values can be stored in word or doubleword integer format. The destination operand specifies the address where the first byte of the destination value is to be stored.",
            "The FISTP instruction performs the same operation as the FIST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FISTP instruction also stores values in quadword integer format.",
            "The following table shows the results obtained when storing various classes of numbers in integer format."
        ],
        "operands": [
            "mem.d, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FIST:FISTP.html"
        ]
    },
    "invlpga": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, reg"
        ],
        "url": [
            "https://"
        ]
    },
    "fdiv": {
        "detail": [
            "Divide"
        ],
        "documentation": [
            "Divides the destination operand by the source operand and stores the result in the destination location. The destination operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format.",
            "The no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0) register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location (either a floating-point or an integer value). The two-operand version, divides the contents of the ST(0) register by the contents of the ST(i) register or vice versa.",
            "The FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIV rather than FDIVP.",
            "The FIDIV instructions convert an integer source operand to double extended-precision floating-point format before performing the division. When the source operand is an integer 0, it is treated as a +0.",
            "If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.",
            "The following table shows the results obtained when dividing various classes of numbers, assuming that neither overflow nor underflow occurs."
        ],
        "operands": [
            "reg.wq, mem.d, reg",
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FDIV:FDIVP:FIDIV.html"
        ]
    },
    "vpmuldq": {
        "detail": [
            "Multiply Packed Doubleword Integers"
        ],
        "documentation": [
            "Multiplies packed signed doubleword integers in the even-numbered (zero-based reference) elements of the first source operand with the packed signed doubleword integers in the corresponding elements of the second source operand and stores packed signed quadword results in the destination operand.",
            "128-bit Legacy SSE version: The input signed doubleword integers are taken from the even-numbered elements of the source operands, i.e. the first (low) and third doubleword element. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation. The first source operand and the destination XMM operand is the same. The second source operand can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The input signed doubleword integers are taken from the even-numbered elements of the source operands, i.e., the first (low) and third doubleword element. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation.The first source operand and the destination operand are XMM registers. The second source operand can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The input signed doubleword integers are taken from the even-numbered elements of the source operands, i.e. the first, 3rd, 5th, 7th doubleword element. For 256-bit memory operands, 256 bits are fetched from memory, but only the four even-numbered doublewords are used in the computation. The first source operand and the destination operand are YMM registers. The second source operand can be a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.",
            "EVEX encoded version: The input signed doubleword integers are taken from the even-numbered elements of the source operands. The first source operand is a ZMM/YMM/XMM registers. The second source operand can be an ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination is a ZMM/YMM/XMM register, and updated according to the writemask at 64-bit granularity."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMULDQ.html"
        ]
    },
    "insertq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, reg.q, imm.b, imm.b",
            "reg.q, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vblendpd": {
        "detail": [
            "Blend Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Double-precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The immediate bits [3:0] determine whether the corresponding double-precision floating-point value in the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is ”1”, then the double-precision floating-point value in the second source operand is copied, else the value in the first source operand is copied.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: the first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/BLENDPD.html"
        ]
    },
    "vmaxps": {
        "detail": [
            "Maximum of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed single-precision floating-point values in the first source operand and the second source operand and returns the maximum value for each pair of values to the destination operand.",
            "If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MAXPS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MAXPS.html"
        ]
    },
    "fyl2x": {
        "detail": [
            "Compute y * log2x"
        ],
        "documentation": [
            "Computes (ST(1) ∗ log2 (ST(0))), stores the result in register ST(1), and pops the FPU register stack. The source operand in ST(0) must be a non-zero positive number.",
            "The following table shows the results obtained when taking the log of various classes of numbers, assuming that neither overflow nor underflow occurs."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FYL2X.html"
        ]
    },
    "vblendmpd": {
        "detail": [
            "Blend Float64/Float32 Vectors Using an OpMask Control"
        ],
        "documentation": [
            "Performs an element-by-element blending between float64/float32 elements in the first source operand (the second operand) with the elements in the second source operand (the third operand) using an opmask register as select control. The blended result is written to the destination register.",
            "The destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location.",
            "The opmask register is not used as a writemask for this instruction. Instead, the mask is used as an element selector: every element of the destination is conditionally selected between first source or second source using the value of the related mask bit (0 for first source operand, 1 for second source operand).",
            "If EVEX.z is set, the elements with corresponding mask bit value of 0 in the destination operand are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBLENDMPD:VBLENDMPS.html"
        ]
    },
    "vblendps": {
        "detail": [
            "Blend Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Packed single-precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The immediate bits [7:0] determine whether the corresponding single precision floating-point value in the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is “1”, then the single-precision floating-point value in the second source operand is copied, else the value in the first source operand is copied.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: The first source operand an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/BLENDPS.html"
        ]
    },
    "vphsubwd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vptestmb": {
        "detail": [
            "Logical AND and Set Mask"
        ],
        "documentation": [
            "Performs a bitwise logical AND operation on the first source operand (the second operand) and second source operand (the third operand) and stores the result in the destination operand (the first operand) under the writemask. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second src operands is non-zero; otherwise it is set to 0.",
            "VPTESTMD/VPTESTMQ: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a mask register updated under the writemask.",
            "VPTESTMB/VPTESTMW: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a mask register updated under the writemask."
        ],
        "operands": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.q, reg.x, mem.x",
            "reg.q, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPTESTMB:VPTESTMW:VPTESTMD:VPTESTMQ.html"
        ]
    },
    "vptestmd": {
        "detail": [
            "Logical AND and Set Mask"
        ],
        "documentation": [
            "Performs a bitwise logical AND operation on the first source operand (the second operand) and second source operand (the third operand) and stores the result in the destination operand (the first operand) under the writemask. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second src operands is non-zero; otherwise it is set to 0.",
            "VPTESTMD/VPTESTMQ: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a mask register updated under the writemask.",
            "VPTESTMB/VPTESTMW: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a mask register updated under the writemask."
        ],
        "operands": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.q, reg.z, mem.z",
            "reg.q, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPTESTMB:VPTESTMW:VPTESTMD:VPTESTMQ.html"
        ]
    },
    "vblendmps": {
        "detail": [
            "Blend Float64/Float32 Vectors Using an OpMask Control"
        ],
        "documentation": [
            "Performs an element-by-element blending between float64/float32 elements in the first source operand (the second operand) with the elements in the second source operand (the third operand) using an opmask register as select control. The blended result is written to the destination register.",
            "The destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location.",
            "The opmask register is not used as a writemask for this instruction. Instead, the mask is used as an element selector: every element of the destination is conditionally selected between first source or second source using the value of the related mask bit (0 for first source operand, 1 for second source operand).",
            "If EVEX.z is set, the elements with corresponding mask bit value of 0 in the destination operand are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBLENDMPD:VBLENDMPS.html"
        ]
    },
    "vbroadcasti64x2": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "documentation": [
            "VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).",
            "VEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4 load floating-point values as tuples from the source operand (the second operand) in memory or register and broadcast to all elements of the destination operand (the first operand). The destination operand is a YMM/ZMM register updated according to the writemask k1. The source operand is either a register or 64-bit/128-bit/256-bit memory location.",
            "VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as 256-bit and 512-bit wide versions and up. VBROADCASTSS is supported in 128-bit, 256-bit and 512-bit wide versions. F32x8 and F64x4 are only supported as 512-bit wide versions.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32-bit granularity. VBROADCASTF64X2 and VBROADCASTF64X4 have 64-bit granularity.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.y, mem.x",
            "reg.y, reg.q, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBROADCAST.html"
        ]
    },
    "cmpsd": {
        "detail": [
            "Compare String Operands"
        ],
        "documentation": [
            "Compares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word, doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register according to the results.",
            "Both source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the second source operand is read from ES:DI, ES:EDI or RDI (again depending on the address-size attribute of the instruction is 16, 32, or 64). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the source values. This explicit-operand form is provided to allow documentation. However, note that the documentation provided by this form can be misleading. That is, the source operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords, quadwords), but they do not have to specify the correct loca-",
            "tion. Locations of the source operands are always specified by the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers, which must be loaded correctly before the compare string instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the CMPS instructions. Here also the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers are assumed by the processor to specify the location of the source operands. The size of the source operands is selected with the mnemonic: CMPSB (byte comparison), CMPSW (word comparison), CMPSD (doubleword comparison), or CMPSQ (quadword comparison using REX.W).",
            "After the comparison, the (E/R)SI and (E/R)DI registers increment or decrement automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E/R)SI and (E/R)DI register increment; if the DF flag is 1, the registers decrement.) The registers increment or decrement by 1 for byte operations, by 2 for word operations, 4 for doubleword operations. If operand size is 64, RSI and RDI registers increment by 8 for quadword operations.",
            "The CMPS, CMPSB, CMPSW, CMPSD, and CMPSQ instructions can be preceded by the REP prefix for block comparisons. More often, however, these instructions will be used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for a description of the REP prefix.",
            "In 64-bit mode, the instruction’s default address size is 64 bits, 32 bit address size is supported using the prefix 67H. Use of the REX.W prefix promotes doubleword operation to 64 bits (see CMPSQ). See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The CF, OF, SF, ZF, AF, and PF flags are set according to the temporary result of the comparison."
        ],
        "operands": [
            "mem.d, mem.d",
            "reg.q, reg.q, imm.b",
            "reg.q, mem.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPS:CMPSB:CMPSW:CMPSD:CMPSQ.html"
        ]
    },
    "vbroadcasti64x4": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "documentation": [
            "VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).",
            "VEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4 load floating-point values as tuples from the source operand (the second operand) in memory or register and broadcast to all elements of the destination operand (the first operand). The destination operand is a YMM/ZMM register updated according to the writemask k1. The source operand is either a register or 64-bit/128-bit/256-bit memory location.",
            "VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as 256-bit and 512-bit wide versions and up. VBROADCASTSS is supported in 128-bit, 256-bit and 512-bit wide versions. F32x8 and F64x4 are only supported as 512-bit wide versions.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32-bit granularity. VBROADCASTF64X2 and VBROADCASTF64X4 have 64-bit granularity.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.z, mem.y",
            "reg.z, reg.q, mem.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBROADCAST.html"
        ]
    },
    "vptestmq": {
        "detail": [
            "Logical AND and Set Mask"
        ],
        "documentation": [
            "Performs a bitwise logical AND operation on the first source operand (the second operand) and second source operand (the third operand) and stores the result in the destination operand (the first operand) under the writemask. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second src operands is non-zero; otherwise it is set to 0.",
            "VPTESTMD/VPTESTMQ: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a mask register updated under the writemask.",
            "VPTESTMB/VPTESTMW: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a mask register updated under the writemask."
        ],
        "operands": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.q, reg.z, mem.z",
            "reg.q, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPTESTMB:VPTESTMW:VPTESTMD:VPTESTMQ.html"
        ]
    },
    "cmpsb": {
        "detail": [
            "Compare String Operands"
        ],
        "documentation": [
            "Compares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word, doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register according to the results.",
            "Both source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the second source operand is read from ES:DI, ES:EDI or RDI (again depending on the address-size attribute of the instruction is 16, 32, or 64). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the source values. This explicit-operand form is provided to allow documentation. However, note that the documentation provided by this form can be misleading. That is, the source operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords, quadwords), but they do not have to specify the correct loca-",
            "tion. Locations of the source operands are always specified by the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers, which must be loaded correctly before the compare string instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the CMPS instructions. Here also the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers are assumed by the processor to specify the location of the source operands. The size of the source operands is selected with the mnemonic: CMPSB (byte comparison), CMPSW (word comparison), CMPSD (doubleword comparison), or CMPSQ (quadword comparison using REX.W).",
            "After the comparison, the (E/R)SI and (E/R)DI registers increment or decrement automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E/R)SI and (E/R)DI register increment; if the DF flag is 1, the registers decrement.) The registers increment or decrement by 1 for byte operations, by 2 for word operations, 4 for doubleword operations. If operand size is 64, RSI and RDI registers increment by 8 for quadword operations.",
            "The CMPS, CMPSB, CMPSW, CMPSD, and CMPSQ instructions can be preceded by the REP prefix for block comparisons. More often, however, these instructions will be used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for a description of the REP prefix.",
            "In 64-bit mode, the instruction’s default address size is 64 bits, 32 bit address size is supported using the prefix 67H. Use of the REX.W prefix promotes doubleword operation to 64 bits (see CMPSQ). See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The CF, OF, SF, ZF, AF, and PF flags are set according to the temporary result of the comparison."
        ],
        "operands": [
            "mem.b, mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPS:CMPSB:CMPSW:CMPSD:CMPSQ.html"
        ]
    },
    "vptestmw": {
        "detail": [
            "Logical AND and Set Mask"
        ],
        "documentation": [
            "Performs a bitwise logical AND operation on the first source operand (the second operand) and second source operand (the third operand) and stores the result in the destination operand (the first operand) under the writemask. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second src operands is non-zero; otherwise it is set to 0.",
            "VPTESTMD/VPTESTMQ: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a mask register updated under the writemask.",
            "VPTESTMB/VPTESTMW: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a mask register updated under the writemask."
        ],
        "operands": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.q, reg.x, mem.x",
            "reg.q, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPTESTMB:VPTESTMW:VPTESTMD:VPTESTMQ.html"
        ]
    },
    "scasb": {
        "detail": [
            "Scan String"
        ],
        "documentation": [
            "In non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override prefix.",
            "At the assembly-code level, two forms of this instruction are allowed. The explicit-operand form and the no-operands form. The explicit-operand form (specified using the SCAS mnemonic) allows a memory operand to be specified explicitly. The memory operand must be a symbol that indicates the size and location of the operand value. The register operand is then automatically selected to match the size of the memory operand (AL register for byte comparisons, AX for word comparisons, EAX for doubleword comparisons). The explicit-operand form is provided to allow documentation. Note that the documentation provided by this form can be misleading. That is, the memory operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword) but it does not have to specify the correct location. The location is always specified by ES:(E)DI.",
            "The no-operands form of the instruction uses a short form of SCAS. Again, ES:(E)DI is assumed to be the memory operand and AL, AX, or EAX is assumed to be the register operand. The size of operands is selected by the mnemonic: SCASB (byte comparison), SCASW (word comparison), or SCASD (doubleword comparison).",
            "After the comparison, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented. The register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by 4 for doubleword operations.",
            "SCAS, SCASB, SCASW, SCASD, and SCASQ can be preceded by the REP prefix for block comparisons of ECX bytes, words, doublewords, or quadwords. Often, however, these instructions will be used in a LOOP construct that takes",
            "some action based on the setting of status flags. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix.",
            "In 64-bit mode, the instruction’s default address size is 64-bits, 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits. The 64-bit no-operand mnemonic is SCASQ. Address of the memory operand is specified in either RDI or EDI, and AL/AX/EAX/RAX may be used as the register operand. After a comparison, the destination register is incremented or decremented by the current operand size (depending on the value of the DF flag). See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF, SF, ZF, AF, PF, and CF flags are set according to the temporary result of the comparison."
        ],
        "operands": [
            "reg, mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SCAS:SCASB:SCASW:SCASD.html"
        ]
    },
    "jb": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "vfnmaddsd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.q, mem.q",
            "reg.x, reg.q, reg.q, reg.q",
            "reg.x, reg.q, mem.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "cmpsq": {
        "detail": [
            "Compare String Operands"
        ],
        "documentation": [
            "Compares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word, doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register according to the results.",
            "Both source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the second source operand is read from ES:DI, ES:EDI or RDI (again depending on the address-size attribute of the instruction is 16, 32, or 64). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the source values. This explicit-operand form is provided to allow documentation. However, note that the documentation provided by this form can be misleading. That is, the source operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords, quadwords), but they do not have to specify the correct loca-",
            "tion. Locations of the source operands are always specified by the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers, which must be loaded correctly before the compare string instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the CMPS instructions. Here also the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers are assumed by the processor to specify the location of the source operands. The size of the source operands is selected with the mnemonic: CMPSB (byte comparison), CMPSW (word comparison), CMPSD (doubleword comparison), or CMPSQ (quadword comparison using REX.W).",
            "After the comparison, the (E/R)SI and (E/R)DI registers increment or decrement automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E/R)SI and (E/R)DI register increment; if the DF flag is 1, the registers decrement.) The registers increment or decrement by 1 for byte operations, by 2 for word operations, 4 for doubleword operations. If operand size is 64, RSI and RDI registers increment by 8 for quadword operations.",
            "The CMPS, CMPSB, CMPSW, CMPSD, and CMPSQ instructions can be preceded by the REP prefix for block comparisons. More often, however, these instructions will be used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for a description of the REP prefix.",
            "In 64-bit mode, the instruction’s default address size is 64 bits, 32 bit address size is supported using the prefix 67H. Use of the REX.W prefix promotes doubleword operation to 64 bits (see CMPSQ). See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The CF, OF, SF, ZF, AF, and PF flags are set according to the temporary result of the comparison."
        ],
        "operands": [
            "mem.q, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPS:CMPSB:CMPSW:CMPSD:CMPSQ.html"
        ]
    },
    "scasd": {
        "detail": [
            "Scan String"
        ],
        "documentation": [
            "In non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override prefix.",
            "At the assembly-code level, two forms of this instruction are allowed. The explicit-operand form and the no-operands form. The explicit-operand form (specified using the SCAS mnemonic) allows a memory operand to be specified explicitly. The memory operand must be a symbol that indicates the size and location of the operand value. The register operand is then automatically selected to match the size of the memory operand (AL register for byte comparisons, AX for word comparisons, EAX for doubleword comparisons). The explicit-operand form is provided to allow documentation. Note that the documentation provided by this form can be misleading. That is, the memory operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword) but it does not have to specify the correct location. The location is always specified by ES:(E)DI.",
            "The no-operands form of the instruction uses a short form of SCAS. Again, ES:(E)DI is assumed to be the memory operand and AL, AX, or EAX is assumed to be the register operand. The size of operands is selected by the mnemonic: SCASB (byte comparison), SCASW (word comparison), or SCASD (doubleword comparison).",
            "After the comparison, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented. The register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by 4 for doubleword operations.",
            "SCAS, SCASB, SCASW, SCASD, and SCASQ can be preceded by the REP prefix for block comparisons of ECX bytes, words, doublewords, or quadwords. Often, however, these instructions will be used in a LOOP construct that takes",
            "some action based on the setting of status flags. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix.",
            "In 64-bit mode, the instruction’s default address size is 64-bits, 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits. The 64-bit no-operand mnemonic is SCASQ. Address of the memory operand is specified in either RDI or EDI, and AL/AX/EAX/RAX may be used as the register operand. After a comparison, the destination register is incremented or decremented by the current operand size (depending on the value of the DF flag). See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF, SF, ZF, AF, PF, and CF flags are set according to the temporary result of the comparison."
        ],
        "operands": [
            "reg, mem.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/SCAS:SCASB:SCASW:SCASD.html"
        ]
    },
    "cmpss": {
        "detail": [
            "Compare Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Compares the low single-precision floating-point values in the second source operand and the first source operand and returns the results of the comparison to the destination operand. The comparison predicate operand (immediate operand) specifies the type of comparison performed.",
            "128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 32-bit memory location. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged. The comparison result is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).",
            "VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 32-bit memory location. The result is stored in the low 32 bits of the destination operand; bits 128:32 of the destination operand are copied from the first source operand. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. The comparison result is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).",
            "EVEX encoded version: The first source operand (second operand) is an XMM register. The second source operand can be a XMM register or a 32-bit memory location. The destination operand (first operand) is an opmask register. The comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false), written to the destination starting from the LSB according to the writemask k2. Bits (MAX_KL-1:128) of the destination register are cleared.",
            "The comparison predicate operand is an 8-bit immediate:"
        ],
        "operands": [
            "reg.d, reg.d, imm.b",
            "reg.d, mem.d, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPSS.html"
        ]
    },
    "fadd": {
        "detail": [
            "Add"
        ],
        "documentation": [
            "Adds the destination and source operands and stores the sum in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.",
            "The no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-operand version adds the contents of a memory location (either a floating-point or an integer value) to the contents of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice versa. The value in ST(0) can be doubled by coding:",
            "FADD ST(0), ST(0);",
            "The FADDP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. (The no-operand version of the floating-point add instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FADD rather than FADDP.)",
            "The FIADD instructions convert an integer source operand to double extended-precision floating-point format before performing the addition.",
            "The table on the following page shows the results obtained when adding various classes of numbers, assuming that neither overflow nor underflow occurs.",
            "When the sum of two operands with opposite signs is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. When the source operand is an integer 0, it is treated as a +0.",
            "When both operand are infinities of the same sign, the result is ∞ of the expected sign. If both operands are infinities of opposite signs, an invalid-operation exception is generated. See Table 3-18."
        ],
        "operands": [
            "reg.wq, mem.d, reg",
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FADD:FADDP:FIADD.html"
        ]
    },
    "cmpsw": {
        "detail": [
            "Compare String Operands"
        ],
        "documentation": [
            "Compares the byte, word, doubleword, or quadword specified with the first source operand with the byte, word, doubleword, or quadword specified with the second source operand and sets the status flags in the EFLAGS register according to the results.",
            "Both source operands are located in memory. The address of the first source operand is read from DS:SI, DS:ESI or RSI (depending on the address-size attribute of the instruction is 16, 32, or 64, respectively). The address of the second source operand is read from ES:DI, ES:EDI or RDI (again depending on the address-size attribute of the instruction is 16, 32, or 64). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the CMPS mnemonic) allows the two source operands to be specified explicitly. Here, the source operands should be symbols that indicate the size and location of the source values. This explicit-operand form is provided to allow documentation. However, note that the documentation provided by this form can be misleading. That is, the source operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords, quadwords), but they do not have to specify the correct loca-",
            "tion. Locations of the source operands are always specified by the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers, which must be loaded correctly before the compare string instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the CMPS instructions. Here also the DS:(E)SI (or RSI) and ES:(E)DI (or RDI) registers are assumed by the processor to specify the location of the source operands. The size of the source operands is selected with the mnemonic: CMPSB (byte comparison), CMPSW (word comparison), CMPSD (doubleword comparison), or CMPSQ (quadword comparison using REX.W).",
            "After the comparison, the (E/R)SI and (E/R)DI registers increment or decrement automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E/R)SI and (E/R)DI register increment; if the DF flag is 1, the registers decrement.) The registers increment or decrement by 1 for byte operations, by 2 for word operations, 4 for doubleword operations. If operand size is 64, RSI and RDI registers increment by 8 for quadword operations.",
            "The CMPS, CMPSB, CMPSW, CMPSD, and CMPSQ instructions can be preceded by the REP prefix for block comparisons. More often, however, these instructions will be used in a LOOP construct that takes some action based on the setting of the status flags before the next comparison is made. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in Chapter 4 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for a description of the REP prefix.",
            "In 64-bit mode, the instruction’s default address size is 64 bits, 32 bit address size is supported using the prefix 67H. Use of the REX.W prefix promotes doubleword operation to 64 bits (see CMPSQ). See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The CF, OF, SF, ZF, AF, and PF flags are set according to the temporary result of the comparison."
        ],
        "operands": [
            "mem.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPS:CMPSB:CMPSW:CMPSD:CMPSQ.html"
        ]
    },
    "jl": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "jo": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "jp": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "scasq": {
        "detail": [
            "Scan String"
        ],
        "documentation": [
            "In non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override prefix.",
            "At the assembly-code level, two forms of this instruction are allowed. The explicit-operand form and the no-operands form. The explicit-operand form (specified using the SCAS mnemonic) allows a memory operand to be specified explicitly. The memory operand must be a symbol that indicates the size and location of the operand value. The register operand is then automatically selected to match the size of the memory operand (AL register for byte comparisons, AX for word comparisons, EAX for doubleword comparisons). The explicit-operand form is provided to allow documentation. Note that the documentation provided by this form can be misleading. That is, the memory operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword) but it does not have to specify the correct location. The location is always specified by ES:(E)DI.",
            "The no-operands form of the instruction uses a short form of SCAS. Again, ES:(E)DI is assumed to be the memory operand and AL, AX, or EAX is assumed to be the register operand. The size of operands is selected by the mnemonic: SCASB (byte comparison), SCASW (word comparison), or SCASD (doubleword comparison).",
            "After the comparison, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented. The register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by 4 for doubleword operations.",
            "SCAS, SCASB, SCASW, SCASD, and SCASQ can be preceded by the REP prefix for block comparisons of ECX bytes, words, doublewords, or quadwords. Often, however, these instructions will be used in a LOOP construct that takes",
            "some action based on the setting of status flags. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix.",
            "In 64-bit mode, the instruction’s default address size is 64-bits, 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits. The 64-bit no-operand mnemonic is SCASQ. Address of the memory operand is specified in either RDI or EDI, and AL/AX/EAX/RAX may be used as the register operand. After a comparison, the destination register is incremented or decremented by the current operand size (depending on the value of the DF flag). See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF, SF, ZF, AF, PF, and CF flags are set according to the temporary result of the comparison."
        ],
        "operands": [
            "reg, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/SCAS:SCASB:SCASW:SCASD.html"
        ]
    },
    "js": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "xrstors64": {
        "detail": [
            "Restore Processor Extended States Supervisor"
        ],
        "documentation": [
            "Performs a full or partial restore of processor state components from the XSAVE area located at the memory address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XRSTORS may be executed only if CPL = 0.",
            "The format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Section 13.12, “Operation of XRSTORS,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XRSTOR instruction. The following items provide a high-level outline:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.z[4096], reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XRSTORS.html"
        ]
    },
    "scasw": {
        "detail": [
            "Scan String"
        ],
        "documentation": [
            "In non-64-bit modes and in default 64-bit mode: this instruction compares a byte, word, doubleword or quadword specified using a memory operand with the value in AL, AX, or EAX. It then sets status flags in EFLAGS recording the results. The memory operand address is read from ES:(E)DI register (depending on the address-size attribute of the instruction and the current operational mode). Note that ES cannot be overridden with a segment override prefix.",
            "At the assembly-code level, two forms of this instruction are allowed. The explicit-operand form and the no-operands form. The explicit-operand form (specified using the SCAS mnemonic) allows a memory operand to be specified explicitly. The memory operand must be a symbol that indicates the size and location of the operand value. The register operand is then automatically selected to match the size of the memory operand (AL register for byte comparisons, AX for word comparisons, EAX for doubleword comparisons). The explicit-operand form is provided to allow documentation. Note that the documentation provided by this form can be misleading. That is, the memory operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword) but it does not have to specify the correct location. The location is always specified by ES:(E)DI.",
            "The no-operands form of the instruction uses a short form of SCAS. Again, ES:(E)DI is assumed to be the memory operand and AL, AX, or EAX is assumed to be the register operand. The size of operands is selected by the mnemonic: SCASB (byte comparison), SCASW (word comparison), or SCASD (doubleword comparison).",
            "After the comparison, the (E)DI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the (E)DI register is incremented; if the DF flag is 1, the (E)DI register is decremented. The register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by 4 for doubleword operations.",
            "SCAS, SCASB, SCASW, SCASD, and SCASQ can be preceded by the REP prefix for block comparisons of ECX bytes, words, doublewords, or quadwords. Often, however, these instructions will be used in a LOOP construct that takes",
            "some action based on the setting of status flags. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix.",
            "In 64-bit mode, the instruction’s default address size is 64-bits, 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits. The 64-bit no-operand mnemonic is SCASQ. Address of the memory operand is specified in either RDI or EDI, and AL/AX/EAX/RAX may be used as the register operand. After a comparison, the destination register is incremented or decremented by the current operand size (depending on the value of the DF flag). See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF, SF, ZF, AF, PF, and CF flags are set according to the temporary result of the comparison."
        ],
        "operands": [
            "reg, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/SCAS:SCASB:SCASW:SCASD.html"
        ]
    },
    "vfnmaddss": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.d, reg.d, mem.d",
            "reg.x, reg.d, reg.d, reg.d",
            "reg.x, reg.d, mem.d, reg.d"
        ],
        "url": [
            "https://"
        ]
    },
    "jz": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "fchs": {
        "detail": [
            "Change Sign"
        ],
        "documentation": [
            "Complements the sign bit of ST(0). This operation changes a positive value into a negative value of equal magnitude or vice versa. The following table shows the results obtained when changing the sign of various classes of numbers."
        ],
        "operands": [
            "reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCHS.html"
        ]
    },
    "vpshldd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "cmovbe": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "vpackusdw": {
        "detail": [
            "Pack with Unsigned Saturation"
        ],
        "documentation": [
            "Converts packed signed doubleword integers in the first and second source operands into packed unsigned word integers using unsigned saturation to handle overflow conditions. If the signed doubleword value is beyond the range of an unsigned word (that is, greater than FFFFH or less than 0000H), the saturated unsigned word integer value of FFFFH or 0000H, respectively, is stored in the destination.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, updated conditionally under the writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding destination register destination are unmodified."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PACKUSDW.html"
        ]
    },
    "vpshldq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "vpshldw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "invd": {
        "detail": [
            "Invalidate Internal Caches"
        ],
        "documentation": [
            "Invalidates (flushes) the processor’s internal caches and issues a special-function bus cycle that directs external caches to also flush themselves. Data held in internal caches is not written back to main memory.",
            "After executing this instruction, the processor does not wait for the external caches to complete their flushing operation before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache flush signal.",
            "The INVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction.",
            "The INVD instruction may be used when the cache is used as temporary memory and the cache contents need to be invalidated rather than written back to memory. When the cache is used as temporary memory, no external device should be actively writing data to main memory.",
            "Use this instruction with care. Data cached internally and not written back to main memory will be lost. Note that any data from an external device to main memory (for example, via a PCIWrite) can be temporarily stored in the caches; these data can be lost when an INVD instruction is executed. Unless there is a specific requirement or benefit to flushing caches without writing back modified cache lines (for example, temporary memory, testing, or fault recovery where cache coherency with main memory is not a concern), software should instead use the WBINVD instruction.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/INVD.html"
        ]
    },
    "vgf2p8affineinvqb": {
        "detail": [
            "Galois Field Affine Transformation Inverse"
        ],
        "documentation": [
            "The AFFINEINVB instruction computes an affine transformation in the Galois Field 28. For this instruction, an affine transformation is defined by A * inv(x) + b where “A” is an 8 by 8 bit matrix, and “x” and “b” are 8-bit vectors. The inverse of the bytes in x is defined with respect to the reduction polynomial x8 + x4 + x3 + x + 1.",
            "One SIMD register (operand 1) holds “x” as either 16, 32 or 64 8-bit vectors. A second SIMD (operand 2) register or memory operand contains 2, 4, or 8 “A” values, which are operated upon by the correspondingly aligned 8 “x” values in the first register. The “b” vector is constant for all calculations and contained in the immediate byte.",
            "The SSE encoded forms of the instruction require 16B alignment on their memory operations.",
            "The inverse of each byte is given by the following table. The upper nibble is on the vertical axis and the lower nibble is on the horizontal axis. For example, the inverse of 0x95 is 0x8A."
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/GF2P8AFFINEINVQB.html"
        ]
    },
    "korb": {
        "detail": [
            "Bitwise Logical OR Masks"
        ],
        "documentation": [
            "Performs a bitwise OR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KORW:KORB:KORQ:KORD.html"
        ]
    },
    "kord": {
        "detail": [
            "Bitwise Logical OR Masks"
        ],
        "documentation": [
            "Performs a bitwise OR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KORW:KORB:KORQ:KORD.html"
        ]
    },
    "psignd": {
        "detail": [
            "Packed SIGN"
        ],
        "documentation": [
            "(V)PSIGNB/(V)PSIGNW/(V)PSIGND negates each data element of the destination operand (the first operand) if the signed integer value of the corresponding data element in the source operand (the second operand) is less than zero. If the signed integer value of a data element in the source operand is positive, the corresponding data element in the destination operand is unchanged. If a data element in the source operand is zero, the corresponding data element in the destination operand is set to zero.",
            "(V)PSIGNB operates on signed bytes. (V)PSIGNW operates on 16-bit signed words. (V)PSIGND operates on signed 32-bit integers. When the source operand is a 128bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Legacy SSE instructions: Both operands can be MMX registers. In 64-bit mode, use the REX prefix to access additional registers.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise instructions will #UD.",
            "VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand is an YMM register or a 256-bit memory location."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSIGNB:PSIGNW:PSIGND.html"
        ]
    },
    "psignb": {
        "detail": [
            "Packed SIGN"
        ],
        "documentation": [
            "(V)PSIGNB/(V)PSIGNW/(V)PSIGND negates each data element of the destination operand (the first operand) if the signed integer value of the corresponding data element in the source operand (the second operand) is less than zero. If the signed integer value of a data element in the source operand is positive, the corresponding data element in the destination operand is unchanged. If a data element in the source operand is zero, the corresponding data element in the destination operand is set to zero.",
            "(V)PSIGNB operates on signed bytes. (V)PSIGNW operates on 16-bit signed words. (V)PSIGND operates on signed 32-bit integers. When the source operand is a 128bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Legacy SSE instructions: Both operands can be MMX registers. In 64-bit mode, use the REX prefix to access additional registers.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise instructions will #UD.",
            "VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand is an YMM register or a 256-bit memory location."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSIGNB:PSIGNW:PSIGND.html"
        ]
    },
    "fsubrp": {
        "detail": [
            "Reverse Subtract"
        ],
        "documentation": [
            "Subtracts the destination operand from the source operand and stores the difference in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.",
            "These instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided to support more efficient coding.",
            "The no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.",
            "The FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point reverse subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUBR rather than FSUBRP.",
            "The FISUBR instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.",
            "The following table shows the results obtained when subtracting various classes of numbers from one another, assuming that neither overflow nor underflow occurs. Here, the DEST value is subtracted from the SRC value (SRC − DEST = result).",
            "When the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.",
            "When one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalidoperation exception is generated."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FSUBR:FSUBRP:FISUBR.html"
        ]
    },
    "aesdec128kl vaddpd": {
        "detail": [
            "Add Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Add two, four or eight packed double-precision floating-point values from the first source operand to the second source operand, and stores the packed double-precision floating-point results in the destination operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: the first source operand is a XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADDPD.html"
        ]
    },
    "fisttp": {
        "detail": [
            "Store Integer with Truncation"
        ],
        "documentation": [
            "FISTTP converts the value in ST into a signed integer using truncation (chop) as rounding mode, transfers the result to the destination, and pop ST. FISTTP accepts word, short integer, and long integer destinations.",
            "The following table shows the results obtained when storing various classes of numbers in integer format.",
            "Flags Affected:",
            "C1 is cleared; C0, C2, C3 undefined."
        ],
        "operands": [
            "mem.d, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FISTTP.html"
        ]
    },
    "korq": {
        "detail": [
            "Bitwise Logical OR Masks"
        ],
        "documentation": [
            "Performs a bitwise OR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KORW:KORB:KORQ:KORD.html"
        ]
    },
    "loop": {
        "detail": [
            "Loop According to ECX Counter"
        ],
        "documentation": [
            "Performs a loop operation using the RCX, ECX or CX register as a counter (depending on whether address size is 64 bits, 32 bits, or 16 bits). Note that the LOOP instruction ignores REX.W; but 64-bit address size can be over-ridden using a 67H prefix.",
            "Each time the LOOP instruction is executed, the count register is decremented, then checked for 0. If the count is 0, the loop is terminated and program execution continues with the instruction following the LOOP instruction. If the count is not zero, a near jump is performed to the destination (target) operand, which is presumably the instruction at the beginning of the loop.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the IP/EIP/RIP register). This offset is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit immediate value, which is added to the instruction pointer. Offsets of –128 to +127 are allowed with this instruction.",
            "Some forms of the loop instruction (LOOPcc) also accept the ZF flag as a condition for terminating the loop before the count reaches zero. With these forms of the instruction, a condition code (cc) is associated with each instruction to indicate the condition being tested for. Here, the LOOPcc instruction itself does not affect the state of the ZF flag; the ZF flag is changed by other instructions in the loop.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/LOOP:LOOPcc.html"
        ]
    },
    "mfence": {
        "detail": [
            "Memory Fence"
        ],
        "documentation": [
            "Performs a serializing operation on all load-from-memory and store-to-memory instructions that were issued prior the MFENCE instruction. This serializing operation guarantees that every load and store instruction that precedes the MFENCE instruction in program order becomes globally visible before any load or store instruction that follows the MFENCE instruction.1 The MFENCE instruction is ordered with respect to all load and store instructions, other MFENCE instructions, any LFENCE and SFENCE instructions, and any serializing instructions (such as the CPUID instruction). MFENCE does not serialize the instruction stream."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/MFENCE.html"
        ]
    },
    "korw": {
        "detail": [
            "Bitwise Logical OR Masks"
        ],
        "documentation": [
            "Performs a bitwise OR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KORW:KORB:KORQ:KORD.html"
        ]
    },
    "psignw": {
        "detail": [
            "Packed SIGN"
        ],
        "documentation": [
            "(V)PSIGNB/(V)PSIGNW/(V)PSIGND negates each data element of the destination operand (the first operand) if the signed integer value of the corresponding data element in the source operand (the second operand) is less than zero. If the signed integer value of a data element in the source operand is positive, the corresponding data element in the destination operand is unchanged. If a data element in the source operand is zero, the corresponding data element in the destination operand is set to zero.",
            "(V)PSIGNB operates on signed bytes. (V)PSIGNW operates on 16-bit signed words. (V)PSIGND operates on signed 32-bit integers. When the source operand is a 128bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Legacy SSE instructions: Both operands can be MMX registers. In 64-bit mode, use the REX prefix to access additional registers.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise instructions will #UD.",
            "VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand is an YMM register or a 256-bit memory location."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSIGNB:PSIGNW:PSIGND.html"
        ]
    },
    "vrcpps": {
        "detail": [
            "Compute Reciprocals of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD computation of the approximate reciprocals of the four packed single-precision floating-point values in the source operand (second operand) stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD single-precision floating-point operation.",
            "The relative error for this approximation is:",
            "|Relative Error| ≤ 1.5 ∗ 2−12",
            "The RCPPS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). Tiny results (see Section 4.9.1.5, “Numeric Underflow Exception (#U)” in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1) are always flushed to 0.0, with the sign of the operand. (Input values greater than or equal to |1.11111111110100000000000B∗2125| are guaranteed to not produce tiny results; input values less than or equal to |1.00000000000110000000001B*2126| are guaranteed to produce tiny results, which are in turn flushed to 0.0; and input values in between this range may or may not produce tiny results, depending on the implementation.) When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/RCPPS.html"
        ]
    },
    "movbe": {
        "detail": [
            "Move Data After Swapping Bytes"
        ],
        "documentation": [
            "Performs a byte swap operation on the data copied from the second operand (source operand) and store the result in the first operand (destination operand). The source operand can be a general-purpose register, or memory location; the destination register can be a general-purpose register, or a memory location; however, both operands can not be registers, and only one operand can be a memory location. Both operands must be the same size, which can be a word, a doubleword or quadword.",
            "The MOVBE instruction is provided for swapping the bytes on a read from memory or on a write to memory; thus providing support for converting little-endian values to big-endian format and vice versa.",
            "In 64-bit mode, the instruction's default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.w, mem.w",
            "mem.w, reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVBE.html"
        ]
    },
    "vshufi64x2": {
        "detail": [
            "Shuffle Packed Values at 128-bit Granularity"
        ],
        "documentation": [
            "256-bit Version: Moves one of the two 128-bit packed single-precision floating-point values from the first source operand (second operand) into the low 128-bit of the destination operand (first operand); moves one of the two packed 128-bit floating-point values from the second source operand (third operand) into the high 128-bit of the destination operand. The selector operand (third operand) determines which values are moved to the destination operand.",
            "512-bit Version: Moves two of the four 128-bit packed single-precision floating-point values from the first source operand (second operand) into the low 256-bit of each double qword of the destination operand (first operand); moves two of the four packed 128-bit floating-point values from the second source operand (third operand) into the high 256-bit of the destination operand. The selector operand (third operand) determines which values are moved to the destination operand.",
            "The first source operand is a vector register. The second source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a vector register.",
            "The writemask updates the destination operand with the granularity of 32/64-bit data elements."
        ],
        "operands": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSHUFF32x4:VSHUFF64x2:VSHUFI32x4:VSHUFI64x2.html"
        ]
    },
    "kxorb": {
        "detail": [
            "Bitwise Logical XOR Masks"
        ],
        "documentation": [
            "Performs a bitwise XOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KXORW:KXORB:KXORQ:KXORD.html"
        ]
    },
    "vcvttsd2usi": {
        "detail": [
            "Convert with Truncation Scalar Double-Precision Floating-Point Value to Unsigned Integer"
        ],
        "documentation": [
            "Converts with truncation a double-precision floating-point value in the source operand (the second operand) to an unsigned doubleword integer (or unsigned quadword integer if operand size is 64 bits) in the destination operand (the first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w – 1 is returned, where w represents the number of bits in the destination format.",
            "EVEX.W1 version: promotes the instruction to produce 64-bit data in 64-bit mode."
        ],
        "operands": [
            "reg.d, mem.q",
            "reg.d, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTTSD2USI.html"
        ]
    },
    "kxord": {
        "detail": [
            "Bitwise Logical XOR Masks"
        ],
        "documentation": [
            "Performs a bitwise XOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KXORW:KXORB:KXORQ:KXORD.html"
        ]
    },
    "addpd": {
        "detail": [
            "Add Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Add two, four or eight packed double-precision floating-point values from the first source operand to the second source operand, and stores the packed double-precision floating-point results in the destination operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: the first source operand is a XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADDPD.html"
        ]
    },
    "vdivsd": {
        "detail": [
            "Divide Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Divides the low double-precision floating-point value in the first source operand by the low double-precision floating-point value in the second source operand, and stores the double-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination are XMM registers.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:64) of the corresponding ZMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The quadword at bits 127:64 of the destination operand is copied from the corresponding quadword of the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX.128 encoded version: The first source operand is an xmm register encoded by EVEX.vvvv. The quadword element of the destination operand at bits 127:64 are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX version: The low quadword element of the destination is updated according to the writemask.",
            "Software should ensure VDIVSD is encoded with VEX.L=0. Encoding VDIVSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/DIVSD.html"
        ]
    },
    "vmlaunch": {
        "detail": [
            "Launch/Resume Virtual Machine"
        ],
        "documentation": [
            "Effects a VM entry managed by the current VMCS.",
            "Flags Affected:",
            "See the operation section and Section 30.2."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/VMLAUNCH:VMRESUME.html"
        ]
    },
    "kxorq": {
        "detail": [
            "Bitwise Logical XOR Masks"
        ],
        "documentation": [
            "Performs a bitwise XOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KXORW:KXORB:KXORQ:KXORD.html"
        ]
    },
    "repe lodsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "ud2": {
        "detail": [
            "Undefined Instruction"
        ],
        "documentation": [
            "Generates an invalid opcode exception. This instruction is provided for software testing to explicitly generate an invalid opcode exception. The opcodes for this instruction are reserved for this purpose.",
            "Other than raising the invalid opcode exception, this instruction has no effect on processor state or memory.",
            "Even though it is the execution of the UD instruction that causes the invalid opcode exception, the instruction pointer saved by delivery of the exception references the UD instruction (and not the following instruction).",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/UD.html"
        ]
    },
    "repe lodsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vdivss": {
        "detail": [
            "Divide Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Divides the low single-precision floating-point value in the first source operand by the low single-precision floating-point value in the second source operand, and stores the single-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 32-bit memory location.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The three high-order doublewords of the destination operand are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX.128 encoded version: The first source operand is an xmm register encoded by EVEX.vvvv. The doubleword elements of the destination operand at bits 127:32 are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX version: The low doubleword element of the destination is updated according to the writemask.",
            "Software should ensure VDIVSS is encoded with VEX.L=0. Encoding VDIVSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/DIVSS.html"
        ]
    },
    "vrsqrtss": {
        "detail": [
            "Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Computes an approximate reciprocal of the square root of the low single-precision floating-point value in the source operand (second operand) stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a scalar single-precision floating-point operation.",
            "The relative error for this approximation is:",
            "|Relative Error| ≤ 1.5 ∗ 2−12",
            "The RSQRTSS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). When a source value is a negative value (other than −0.0), a floating-point indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/RSQRTSS.html"
        ]
    },
    "kxorw": {
        "detail": [
            "Bitwise Logical XOR Masks"
        ],
        "documentation": [
            "Performs a bitwise XOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KXORW:KXORB:KXORQ:KXORD.html"
        ]
    },
    "imul": {
        "detail": [
            "Signed Multiply"
        ],
        "documentation": [
            "Performs a signed multiplication of two operands. This instruction has three forms, depending on the number of operands.",
            "Flags Affected:",
            "For the one operand form of the instruction, the CF and OF flags are set when significant bits are carried into the upper half of the result and cleared when the result fits exactly in the lower half of the result. For the two- and three-operand forms of the instruction, the CF and OF flags are set when the result must be truncated to fit in the destination operand size and cleared when the result fits exactly in the destination operand size. The SF, ZF, AF, and PF flags are undefined."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, reg.w, imm.w",
            "reg.w, mem.w",
            "reg.b, reg, reg",
            "reg.w, mem.w, imm.w",
            "mem.b, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/IMUL.html"
        ]
    },
    "vmaxsd": {
        "detail": [
            "Return Maximum Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Compares the low double-precision floating-point values in the first source operand and the second source operand, and returns the maximum value to the low quadword of the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers. When the second source operand is a memory operand, only 64 bits are accessed.",
            "If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN of either source operand be returned, the action of MAXSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.",
            "128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination operand is updated according to the writemask.",
            "Software should ensure VMAXSD is encoded with VEX.L=0. Encoding VMAXSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MAXSD.html"
        ]
    },
    "sha1rnds4": {
        "detail": [
            "Perform Four Rounds of SHA1 Operation"
        ],
        "documentation": [
            "The SHA1RNDS4 instruction performs four rounds of SHA1 operation using an initial SHA1 state (A,B,C,D) from the first operand (which is a source operand and the destination operand) and some pre-computed sum of the next 4 round message dwords, and state variable E from the second operand (a source operand). The updated SHA1 state (A,B,C,D) after four rounds of processing is stored in the destination operand.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SHA1RNDS4.html"
        ]
    },
    "fcmovnb": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "documentation": [
            "Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Description column above and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).",
            "The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.",
            "A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “COMISS—Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS” in this chapter). If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCMOVcc.html"
        ]
    },
    "cldemote": {
        "detail": [
            "Cache Line Demote"
        ],
        "documentation": [
            "Hints to hardware that the cache line that contains the linear address specified with the memory operand should be moved (“demoted”) from the cache(s) closest to the processor core to a level more distant from the processor core. This may accelerate subsequent accesses to the line by other cores in the same coherence domain, especially if the line was written by the core that demotes the line. Moving the line in such a manner is a performance optimization, i.e., it is a hint which does not modify architectural state. Hardware may choose which level in the cache hierarchy to retain the line (e.g., L3 in typical server designs). The source operand is a byte memory location.",
            "The availability of the CLDEMOTE instruction is indicated by the presence of the CPUID feature flag CLDEMOTE (bit 25 of the ECX register in sub-leaf 07H, see “CPUID—CPU Identification”). On processors which do not support the CLDEMOTE instruction (including legacy hardware) the instruction will be treated as a NOP.",
            "A CLDEMOTE instruction is ordered with respect to stores to the same cache line, but unordered with respect to other instructions including memory fences, CLDEMOTE, CLWB or CLFLUSHOPT instructions to a different cache line. Since CLDEMOTE will retire in order with respect to stores to the same cache line, software should ensure that after issuing CLDEMOTE the line is not accessed again immediately by the same core to avoid cache data movement penalties.",
            "The effective memory type of the page containing the affected line determines the effect; cacheable types are likely to generate a data movement operation, while uncacheable types may cause the instruction to be ignored.",
            "Speculative fetching can occur at any time and is not tied to instruction execution. The CLDEMOTE instruction is not ordered with respect to PREFETCHh instructions or any of the speculative fetching mechanisms. That is, data can be speculatively loaded into a cache line just before, during, or after the execution of a CLDEMOTE instruction that references the cache line.",
            "Unlike CLFLUSH, CLFLUSHOPT and CLWB instructions, CLDEMOTE is not guaranteed to write back modified data to memory.",
            "The CLDEMOTE instruction may be ignored by hardware in certain cases and is not a guarantee.",
            "The CLDEMOTE instruction can be used at all privilege levels. In certain processor implementations the CLDEMOTE instruction may set the A bit but not the D bit in the page tables.",
            "If the line is not found in the cache, the instruction will be treated as a NOP.",
            "In some implementations, the CLDEMOTE instruction may always cause a transactional abort with Transactional Synchronization Extensions (TSX). However, programmers must not rely on CLDEMOTE instruction to force a transactional abort.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/CLDEMOTE.html"
        ]
    },
    "addps": {
        "detail": [
            "Add Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Add four, eight or sixteen packed single-precision floating-point values from the first source operand with the second source operand, and stores the packed single-precision floating-point results in the destination operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: the first source operand is a XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADDPS.html"
        ]
    },
    "fcmovne": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "documentation": [
            "Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Description column above and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).",
            "The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.",
            "A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “COMISS—Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS” in this chapter). If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCMOVcc.html"
        ]
    },
    "frndint": {
        "detail": [
            "Round to Integer"
        ],
        "documentation": [
            "Rounds the source value in the ST(0) register to the nearest integral value, depending on the current rounding mode (setting of the RC field of the FPU control word), and stores the result in ST(0).",
            "If the source value is ∞, the value is not changed. If the source value is not an integral value, the floating-point inexact-result exception (#P) is generated.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FRNDINT.html"
        ]
    },
    "vpalignr": {
        "detail": [
            "Packed Align Right"
        ],
        "documentation": [
            "(V)PALIGNR concatenates the destination operand (the first operand) and the source operand (the second operand) into an intermediate composite, shifts the composite at byte granularity to the right by a constant immediate, and extracts the right-aligned result into the destination. The first and the second operands can be an MMX,",
            "XMM or a YMM register. The immediate value is considered unsigned. Immediate shift counts larger than the 2L (i.e. 32 for 128-bit operands, or 16 for 64-bit operands) produce a zero result. Both operands can be MMX registers, XMM registers or YMM registers. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "In 64-bit mode and not encoded by VEX/EVEX prefix, use the REX prefix to access additional registers.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "EVEX.512 encoded version: The first source operand is a ZMM register and contains four 16-byte blocks. The second source operand is a ZMM register or a 512-bit memory location containing four 16-byte block. The destination operand is a ZMM register and contain four 16-byte results. The imm8[7:0] is the common shift count",
            "used for each of the four successive 16-byte block sources. The low 16-byte block of the two source operands produce the low 16-byte result of the destination operand, the high 16-byte block of the two source operands produce the high 16-byte result of the destination operand and so on for the blocks in the middle.",
            "VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register and contains two 16-byte blocks. The second source operand is a YMM register or a 256-bit memory location containing two 16-byte block. The destination operand is a YMM register and contain two 16-byte results. The imm8[7:0] is the common shift count used for the two lower 16-byte block sources and the two upper 16-byte block sources. The low 16-byte block of the two source operands produce the low 16-byte result of the destination operand, the high 16-byte block of the two source operands produce the high 16-byte result of the destination operand. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "Concatenation is done with 128-bit data in the first and second source operand for both 128-bit and 256-bit instructions. The high 128-bits of the intermediate composite 256-bit result came from the 128-bit data from the first source operand; the low 128-bits of the intermediate result came from the 128-bit data of the second source operand.",
            "Note: VEX.L must be 0, otherwise the instruction will #UD.",
            "0 127 0 127"
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PALIGNR.html"
        ]
    },
    "repe lodsq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "packusdw": {
        "detail": [
            "Pack with Unsigned Saturation"
        ],
        "documentation": [
            "Converts packed signed doubleword integers in the first and second source operands into packed unsigned word integers using unsigned saturation to handle overflow conditions. If the signed doubleword value is beyond the range of an unsigned word (that is, greater than FFFFH or less than 0000H), the saturated unsigned word integer value of FFFFH or 0000H, respectively, is stored in the destination.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, updated conditionally under the writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding destination register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PACKUSDW.html"
        ]
    },
    "lidt": {
        "detail": [
            "Load Global/Interrupt Descriptor Table Register"
        ],
        "documentation": [
            "Loads the values in the source operand into the global descriptor table register (GDTR) or the interrupt descriptor table register (IDTR). The source operand specifies a 6-byte memory location that contains the base address (a linear address) and the limit (size of table in bytes) of the global descriptor table (GDT) or the interrupt descriptor table (IDT). If operand-size attribute is 32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data operand) and a 32-bit base address (upper 4 bytes of the data operand) are loaded into the register. If the operand-size attribute is 16 bits, a 16-bit limit (lower 2 bytes) and a 24-bit base address (third, fourth, and fifth byte) are loaded. Here, the high-order byte of the operand is not used and the high-order byte of the base address in the GDTR or IDTR is filled with zeros.",
            "The LGDT and LIDT instructions are used only in operating-system software; they are not used in application programs. They are the only instructions that directly load a linear address (that is, not a segment-relative address) and a limit in protected mode. They are commonly executed in real-address mode to allow processor initialization prior to switching to protected mode.",
            "In 64-bit mode, the instruction’s operand size is fixed at 8+2 bytes (an 8-byte base and a 2-byte limit). See the summary chart at the beginning of this section for encoding data and limits.",
            "See “SGDT—Store Global Descriptor Table Register” in Chapter 4, Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for information on storing the contents of the GDTR and IDTR.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "mem.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/LGDT:LIDT.html"
        ]
    },
    "vmaxss": {
        "detail": [
            "Return Maximum Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Compares the low single-precision floating-point values in the first source operand and the second source operand, and returns the maximum value to the low doubleword of the destination operand.",
            "If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN from either source operand be returned, the action of MAXSS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.",
            "The second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL:32) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded version: The first source operand is an xmm register encoded by VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL:128) of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination operand is updated according to the writemask.",
            "Software should ensure VMAXSS is encoded with VEX.L=0. Encoding VMAXSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/MAXSS.html"
        ]
    },
    "repe lodsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.w, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "fcmovnu": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "documentation": [
            "Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Description column above and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).",
            "The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.",
            "A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “COMISS—Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS” in this chapter). If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCMOVcc.html"
        ]
    },
    "vpshldvd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpshldvq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpshldvw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "fsqrt": {
        "detail": [
            "Square Root"
        ],
        "documentation": [
            "Computes the square root of the source value in the ST(0) register and stores the result in ST(0).",
            "The following table shows the results obtained when taking the square root of various classes of numbers, assuming that neither overflow nor underflow occurs."
        ],
        "operands": [
            "reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FSQRT.html"
        ]
    },
    "vpmovd2m": {
        "detail": [
            "Convert a Vector Register to a Mask"
        ],
        "documentation": [
            "Converts a vector register to a mask register. Each element in the destination register is set to 1 or 0 depending on the value of most significant bit of the corresponding element in the source register.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a mask register.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVB2M:VPMOVW2M:VPMOVD2M:VPMOVQ2M.html"
        ]
    },
    "psubb": {
        "detail": [
            "Subtract Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.",
            "The (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.",
            "The (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.",
            "The (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.",
            "Note that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded VPSUBD: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "EVEX encoded VPSUBB/W: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html"
        ]
    },
    "psubd": {
        "detail": [
            "Subtract Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.",
            "The (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.",
            "The (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.",
            "The (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.",
            "Note that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded VPSUBD: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "EVEX encoded VPSUBB/W: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html"
        ]
    },
    "vcvtpd2ps": {
        "detail": [
            "Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Converts two, four or eight packed double-precision floating-point values in the source operand (second operand) to two, four or eight packed single-precision floating-point values in the destination operand (first operand).",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits.",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM/XMM/XMM (low 64-bits) register conditionally updated with writemask k1. The upper bits (MAXVL-1:256/128/64) of the corresponding destination are zeroed.",
            "VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:64) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.y, reg.q, mem.z",
            "reg.y, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTPD2PS.html"
        ]
    },
    "vpmulhw": {
        "detail": [
            "Multiply Packed Signed Integers and Store High Result"
        ],
        "documentation": [
            "Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each intermediate 32-bit result in the destination operand. (Figure 4-12 shows this operation when using 64-bit operands.)",
            "n 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMULHW.html"
        ]
    },
    "monitor": {
        "detail": [
            "Set Up Monitor Address"
        ],
        "documentation": [
            "The MONITOR instruction arms address monitoring hardware using an address specified in EAX (the address range that the monitoring hardware checks for store operations can be determined by using CPUID). A store to an address within the specified address range triggers the monitoring hardware. The state of monitor hardware is used by MWAIT.",
            "The address is specified in RAX/EAX/AX and the size is based on the effective address size of the encoded instruction. By default, the DS segment is used to create a linear address that is monitored. Segment overrides can be used.",
            "ECX and EDX are also used. They communicate other information to MONITOR. ECX specifies optional extensions. EDX specifies optional hints; it does not change the architectural behavior of the instruction. For the Pentium 4 processor (family 15, model 3), no extensions or hints are defined. Undefined hints in EDX are ignored by the processor; undefined extensions in ECX raises a general protection fault.",
            "The address range must use memory of the write-back type. Only write-back memory will correctly trigger the monitoring hardware. Additional information on determining what address range to use in order to prevent false wake-ups is described in Chapter 8, “Multiple-Processor Management” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.",
            "The MONITOR instruction is ordered as a load operation with respect to other memory transactions. The instruction is subject to the permission checking and faults associated with a byte load. Like a load, MONITOR sets the A-bit but not the D-bit in page tables.",
            "CPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and MWAIT in the processor. When set, MONITOR may be executed only at privilege level 0 (use at any other privilege level results in an invalid-opcode exception). The operating system or system BIOS may disable this instruction by using the IA32_MISC_ENABLE MSR; disabling MONITOR clears the CPUID feature flag and causes execution to generate an invalid-opcode exception.",
            "The instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/MONITOR.html"
        ]
    },
    "psubq": {
        "detail": [
            "Subtract Packed Quadword Integers"
        ],
        "documentation": [
            "Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. When packed quadword operands are used, a SIMD subtract is performed. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).",
            "Note that the (V)PSUBQ instruction can operate on either unsigned or signed (two’s complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values upon which it operates.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The source operand can be a quadword integer stored in an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded VPSUBQ: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBQ.html"
        ]
    },
    "sar": {
        "detail": [
            "Shift"
        ],
        "documentation": [
            "Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF flag, then discarded. At the end of the shift operation, the CF flag contains the last bit shifted out of the destination operand.",
            "The destination operand can be a register or a memory location. The count operand can be an immediate value or the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W is used). The count range is limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used). A special opcode encoding is provided for a count of 1.",
            "The shift arithmetic left (SAL) and shift logical left (SHL) instructions perform the same operation; they shift the bits in the destination operand to the left (toward more significant bit locations). For each shift count, the most significant bit of the destination operand is shifted into the CF flag, and the least significant bit is cleared (see Figure 7-7 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1).",
            "The shift arithmetic right (SAR) and shift logical right (SHR) instructions shift the bits of the destination operand to the right (toward less significant bit locations). For each shift count, the least significant bit of the destination operand is shifted into the CF flag, and the most significant bit is either set or cleared depending on the instruction type. The SHR instruction clears the most significant bit (see Figure 7-8 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1); the SAR instruction sets or clears the most significant bit to correspond to the sign (most significant bit) of the original value in the destination operand. In effect, the SAR instruction fills the empty bit position’s shifted value with the sign of the unshifted value (see Figure 7-9 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1).",
            "The SAR and SHR instructions can be used to perform signed or unsigned division, respectively, of the destination operand by powers of 2. For example, using the SAR instruction to shift a signed integer 1 bit to the right divides the value by 2.",
            "Using the SAR instruction to perform a division operation does not produce the same result as the IDIV instruction. The quotient from the IDIV instruction is rounded toward zero, whereas the “quotient” of the SAR instruction is rounded toward negative infinity. This difference is apparent only for negative numbers. For example, when the IDIV instruction is used to divide -9 by 4, the result is -2 with a remainder of -1. If the SAR instruction is used to shift -9 right by two bits, the result is -3 and the “remainder” is +3; however, the SAR instruction stores only the most significant bit of the remainder (in the CF flag).",
            "The OF flag is affected only on 1-bit shifts. For left shifts, the OF flag is set to 0 if the most-significant bit of the result is the same as the CF flag (that is, the top two bits of the original operand were the same); otherwise, it is set to 1. For the SAR instruction, the OF flag is cleared for all 1-bit shifts. For the SHR instruction, the OF flag is set to the most-significant bit of the original operand.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits and the mask width for CL is 5 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64-bits and sets the mask width for CL to 6 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The CF flag contains the value of the last bit shifted out of the destination operand; it is undefined for SHL and SHR instructions where the count is greater than or equal to the size (in bits) of the destination operand. The OF flag is affected only for 1-bit shifts (see “Description” above); otherwise, it is undefined. The SF, ZF, and PF flags are set according to the result. If the count is 0, the flags are not affected. For a non-zero count, the AF flag is undefined."
        ],
        "operands": [
            "mem.b, imm.b",
            "reg.b, reg",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/SAL:SAR:SHL:SHR.html"
        ]
    },
    "psubw": {
        "detail": [
            "Subtract Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.",
            "The (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.",
            "The (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.",
            "The (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.",
            "Note that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded VPSUBD: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "EVEX encoded VPSUBB/W: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html"
        ]
    },
    "vpmovsqb": {
        "detail": [
            "Down Convert QWord to Byte"
        ],
        "documentation": [
            "VPMOVQB down converts 64-bit integer elements in the source operand (the second operand) into packed byte elements using truncation. VPMOVSQB converts signed 64-bit integers into packed signed bytes using signed saturation. VPMOVUSQB convert unsigned quad-word values into unsigned byte values using unsigned saturation. The source operand is a vector register. The destination operand is an XMM register or a memory location.",
            "Down-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:64) of the destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.z",
            "mem.q, reg.q, reg.z",
            "mem.q, reg.z",
            "reg.x, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVQB:VPMOVSQB:VPMOVUSQB.html"
        ]
    },
    "vextracti64x2": {
        "detail": [
            "Extract packed Integer Values"
        ],
        "documentation": [
            "VEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of doubleword integer values from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand). The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor. The destination may be either a vector register or an 128-bit memory location.",
            "VEXTRACTI32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the writemask.",
            "VEXTRACTI64x2: The low 128-bit of the destination operand is updated at 64-bit granularity according to the writemask.",
            "VEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of quadword integer values from the source operand (the second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor The destination may be either a vector register or a 256-bit memory location.",
            "VEXTRACTI32x8: The low 256-bit of the destination operand is updated at 32-bit granularity according to the writemask.",
            "VEXTRACTI64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the writemask.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "The high 7 bits (6 bits in EVEX.512) of the immediate are ignored.",
            "If VEXTRACTI128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "mem.x, reg.q, reg.y, imm.b",
            "reg.x, reg.y, imm.b",
            "reg.x, reg.q, reg.y, imm.b",
            "mem.x, reg.y, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html"
        ]
    },
    "vpmovsqd": {
        "detail": [
            "Down Convert QWord to DWord"
        ],
        "documentation": [
            "VPMOVQW down converts 64-bit integer elements in the source operand (the second operand) into packed double-words using truncation. VPMOVSQW converts signed 64-bit integers into packed signed doublewords using signed saturation. VPMOVUSQW convert unsigned quad-word values into unsigned double-word values using unsigned saturation.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.",
            "Down-converted doubleword elements are written to the destination operand (the first operand) from the least-significant doubleword. Doubleword elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.y, reg.z",
            "mem.y, reg.q, reg.z",
            "mem.y, reg.z",
            "reg.y, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVQD:VPMOVSQD:VPMOVUSQD.html"
        ]
    },
    "vextracti64x4": {
        "detail": [
            "Extract packed Integer Values"
        ],
        "documentation": [
            "VEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of doubleword integer values from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand). The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor. The destination may be either a vector register or an 128-bit memory location.",
            "VEXTRACTI32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the writemask.",
            "VEXTRACTI64x2: The low 128-bit of the destination operand is updated at 64-bit granularity according to the writemask.",
            "VEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of quadword integer values from the source operand (the second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor The destination may be either a vector register or a 256-bit memory location.",
            "VEXTRACTI32x8: The low 256-bit of the destination operand is updated at 32-bit granularity according to the writemask.",
            "VEXTRACTI64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the writemask.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "The high 7 bits (6 bits in EVEX.512) of the immediate are ignored.",
            "If VEXTRACTI128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "mem.y, reg.q, reg.z, imm.b",
            "reg.y, reg.z, imm.b",
            "reg.y, reg.q, reg.z, imm.b",
            "mem.y, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html"
        ]
    },
    "vmovmskpd": {
        "detail": [
            "Extract Packed Double-Precision Floating-Point Sign Mask"
        ],
        "documentation": [
            "Extracts the sign bits from the packed double-precision floating-point values in the source operand (second operand), formats them into a 2-bit mask, and stores the mask in the destination operand (first operand). The source operand is an XMM register, and the destination operand is a general-purpose register. The mask is stored in the 2 low-order bits of the destination operand. Zero-extend the upper bits of the destination.",
            "In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.",
            "128-bit versions: The source operand is a YMM register. The destination operand is a general purpose register.",
            "VEX.256 encoded version: The source operand is a YMM register. The destination operand is a general purpose register.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.d, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVMSKPD.html"
        ]
    },
    "vaesdeclast": {
        "detail": [
            "Perform Last Round of an AES Decryption Flow"
        ],
        "documentation": [
            "This instruction performs the last round of the AES decryption flow using the Equivalent Inverse Cipher, with the round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and store the result in the destination operand.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/AESDECLAST.html"
        ]
    },
    "vfmadd231pd": {
        "detail": [
            "Fused Multiply-Add of Packed Double- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a set of SIMD multiply-add computation on packed double-precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.",
            "VFMADD132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source operand to the two, four or eight packed double-precision floating-point values in the third source operand, adds the infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMADD213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source operand to the two, four or eight packed double-precision floating-point values in the first source operand, adds the infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMADD231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source to the two, four or eight packed double-precision floating-point values in the third source operand, adds the infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) is a ZMM register and encoded in reg_field. The second source operand is a ZMM register and encoded in EVEX.vvvv. The third source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADD132PD:VFMADD213PD:VFMADD231PD.html"
        ]
    },
    "pabsb": {
        "detail": [
            "Packed Absolute Value"
        ],
        "documentation": [
            "PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and stores the UNSIGNED results in the destination operand (the first operand). PABSB operates on signed bytes, PABSW operates on signed 16-bit words, and PABSD operates on signed 32-bit integers.",
            "EVEX encoded VPABSD/Q: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "EVEX encoded VPABSB/W: The source operand is a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded versions: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding register destination are zeroed.",
            "VEX.128 encoded versions: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand can be an XMM register or an 128-bit memory location. The destination is an XMM register. The upper bits (VL_MAX-1:128) of the corresponding register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PABSB:PABSW:PABSD:PABSQ.html"
        ]
    },
    "pabsd": {
        "detail": [
            "Packed Absolute Value"
        ],
        "documentation": [
            "PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and stores the UNSIGNED results in the destination operand (the first operand). PABSB operates on signed bytes, PABSW operates on signed 16-bit words, and PABSD operates on signed 32-bit integers.",
            "EVEX encoded VPABSD/Q: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "EVEX encoded VPABSB/W: The source operand is a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded versions: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding register destination are zeroed.",
            "VEX.128 encoded versions: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand can be an XMM register or an 128-bit memory location. The destination is an XMM register. The upper bits (VL_MAX-1:128) of the corresponding register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PABSB:PABSW:PABSD:PABSQ.html"
        ]
    },
    "vpmovsqw": {
        "detail": [
            "Down Convert QWord to Word"
        ],
        "documentation": [
            "VPMOVQW down converts 64-bit integer elements in the source operand (the second operand) into packed words using truncation. VPMOVSQW converts signed 64-bit integers into packed signed words using signed saturation. VPMOVUSQW convert unsigned quad-word values into unsigned word values using unsigned saturation.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit memory location.",
            "Down-converted word elements are written to the destination operand (the first operand) from the least-significant word. Word elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:128/64/32) of the register destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.z",
            "mem.x, reg.q, reg.z",
            "mem.x, reg.z",
            "reg.x, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVQW:VPMOVSQW:VPMOVUSQW.html"
        ]
    },
    "vmovmskps": {
        "detail": [
            "Extract Packed Single-Precision Floating-Point Sign Mask"
        ],
        "documentation": [
            "Extracts the sign bits from the packed single-precision floating-point values in the source operand (second operand), formats them into a 4- or 8-bit mask, and stores the mask in the destination operand (first operand). The source operand is an XMM or YMM register, and the destination operand is a general-purpose register. The mask is stored in the 4 or 8 low-order bits of the destination operand. The upper bits of the destination operand beyond the mask are filled with zeros.",
            "In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.",
            "128-bit versions: The source operand is a YMM register. The destination operand is a general purpose register.",
            "VEX.256 encoded version: The source operand is a YMM register. The destination operand is a general purpose register.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.d, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVMSKPS.html"
        ]
    },
    "vcvtusi2sd": {
        "detail": [
            "Convert Unsigned Integer to Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Converts an unsigned doubleword integer (or unsigned quadword integer if operand size is 64 bits) in the second source operand to a double-precision floating-point value in the destination operand. The result is stored in the low quadword of the destination operand. When conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.",
            "The second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and destination operands are XMM registers. Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX.W1 version: promotes the instruction to use 64-bit input value in 64-bit mode.",
            "EVEX.W0 version: attempt to encode this instruction with EVEX embedded rounding is ignored."
        ],
        "operands": [
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTUSI2SD.html"
        ]
    },
    "stgi": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "vfmadd231ps": {
        "detail": [
            "Fused Multiply-Add of Packed Single- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a set of SIMD multiply-add computation on packed single-precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.",
            "VFMADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the first source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting the four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) is a ZMM register and encoded in reg_field. The second source operand is a ZMM register and encoded in EVEX.vvvv. The third source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADD132PS:VFMADD213PS:VFMADD231PS.html"
        ]
    },
    "vfmaddsubpd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "repe xsha1": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg.q, reg, mem.b, mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vrcpss": {
        "detail": [
            "Compute Reciprocal of Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Computes of an approximate reciprocal of the low single-precision floating-point value in the source operand (second operand) and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a scalar single-precision floating-point operation.",
            "The relative error for this approximation is:",
            "|Relative Error| ≤ 1.5 ∗ 2−12",
            "The RCPSS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). Tiny results (see Section 4.9.1.5, “Numeric Underflow Exception (#U)” in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1) are always flushed to 0.0, with the sign of the operand. (Input values greater than or equal to |1.11111111110100000000000B∗2125| are guaranteed to not produce tiny results; input values less than or equal to |1.00000000000110000000001B*2126| are guaranteed to produce tiny results, which are in turn flushed to 0.0; and input values in between this range may or may not produce tiny results, depending on the implementation.) When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/RCPSS.html"
        ]
    },
    "vcvtpd2qq": {
        "detail": [
            "Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers"
        ],
        "documentation": [
            "Converts packed double-precision floating-point values in the source operand (second operand) to packed quadword integers in the destination operand (first operand).",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTPD2QQ.html"
        ]
    },
    "pabsw": {
        "detail": [
            "Packed Absolute Value"
        ],
        "documentation": [
            "PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and stores the UNSIGNED results in the destination operand (the first operand). PABSB operates on signed bytes, PABSW operates on signed 16-bit words, and PABSD operates on signed 32-bit integers.",
            "EVEX encoded VPABSD/Q: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "EVEX encoded VPABSB/W: The source operand is a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded versions: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding register destination are zeroed.",
            "VEX.128 encoded versions: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand can be an XMM register or an 128-bit memory location. The destination is an XMM register. The upper bits (VL_MAX-1:128) of the corresponding register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PABSB:PABSW:PABSD:PABSQ.html"
        ]
    },
    "sbb": {
        "detail": [
            "Integer Subtraction with Borrow"
        ],
        "documentation": [
            "Adds the source operand (second operand) and the carry (CF) flag, and subtracts the result from the destination operand (first operand). The result of the subtraction is stored in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a borrow from a previous subtraction.",
            "When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.",
            "The SBB instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a borrow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.",
            "The SBB instruction is usually executed as part of a multibyte or multiword subtraction in which a SUB instruction is followed by a SBB instruction.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF, SF, ZF, AF, PF, and CF flags are set according to the result."
        ],
        "operands": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SBB.html"
        ]
    },
    "fincstp": {
        "detail": [
            "Increment Stack-Top Pointer"
        ],
        "documentation": [
            "Adds one to the TOP field of the FPU status word (increments the top-of-stack pointer). If the TOP field contains a 7, it is set to 0. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected. This operation is not equivalent to popping the stack, because the tag for the previous top-of-stack register is not marked empty.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FINCSTP.html"
        ]
    },
    "gf2p8mulb": {
        "detail": [
            "Galois Field Multiply Bytes"
        ],
        "documentation": [
            "The instruction multiplies elements in the finite field GF(28), operating on a byte (field element) in the first source operand and the corresponding byte in a second source operand. The field GF(28) is represented in polynomial representation with the reduction polynomial x8 + x4 + x3 + x + 1.",
            "This instruction does not support broadcasting.",
            "The SSE encoded forms of the instruction require16B alignment on their memory operations."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/GF2P8MULB.html"
        ]
    },
    "vcvtusi2ss": {
        "detail": [
            "Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Converts a unsigned doubleword integer (or unsigned quadword integer if operand size is 64 bits) in the source operand (second operand) to a single-precision floating-point value in the destination operand (first operand). The source operand can be a general-purpose register or a memory location. The destination operand is an XMM register. The result is stored in the low doubleword of the destination operand. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits.",
            "The second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and destination operands are XMM registers. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX.W1 version: promotes the instruction to use 64-bit input value in 64-bit mode."
        ],
        "operands": [
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTUSI2SS.html"
        ]
    },
    "vphadduwq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vphadduwd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vfmaddsubps": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vstmxcsr": {
        "detail": [
            "Store MXCSR Register State"
        ],
        "documentation": [
            "Stores the contents of the MXCSR control and status register to the destination operand. The destination operand is a 32-bit memory location. The reserved bits in the MXCSR register are stored as 0s.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
            "VEX.L must be 0, otherwise instructions will #UD.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/STMXCSR.html"
        ]
    },
    "aesenclast": {
        "detail": [
            "Perform Last Round of an AES Encryption Flow"
        ],
        "documentation": [
            "This instruction performs the last round of an AES encryption flow using a round key from the second source operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination operand.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/AESENCLAST.html"
        ]
    },
    "kandnd": {
        "detail": [
            "Bitwise Logical AND NOT Masks"
        ],
        "documentation": [
            "Performs a bitwise AND NOT between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KANDNW:KANDNB:KANDNQ:KANDND.html"
        ]
    },
    "kandnb": {
        "detail": [
            "Bitwise Logical AND NOT Masks"
        ],
        "documentation": [
            "Performs a bitwise AND NOT between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KANDNW:KANDNB:KANDNQ:KANDND.html"
        ]
    },
    "vpshlb": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "paddsb": {
        "detail": [
            "Add Packed Signed Integers with Signed Saturation"
        ],
        "documentation": [
            "Performs a SIMD add of the packed signed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following paragraphs.",
            "(V)PADDSB performs a SIMD add of the packed signed integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.",
            "(V)PADDSW performs a SIMD add of the packed signed word integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.",
            "EVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an ZMM/YMM/XMM register or a memory location. The destination operand is an ZMM/YMM/XMM register.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDSB:PADDSW.html"
        ]
    },
    "cmovb": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "addsd": {
        "detail": [
            "Add Scalar Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Adds the low double-precision floating-point values from the second source operand and the first source operand and stores the double-precision floating-point result in the destination operand.",
            "The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.",
            "EVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX version: The low quadword element of the destination is updated according to the writemask.",
            "Software should ensure VADDSD is encoded with VEX.L=0. Encoding VADDSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADDSD.html"
        ]
    },
    "pfnacc": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vpshld": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "lock sub": {
        "detail": [
            "Subtract"
        ],
        "documentation": [
            "Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, register, or memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.",
            "The SUB instruction performs integer subtraction. It evaluates the result for both signed and unsigned integer operands and sets the OF and CF flags to indicate an overflow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "Flags Affected:",
            "The OF, SF, ZF, AF, PF, and CF flags are set according to the result."
        ],
        "operands": [
            "mem.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SUB.html"
        ]
    },
    "kandnq": {
        "detail": [
            "Bitwise Logical AND NOT Masks"
        ],
        "documentation": [
            "Performs a bitwise AND NOT between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KANDNW:KANDNB:KANDNQ:KANDND.html"
        ]
    },
    "cmovl": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "cmovo": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "kandnw": {
        "detail": [
            "Bitwise Logical AND NOT Masks"
        ],
        "documentation": [
            "Performs a bitwise AND NOT between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KANDNW:KANDNB:KANDNQ:KANDND.html"
        ]
    },
    "cmovp": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "addss": {
        "detail": [
            "Add Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Adds the low single-precision floating-point values from the second source operand and the first source operand, and stores the double-precision floating-point result in the destination operand.",
            "The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAXVL-1:32) of the corresponding the destination register remain unchanged.",
            "EVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX version: The low doubleword element of the destination is updated according to the writemask.",
            "Software should ensure VADDSS is encoded with VEX.L=0. Encoding VADDSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADDSS.html"
        ]
    },
    "cmovs": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "cvtpd2pi": {
        "detail": [
            "Convert Packed Double-Precision FP Values to Packed Dword Integers"
        ],
        "documentation": [
            "Converts two packed double-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand).",
            "The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.",
            "This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPD2PI instruction is executed.",
            "In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15)."
        ],
        "operands": [
            "reg.q, mem.x",
            "reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTPD2PI.html"
        ]
    },
    "push": {
        "detail": [
            "Push Word, Doubleword or Quadword Onto the Stack"
        ],
        "documentation": [
            "Decrements the stack pointer and then stores the source operand on the top of the stack. Address and operand sizes are determined and used as follows:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.w, reg.q, mem.w",
            "reg.w, reg.q, mem.w",
            "imm.d, reg.q, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUSH.html"
        ]
    },
    "paddsw": {
        "detail": [
            "Add Packed Signed Integers with Signed Saturation"
        ],
        "documentation": [
            "Performs a SIMD add of the packed signed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following paragraphs.",
            "(V)PADDSB performs a SIMD add of the packed signed integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.",
            "(V)PADDSW performs a SIMD add of the packed signed word integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.",
            "EVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an ZMM/YMM/XMM register or a memory location. The destination operand is an ZMM/YMM/XMM register.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDSB:PADDSW.html"
        ]
    },
    "orpd": {
        "detail": [
            "Bitwise Logical OR of Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical OR of the two, four or eight packed double-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ORPD.html"
        ]
    },
    "rdtscp": {
        "detail": [
            "Read Time-Stamp Counter and Processor ID"
        ],
        "documentation": [
            "Reads the current value of the processor’s time-stamp counter (a 64-bit MSR) into the EDX:EAX registers and also reads the value of the IA32_TSC_AUX MSR (address C0000103H) into the ECX register. The EDX register is loaded with the high-order 32 bits of the IA32_TSC MSR; the EAX register is loaded with the low-order 32 bits of the IA32_TSC MSR; and the ECX register is loaded with the low-order 32-bits of IA32_TSC_AUX MSR. On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX, RDX, and RCX are cleared.",
            "The processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever the processor is reset. See “Time Stamp Counter” in Chapter 17 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B, for specific details of the time stamp counter behavior.",
            "The time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSCP instruction as follows. When the flag is clear, the RDTSCP instruction can be executed at any privilege level; when the flag is set, the instruction can only be executed at privilege level 0.",
            "The RDTSCP instruction is not a serializing instruction, but it does wait until all previous instructions have executed and all previous loads are globally visible.1 But it does not wait for previous stores to be globally visible, and subsequent instructions may begin execution before the read operation is performed. The following items may guide software seeking to order executions of RDTSCP:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg, reg, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/RDTSCP.html"
        ]
    },
    "cmovz": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "cvtpd2ps": {
        "detail": [
            "Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Converts two, four or eight packed double-precision floating-point values in the source operand (second operand) to two, four or eight packed single-precision floating-point values in the destination operand (first operand).",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits.",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM/XMM/XMM (low 64-bits) register conditionally updated with writemask k1. The upper bits (MAXVL-1:256/128/64) of the corresponding destination are zeroed.",
            "VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:64) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. Bits[127:64] of the destination XMM register are zeroed. However, the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTPD2PS.html"
        ]
    },
    "pfacc": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vrndscalepd": {
        "detail": [
            "Round Packed Float64 Values To Include A Given Number Of Fraction Bits"
        ],
        "documentation": [
            "Round the double-precision floating-point values in the source operand by the rounding mode specified in the immediate operand (see Figure 5-29) and places the result in the destination operand.",
            "The destination operand (the first operand) is a ZMM/YMM/XMM register conditionally updated according to the writemask. The source operand (the second operand) can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location.",
            "The rounding process rounds the input to an integral value, plus number bits of fraction that are specified by imm8[7:4] (to be included in the result) and returns the result as a double-precision floating-point value.",
            "It should be noticed that no overflow is induced while executing this instruction (although the source is scaled by the imm8[7:4] value).",
            "The immediate operand also specifies control fields for the rounding operation, three bit fields are defined and shown in the “Immediate Control Description” figure below. Bit 3 of the immediate byte controls the processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Immediate control table below lists the encoded values for rounding-mode field).",
            "The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.",
            "The sign of the result of this instruction is preserved, including the sign of zero.",
            "The formula of the operation on each data element for VRNDSCALEPD is",
            "ROUND(x) = 2-M*Round_to_INT(x*2M, round_ctrl),",
            "round_ctrl = imm[3:0];",
            "M=imm[7:4];",
            "The operation of x*2M is computed as if the exponent range is unlimited (i.e. no overflow ever occurs).",
            "VRNDSCALEPD is a more general form of the VEX-encoded VROUNDPD instruction. In VROUNDPD, the formula of the operation on each element is",
            "ROUND(x) = Round_to_INT(x, round_ctrl),",
            "round_ctrl = imm[3:0];",
            "Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRNDSCALEPD.html"
        ]
    },
    "kaddb": {
        "detail": [
            "ADD Two Masks"
        ],
        "documentation": [
            "Adds the vector mask k2 and the vector mask k3, and writes the result into vector mask k1."
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KADDW:KADDB:KADDQ:KADDD.html"
        ]
    },
    "kaddd": {
        "detail": [
            "ADD Two Masks"
        ],
        "documentation": [
            "Adds the vector mask k2 and the vector mask k3, and writes the result into vector mask k1."
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KADDW:KADDB:KADDQ:KADDD.html"
        ]
    },
    "vreducepd": {
        "detail": [
            "Perform Reduction Transformation on Packed Float64 Values"
        ],
        "documentation": [
            "Perform reduction transformation of the packed binary encoded double-precision FP values in the source operand (the second operand) and store the reduced results in binary FP format to the destination operand (the first operand) under the writemask k1.",
            "The reduction transformation subtracts the integer part and the leading M fractional bits from the binary FP source value, where M is a unsigned integer specified by imm8[7:4], see Figure 5-28. Specifically, the reduction transformation can be expressed as:",
            "dest = src – (ROUND(2M*src))*2-M;",
            "where “Round()” treats “src”, “2M”, and their product as binary FP numbers with normalized significand and biased exponents.",
            "The magnitude of the reduced result can be expressed by considering src= 2p*man2,",
            "where ‘man2’ is the normalized significand and ‘p’ is the unbiased exponent",
            "Then if RC = RNE: 0<=|Reduced Result|<=2p-M-1",
            "Then if RC ≠ RNE: 0<=|Reduced Result|<2p-M",
            "This instruction might end up with a precision exception set. However, in case of SPE set (i.e. Suppress Precision Exception, which is imm8[3]=1), no precision exception is reported.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.q, mem.x, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VREDUCEPD.html"
        ]
    },
    "wrmsr": {
        "detail": [
            "Write to Model Specific Register"
        ],
        "documentation": [
            "Writes the contents of registers EDX:EAX into the 64-bit model specific register (MSR) specified in the ECX register. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The contents of the EDX register are copied to high-order 32 bits of the selected MSR and the contents of the EAX register are copied to low-order 32 bits of the MSR. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are ignored.) Undefined or reserved bits in an MSR should be set to values previously read.",
            "This instruction must be executed at privilege level 0 or in real-address mode; otherwise, a general protection exception #GP(0) is generated. Specifying a reserved or unimplemented MSR address in ECX will also cause a general protection exception. The processor will also generate a general protection exception if software attempts to write to bits in a reserved MSR.",
            "When the WRMSR instruction is used to write to an MTRR, the TLBs are invalidated. This includes global entries (see “Translation Lookaside Buffers (TLBs)” in Chapter 3 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A).",
            "MSRs control functions for testability, execution tracing, performance-monitoring and machine check errors. Chapter 2, “Model-Specific Registers (MSRs)” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 4, lists all MSRs that can be written with this instruction and their addresses. Note that each processor family has its own set of MSRs.",
            "The WRMSR instruction is a serializing instruction (see “Serializing Instructions” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A). Note that WRMSR to the IA32_TSC_DEADLINE MSR (MSR index 6E0H) and the X2APIC MSRs (MSR indices 802H to 83FH) are not serializing.",
            "The CPUID instruction should be used to determine whether MSRs are supported (CPUID.01H:EDX[5] = 1) before using this instruction.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/WRMSR.html"
        ]
    },
    "or": {
        "detail": [
            "Logical Inclusive OR"
        ],
        "documentation": [
            "Performs a bitwise inclusive OR operation between the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result of the OR instruction is set to 0 if both corresponding bits of the first and second operands are 0; otherwise, each bit is set to 1.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined."
        ],
        "operands": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/OR.html"
        ]
    },
    "vfmsubadd213pd": {
        "detail": [
            "Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFMSUBADD132PD: Multiplies the two, four, or eight packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the even double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMSUBADD213PD: Multiplies the two, four, or eight packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the even double-precision floating-point values in the third source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMSUBADD231PD: Multiplies the two, four, or eight packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the even double-precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUBADD132PD:VFMSUBADD213PD:VFMSUBADD231PD.html"
        ]
    },
    "movlhps": {
        "detail": [
            "Move Packed Single-Precision Floating-Point Values Low to High"
        ],
        "documentation": [
            "This instruction cannot be used for memory to register moves.",
            "128-bit two-argument form:",
            "Moves two packed single-precision floating-point values from the low quadword of the second XMM argument (second operand) to the high quadword of the first XMM register (first argument). The low quadword of the destination operand is left unchanged. Bits (MAXVL-1:128) of the corresponding destination register are unmodified.",
            "128-bit three-argument forms:",
            "Moves two packed single-precision floating-point values from the low quadword of the third XMM argument (third operand) to the high quadword of the destination (first operand). Copies the low quadword from the second XMM argument (second operand) to the low quadword of the destination (first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "If VMOVLHPS is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVLHPS.html"
        ]
    },
    "vpshlw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "orps": {
        "detail": [
            "Bitwise Logical OR of Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical OR of the four, eight or sixteen packed single-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ORPS.html"
        ]
    },
    "vrndscaleps": {
        "detail": [
            "Round Packed Float32 Values To Include A Given Number Of Fraction Bits"
        ],
        "documentation": [
            "Round the single-precision floating-point values in the source operand by the rounding mode specified in the immediate operand (see Figure 5-29) and places the result in the destination operand.",
            "The destination operand (the first operand) is a ZMM register conditionally updated according to the writemask. The source operand (the second operand) can be a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location.",
            "The rounding process rounds the input to an integral value, plus number bits of fraction that are specified by imm8[7:4] (to be included in the result) and returns the result as a single-precision floating-point value.",
            "It should be noticed that no overflow is induced while executing this instruction (although the source is scaled by the imm8[7:4] value).",
            "The immediate operand also specifies control fields for the rounding operation, three bit fields are defined and shown in the “Immediate Control Description” figure below. Bit 3 of the immediate byte controls the processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Immediate control table below lists the encoded values for rounding-mode field).",
            "The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.",
            "The sign of the result of this instruction is preserved, including the sign of zero.",
            "The formula of the operation on each data element for VRNDSCALEPS is",
            "ROUND(x) = 2-M*Round_to_INT(x*2M, round_ctrl),",
            "round_ctrl = imm[3:0];",
            "M=imm[7:4];",
            "The operation of x*2M is computed as if the exponent range is unlimited (i.e. no overflow ever occurs).",
            "VRNDSCALEPS is a more general form of the VEX-encoded VROUNDPS instruction. In VROUNDPS, the formula of the operation on each element is",
            "ROUND(x) = Round_to_INT(x, round_ctrl),",
            "round_ctrl = imm[3:0];",
            "Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
            "Handling of special case of input values are listed in Table 5-25."
        ],
        "operands": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRNDSCALEPS.html"
        ]
    },
    "popfq": {
        "detail": [
            "Pop Stack into EFLAGS Register"
        ],
        "documentation": [
            "Pops a doubleword (POPFD) from the top of the stack (if the current operand-size attribute is 32) and stores the value in the EFLAGS register, or pops a word from the top of the stack (if the operand-size attribute is 16) and stores it in the lower 16 bits of the EFLAGS register (that is, the FLAGS register). These instructions reverse the operation of the PUSHF/PUSHFD/PUSHFQ instructions.",
            "The POPF (pop flags) and POPFD (pop flags double) mnemonics reference the same opcode. The POPF instruction is intended for use when the operand-size attribute is 16; the POPFD instruction is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size to 16 for POPF and to 32 for POPFD. Others may treat the mnemonics as synonyms (POPF/POPFD) and use the setting of the operand-size attribute to determine the size of values to pop from the stack.",
            "The effect of POPF/POPFD on the EFLAGS register changes, depending on the mode of operation. See Table 4-15 and the key below for details.",
            "When operating in protected, compatibility, or 64-bit mode at privilege level 0 (or in real-address mode, the equivalent to privilege level 0), all non-reserved flags in the EFLAGS register except RF1, VIP, VIF, and VM may be modified. VIP, VIF and VM remain unaffected.",
            "Flags Affected:",
            "All flags may be affected; see the Operation section for details."
        ],
        "operands": [
            "reg.q, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/POPF:POPFD:POPFQ.html"
        ]
    },
    "kaddq": {
        "detail": [
            "ADD Two Masks"
        ],
        "documentation": [
            "Adds the vector mask k2 and the vector mask k3, and writes the result into vector mask k1."
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KADDW:KADDB:KADDQ:KADDD.html"
        ]
    },
    "vinserti32x4": {
        "detail": [
            "Insert Packed Integer Values"
        ],
        "documentation": [
            "VINSERTI32x4 and VINSERTI64x2 inserts 128-bits of packed integer values from the second source operand (the third operand) into the destination operand (the first operand) at an 128-bit granular offset multiplied by imm8[0] (256-bit) or imm8[1:0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit memory location. The high 6/7bits of the immediate are ignored. The destination operand is a ZMM/YMM register and updated at 32 and 64-bit granularity according to the writemask.",
            "VINSERTI32x8 and VINSERTI64x4 inserts 256-bits of packed integer values from the second source operand (the third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an YMM register or a 256-bit memory location. The upper bits of the immediate are ignored. The destination operand is a ZMM register and updated at 32 and 64-bit granularity according to the writemask.",
            "VINSERTI128 inserts 128-bits of packed integer data from the second source operand (the third operand) into the destination operand (the first operand) at a 128-bit granular offset multiplied by imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit memory location. The high 7 bits of the immediate are ignored. VEX.L must be 1, otherwise attempt to execute this instruction with VEX.L=0 will cause #UD."
        ],
        "operands": [
            "reg.z, reg.z, mem.x, imm.b",
            "reg.z, reg.q, reg.z, reg.x, imm.b",
            "reg.z, reg.q, reg.z, mem.x, imm.b",
            "reg.z, reg.z, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VINSERTI128:VINSERTI32x4:VINSERTI64x2:VINSERTI32x8:VINSERTI64x4.html"
        ]
    },
    "vreduceps": {
        "detail": [
            "Perform Reduction Transformation on Packed Float32 Values"
        ],
        "documentation": [
            "Perform reduction transformation of the packed binary encoded single-precision FP values in the source operand (the second operand) and store the reduced results in binary FP format to the destination operand (the first operand) under the writemask k1.",
            "The reduction transformation subtracts the integer part and the leading M fractional bits from the binary FP source value, where M is a unsigned integer specified by imm8[7:4], see Figure 5-28. Specifically, the reduction transformation can be expressed as:",
            "dest = src – (ROUND(2M*src))*2-M;",
            "where “Round()” treats “src”, “2M”, and their product as binary FP numbers with normalized significand and biased exponents.",
            "The magnitude of the reduced result can be expressed by considering src= 2p*man2,",
            "where ‘man2’ is the normalized significand and ‘p’ is the unbiased exponent",
            "Then if RC = RNE: 0<=|Reduced Result|<=2p-M-1",
            "Then if RC ≠ RNE: 0<=|Reduced Result|<2p-M",
            "This instruction might end up with a precision exception set. However, in case of SPE set (i.e. Suppress Precision Exception, which is imm8[3]=1), no precision exception is reported.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "Handling of special case of input values are listed in Table 5-24."
        ],
        "operands": [
            "reg.x, reg.q, mem.x, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VREDUCEPS.html"
        ]
    },
    "vandnpd": {
        "detail": [
            "Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical AND NOT of the two, four or eight packed double-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ANDNPD.html"
        ]
    },
    "kaddw": {
        "detail": [
            "ADD Two Masks"
        ],
        "documentation": [
            "Adds the vector mask k2 and the vector mask k3, and writes the result into vector mask k1."
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KADDW:KADDB:KADDQ:KADDD.html"
        ]
    },
    "vfmsubadd213ps": {
        "detail": [
            "Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFMSUBADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the corresponding packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements and adds the even single-precision floating-point values in the second source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMSUBADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the corresponding packed single-precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements and adds the even single-precision floating-point values in the third source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMSUBADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the corresponding packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements and adds the even single-precision floating-point values in the first source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUBADD132PS:VFMSUBADD213PS:VFMSUBADD231PS.html"
        ]
    },
    "vinserti32x8": {
        "detail": [
            "Insert Packed Integer Values"
        ],
        "documentation": [
            "VINSERTI32x4 and VINSERTI64x2 inserts 128-bits of packed integer values from the second source operand (the third operand) into the destination operand (the first operand) at an 128-bit granular offset multiplied by imm8[0] (256-bit) or imm8[1:0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit memory location. The high 6/7bits of the immediate are ignored. The destination operand is a ZMM/YMM register and updated at 32 and 64-bit granularity according to the writemask.",
            "VINSERTI32x8 and VINSERTI64x4 inserts 256-bits of packed integer values from the second source operand (the third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an YMM register or a 256-bit memory location. The upper bits of the immediate are ignored. The destination operand is a ZMM register and updated at 32 and 64-bit granularity according to the writemask.",
            "VINSERTI128 inserts 128-bits of packed integer data from the second source operand (the third operand) into the destination operand (the first operand) at a 128-bit granular offset multiplied by imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit memory location. The high 7 bits of the immediate are ignored. VEX.L must be 1, otherwise attempt to execute this instruction with VEX.L=0 will cause #UD."
        ],
        "operands": [
            "reg.z, reg.z, mem.y, imm.b",
            "reg.z, reg.q, reg.z, reg.y, imm.b",
            "reg.z, reg.q, reg.z, mem.y, imm.b",
            "reg.z, reg.z, reg.y, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VINSERTI128:VINSERTI32x4:VINSERTI64x2:VINSERTI32x8:VINSERTI64x4.html"
        ]
    },
    "popfw": {
        "detail": [
            "Pop Stack into EFLAGS Register"
        ],
        "documentation": [
            "Pops a doubleword (POPFD) from the top of the stack (if the current operand-size attribute is 32) and stores the value in the EFLAGS register, or pops a word from the top of the stack (if the operand-size attribute is 16) and stores it in the lower 16 bits of the EFLAGS register (that is, the FLAGS register). These instructions reverse the operation of the PUSHF/PUSHFD/PUSHFQ instructions.",
            "The POPF (pop flags) and POPFD (pop flags double) mnemonics reference the same opcode. The POPF instruction is intended for use when the operand-size attribute is 16; the POPFD instruction is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size to 16 for POPF and to 32 for POPFD. Others may treat the mnemonics as synonyms (POPF/POPFD) and use the setting of the operand-size attribute to determine the size of values to pop from the stack.",
            "The effect of POPF/POPFD on the EFLAGS register changes, depending on the mode of operation. See Table 4-15 and the key below for details.",
            "When operating in protected, compatibility, or 64-bit mode at privilege level 0 (or in real-address mode, the equivalent to privilege level 0), all non-reserved flags in the EFLAGS register except RF1, VIP, VIF, and VM may be modified. VIP, VIF and VM remain unaffected.",
            "Flags Affected:",
            "All flags may be affected; see the Operation section for details."
        ],
        "operands": [
            "reg.q, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/POPF:POPFD:POPFQ.html"
        ]
    },
    "vpshlq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vmresume": {
        "detail": [
            "Launch/Resume Virtual Machine"
        ],
        "documentation": [
            "Effects a VM entry managed by the current VMCS.",
            "Flags Affected:",
            "See the operation section and Section 30.2."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/VMLAUNCH:VMRESUME.html"
        ]
    },
    "movmskpd": {
        "detail": [
            "Extract Packed Double-Precision Floating-Point Sign Mask"
        ],
        "documentation": [
            "Extracts the sign bits from the packed double-precision floating-point values in the source operand (second operand), formats them into a 2-bit mask, and stores the mask in the destination operand (first operand). The source operand is an XMM register, and the destination operand is a general-purpose register. The mask is stored in the 2 low-order bits of the destination operand. Zero-extend the upper bits of the destination.",
            "In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.",
            "128-bit versions: The source operand is a YMM register. The destination operand is a general purpose register.",
            "VEX.256 encoded version: The source operand is a YMM register. The destination operand is a general purpose register.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.d, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVMSKPD.html"
        ]
    },
    "vandnps": {
        "detail": [
            "Bitwise Logical AND NOT of Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical AND NOT of the four, eight or sixteen packed single-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ANDNPS.html"
        ]
    },
    "fsincos": {
        "detail": [
            "Sine and Cosine"
        ],
        "documentation": [
            "Computes both the approximate sine and the cosine of the source operand in register ST(0), stores the sine in ST(0), and pushes the cosine onto the top of the FPU register stack. (This instruction is faster than executing the FSIN and FCOS instructions in succession.)",
            "The source operand must be given in radians and must be within the range −263 to +263. The following table shows the results obtained when taking the sine and cosine of various classes of numbers, assuming that underflow does not occur."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FSINCOS.html"
        ]
    },
    "vpsravd": {
        "detail": [
            "Variable Bit Shift Right Arithmetic"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (word/doublewords/quadword) in the first source operand (the second operand) to the right by the number of bits specified in the count value of respective data elements in the second source operand (the third operand). As the bits in the data elements are shifted right, the empty high-order bits are set to the MSB (sign extension).",
            "The count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination data element is filled with the corresponding sign bit of the source element.",
            "VEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX.512/256/128 encoded VPSRAVD/W: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.",
            "EVEX.512/256/128 encoded VPSRAVQ: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is conditionally updated with writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPSRAVW:VPSRAVD:VPSRAVQ.html"
        ]
    },
    "fldpi": {
        "detail": [
            "Load Constant"
        ],
        "documentation": [
            "Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, π, log102, and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.",
            "See the section titled “Approximation of Pi” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a description of the π constant.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FLD1:FLDL2T:FLDL2E:FLDPI:FLDLG2:FLDLN2:FLDZ.html"
        ]
    },
    "movmskps": {
        "detail": [
            "Extract Packed Single-Precision Floating-Point Sign Mask"
        ],
        "documentation": [
            "Extracts the sign bits from the packed single-precision floating-point values in the source operand (second operand), formats them into a 4- or 8-bit mask, and stores the mask in the destination operand (first operand). The source operand is an XMM or YMM register, and the destination operand is a general-purpose register. The mask is stored in the 4 or 8 low-order bits of the destination operand. The upper bits of the destination operand beyond the mask are filled with zeros.",
            "In 64-bit mode, the instruction can access additional registers (XMM8-XMM15, R8-R15) when used with a REX.R prefix. The default operand size is 64-bit in 64-bit mode.",
            "128-bit versions: The source operand is a YMM register. The destination operand is a general purpose register.",
            "VEX.256 encoded version: The source operand is a YMM register. The destination operand is a general purpose register.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.d, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVMSKPS.html"
        ]
    },
    "fbld": {
        "detail": [
            "Load Binary Coded Decimal"
        ],
        "documentation": [
            "Converts the BCD source operand into double extended-precision floating-point format and pushes the value onto the FPU stack. The source operand is loaded without rounding errors. The sign of the source operand is preserved, including that of −0.",
            "The packed BCD digits are assumed to be in the range 0 through 9; the instruction does not check for invalid digits (AH through FH). Attempting to load an invalid encoding produces an undefined result.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, mem.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FBLD.html"
        ]
    },
    "vfmadd132pd": {
        "detail": [
            "Fused Multiply-Add of Packed Double- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a set of SIMD multiply-add computation on packed double-precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.",
            "VFMADD132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source operand to the two, four or eight packed double-precision floating-point values in the third source operand, adds the infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMADD213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source operand to the two, four or eight packed double-precision floating-point values in the first source operand, adds the infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMADD231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source to the two, four or eight packed double-precision floating-point values in the third source operand, adds the infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) is a ZMM register and encoded in reg_field. The second source operand is a ZMM register and encoded in EVEX.vvvv. The third source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADD132PD:VFMADD213PD:VFMADD231PD.html"
        ]
    },
    "vcvttss2usi": {
        "detail": [
            "Convert with Truncation Scalar Single-Precision Floating-Point Value to Unsigned Integer"
        ],
        "documentation": [
            "Converts with truncation a single-precision floating-point value in the source operand (the second operand) to an unsigned doubleword integer (or unsigned quadword integer if operand size is 64 bits) in the destination operand (the first operand). The source operand can be an XMM register or a memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w – 1 is returned, where w represents the number of bits in the destination format.",
            "EVEX.W1 version: promotes the instruction to produce 64-bit data in 64-bit mode.",
            "Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTTSS2USI.html"
        ]
    },
    "vpsravq": {
        "detail": [
            "Variable Bit Shift Right Arithmetic"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (word/doublewords/quadword) in the first source operand (the second operand) to the right by the number of bits specified in the count value of respective data elements in the second source operand (the third operand). As the bits in the data elements are shifted right, the empty high-order bits are set to the MSB (sign extension).",
            "The count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination data element is filled with the corresponding sign bit of the source element.",
            "VEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX.512/256/128 encoded VPSRAVD/W: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.",
            "EVEX.512/256/128 encoded VPSRAVQ: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is conditionally updated with writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPSRAVW:VPSRAVD:VPSRAVQ.html"
        ]
    },
    "vpsravw": {
        "detail": [
            "Variable Bit Shift Right Arithmetic"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (word/doublewords/quadword) in the first source operand (the second operand) to the right by the number of bits specified in the count value of respective data elements in the second source operand (the third operand). As the bits in the data elements are shifted right, the empty high-order bits are set to the MSB (sign extension).",
            "The count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination data element is filled with the corresponding sign bit of the source element.",
            "VEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX.512/256/128 encoded VPSRAVD/W: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.",
            "EVEX.512/256/128 encoded VPSRAVQ: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is conditionally updated with writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPSRAVW:VPSRAVD:VPSRAVQ.html"
        ]
    },
    "pfadd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "phsubsw": {
        "detail": [
            "Packed Horizontal Subtract and Saturate"
        ],
        "documentation": [
            "(V)PHSUBSW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands. The signed, saturated 16-bit results are packed to the destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "In 64-bit mode, use the REX prefix to access additional registers.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.",
            "Note: VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PHSUBSW.html"
        ]
    },
    "aesdecwide256kl": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.z, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vfmadd132ps": {
        "detail": [
            "Fused Multiply-Add of Packed Single- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a set of SIMD multiply-add computation on packed single-precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.",
            "VFMADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the first source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting the four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand, adds the infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) is a ZMM register and encoded in reg_field. The second source operand is a ZMM register and encoded in EVEX.vvvv. The third source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADD132PS:VFMADD213PS:VFMADD231PS.html"
        ]
    },
    "ktestb": {
        "detail": [
            "Packed Bit Test Masks and Set Flags"
        ],
        "documentation": [
            "Performs a bitwise comparison of the bits of the first source operand and corresponding bits in the second source operand. If the AND operation produces all zeros, the ZF is set else the ZF is clear. If the bitwise AND operation of the inverted first source operand with the second source operand produces all zeros the CF is set else the CF is clear. Only the EFLAGS register is updated.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KTESTW:KTESTB:KTESTQ:KTESTD.html"
        ]
    },
    "ktestd": {
        "detail": [
            "Packed Bit Test Masks and Set Flags"
        ],
        "documentation": [
            "Performs a bitwise comparison of the bits of the first source operand and corresponding bits in the second source operand. If the AND operation produces all zeros, the ZF is set else the ZF is clear. If the bitwise AND operation of the inverted first source operand with the second source operand produces all zeros the CF is set else the CF is clear. Only the EFLAGS register is updated.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KTESTW:KTESTB:KTESTQ:KTESTD.html"
        ]
    },
    "paddusb": {
        "detail": [
            "Add Packed Unsigned Integers with Unsigned Saturation"
        ],
        "documentation": [
            "Performs a SIMD add of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs.",
            "(V)PADDUSB performs a SIMD add of the packed unsigned integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual byte result is beyond the range of an unsigned byte integer (that is, greater than FFH), the saturated value of FFH is written to the destination operand.",
            "(V)PADDUSW performs a SIMD add of the packed unsigned word integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual word result is beyond the range of an unsigned word integer (that is, greater than FFFFH), the saturated value of FFFFH is written to the destination operand.",
            "EVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination is an ZMM/YMM/XMM register.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding destination register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDUSB:PADDUSW.html"
        ]
    },
    "lgdt": {
        "detail": [
            "Load Global/Interrupt Descriptor Table Register"
        ],
        "documentation": [
            "Loads the values in the source operand into the global descriptor table register (GDTR) or the interrupt descriptor table register (IDTR). The source operand specifies a 6-byte memory location that contains the base address (a linear address) and the limit (size of table in bytes) of the global descriptor table (GDT) or the interrupt descriptor table (IDT). If operand-size attribute is 32 bits, a 16-bit limit (lower 2 bytes of the 6-byte data operand) and a 32-bit base address (upper 4 bytes of the data operand) are loaded into the register. If the operand-size attribute is 16 bits, a 16-bit limit (lower 2 bytes) and a 24-bit base address (third, fourth, and fifth byte) are loaded. Here, the high-order byte of the operand is not used and the high-order byte of the base address in the GDTR or IDTR is filled with zeros.",
            "The LGDT and LIDT instructions are used only in operating-system software; they are not used in application programs. They are the only instructions that directly load a linear address (that is, not a segment-relative address) and a limit in protected mode. They are commonly executed in real-address mode to allow processor initialization prior to switching to protected mode.",
            "In 64-bit mode, the instruction’s operand size is fixed at 8+2 bytes (an 8-byte base and a 2-byte limit). See the summary chart at the beginning of this section for encoding data and limits.",
            "See “SGDT—Store Global Descriptor Table Register” in Chapter 4, Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for information on storing the contents of the GDTR and IDTR.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "mem.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/LGDT:LIDT.html"
        ]
    },
    "ktestq": {
        "detail": [
            "Packed Bit Test Masks and Set Flags"
        ],
        "documentation": [
            "Performs a bitwise comparison of the bits of the first source operand and corresponding bits in the second source operand. If the AND operation produces all zeros, the ZF is set else the ZF is clear. If the bitwise AND operation of the inverted first source operand with the second source operand produces all zeros the CF is set else the CF is clear. Only the EFLAGS register is updated.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KTESTW:KTESTB:KTESTQ:KTESTD.html"
        ]
    },
    "bzhi": {
        "detail": [
            "Zero High Bits Starting with Specified Bit Position"
        ],
        "documentation": [
            "BZHI copies the bits of the first source operand (the second operand) into the destination operand (the first operand) and clears the higher bits in the destination according to the INDEX value specified by the second source operand (the third operand). The INDEX is specified by bits 7:0 of the second source operand. The INDEX value is saturated at the value of OperandSize -1. CF is set, if the number contained in the 8 low bits of the third operand is greater than OperandSize -1.",
            "This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
            "Flags Affected:",
            "ZF, CF and SF flags are updated based on the result. OF flag is cleared. AF and PF flags are undefined."
        ],
        "operands": [
            "reg.d, mem.d, reg.d",
            "reg.d, reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/BZHI.html"
        ]
    },
    "ktestw": {
        "detail": [
            "Packed Bit Test Masks and Set Flags"
        ],
        "documentation": [
            "Performs a bitwise comparison of the bits of the first source operand and corresponding bits in the second source operand. If the AND operation produces all zeros, the ZF is set else the ZF is clear. If the bitwise AND operation of the inverted first source operand with the second source operand produces all zeros the CF is set else the CF is clear. Only the EFLAGS register is updated.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KTESTW:KTESTB:KTESTQ:KTESTD.html"
        ]
    },
    "paddusw": {
        "detail": [
            "Add Packed Unsigned Integers with Unsigned Saturation"
        ],
        "documentation": [
            "Performs a SIMD add of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs.",
            "(V)PADDUSB performs a SIMD add of the packed unsigned integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual byte result is beyond the range of an unsigned byte integer (that is, greater than FFH), the saturated value of FFH is written to the destination operand.",
            "(V)PADDUSW performs a SIMD add of the packed unsigned word integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual word result is beyond the range of an unsigned word integer (that is, greater than FFFFH), the saturated value of FFFFH is written to the destination operand.",
            "EVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination is an ZMM/YMM/XMM register.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding destination register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDUSB:PADDUSW.html"
        ]
    },
    "lock cmpxchg8b": {
        "detail": [
            "Compare and Exchange Bytes"
        ],
        "documentation": [
            "Compares the 64-bit value in EDX:EAX (or 128-bit value in RDX:RAX if operand size is 128 bits) with the operand (destination operand). If the values are equal, the 64-bit value in ECX:EBX (or 128-bit value in RCX:RBX) is stored in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX (or RDX:RAX). The destination operand is an 8-byte memory location (or 16-byte memory location if operand size is 128 bits). For the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the low-order 32 bits of a 64-bit value. For the RDX:RAX and RCX:RBX register pairs, RDX and RCX contain the high-order 64 bits and RAX and RBX contain the low-order 64bits of a 128-bit value.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor’s bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)",
            "In 64-bit mode, default operation size is 64 bits. Use of the REX.W prefix promotes operation to 128 bits. Note that CMPXCHG16B requires that the destination (memory) operand be 16-byte aligned. See the summary chart at the beginning of this section for encoding data and limits. For information on the CPUID flag that indicates CMPXCHG16B, see page 3-213.",
            "Flags Affected:",
            "The ZF flag is set if the destination operand and EDX:EAX are equal; otherwise it is cleared. The CF, PF, AF, SF, and OF flags are unaffected."
        ],
        "operands": [
            "mem.q, reg, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPXCHG8B:CMPXCHG16B.html"
        ]
    },
    "rex64 xstore": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.b, reg, reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "pclmulqdq": {
        "detail": [
            "Carry-Less Multiplication Quadword"
        ],
        "documentation": [
            "Performs a carry-less multiplication of two quadwords, selected from the first source and second source operand according to the value of the immediate byte. Bits 4 and 0 are used to select which 64-bit half of each operand to use according to Table 4-13, other bits of the immediate byte are ignored."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCLMULQDQ.html"
        ]
    },
    "vbroadcastf32x2": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "documentation": [
            "VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).",
            "VEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4 load floating-point values as tuples from the source operand (the second operand) in memory or register and broadcast to all elements of the destination operand (the first operand). The destination operand is a YMM/ZMM register updated according to the writemask k1. The source operand is either a register or 64-bit/128-bit/256-bit memory location.",
            "VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as 256-bit and 512-bit wide versions and up. VBROADCASTSS is supported in 128-bit, 256-bit and 512-bit wide versions. F32x8 and F64x4 are only supported as 512-bit wide versions.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32-bit granularity. VBROADCASTF64X2 and VBROADCASTF64X4 have 64-bit granularity.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.y, mem.q",
            "reg.y, reg.x",
            "reg.y, reg.q, mem.q",
            "reg.y, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBROADCAST.html"
        ]
    },
    "vbroadcastf32x4": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "documentation": [
            "VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).",
            "VEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4 load floating-point values as tuples from the source operand (the second operand) in memory or register and broadcast to all elements of the destination operand (the first operand). The destination operand is a YMM/ZMM register updated according to the writemask k1. The source operand is either a register or 64-bit/128-bit/256-bit memory location.",
            "VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as 256-bit and 512-bit wide versions and up. VBROADCASTSS is supported in 128-bit, 256-bit and 512-bit wide versions. F32x8 and F64x4 are only supported as 512-bit wide versions.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32-bit granularity. VBROADCASTF64X2 and VBROADCASTF64X4 have 64-bit granularity.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.z, mem.x",
            "reg.z, reg.q, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBROADCAST.html"
        ]
    },
    "aesimc": {
        "detail": [
            "Perform the AES InvMixColumn Transformation"
        ],
        "documentation": [
            "Perform the InvMixColumns transformation on the source operand and store the result in the destination operand. The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.",
            "Note: the AESIMC instruction should be applied to the expanded AES round keys (except for the first and last round key) in order to prepare them for decryption using the “Equivalent Inverse Cipher” (defined in FIPS 197).",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/AESIMC.html"
        ]
    },
    "vbroadcastf32x8": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "documentation": [
            "VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).",
            "VEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4 load floating-point values as tuples from the source operand (the second operand) in memory or register and broadcast to all elements of the destination operand (the first operand). The destination operand is a YMM/ZMM register updated according to the writemask k1. The source operand is either a register or 64-bit/128-bit/256-bit memory location.",
            "VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as 256-bit and 512-bit wide versions and up. VBROADCASTSS is supported in 128-bit, 256-bit and 512-bit wide versions. F32x8 and F64x4 are only supported as 512-bit wide versions.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32-bit granularity. VBROADCASTF64X2 and VBROADCASTF64X4 have 64-bit granularity.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.z, mem.y",
            "reg.z, reg.q, mem.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBROADCAST.html"
        ]
    },
    "vfmadd231sd": {
        "detail": [
            "Fused Multiply-Add of Scalar Double- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD multiply-add computation on the low double-precision floating-point values using three source operands and writes the multiply-add result in the destination operand. The destination operand is also the first source operand. The first and second operand are XMM registers. The third source operand can be an XMM register or a 64-bit memory location.",
            "VFMADD132SD: Multiplies the low double-precision floating-point value from the first source operand to the low double-precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low double-precision floating-point values in the second source operand, performs rounding and stores the resulting double-precision floating-point value to the destination operand (first source operand).",
            "VFMADD213SD: Multiplies the low double-precision floating-point value from the second source operand to the low double-precision floating-point value in the first source operand, adds the infinite precision intermediate result to the low double-precision floating-point value in the third source operand, performs rounding and stores the resulting double-precision floating-point value to the destination operand (first source operand).",
            "VFMADD231SD: Multiplies the low double-precision floating-point value from the second source to the low double-precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low double-precision floating-point value in the first source operand, performs rounding and stores the resulting double-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination is updated according to the writemask."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADD132SD:VFMADD213SD:VFMADD231SD.html"
        ]
    },
    "vpmulld": {
        "detail": [
            "Multiply Packed Integers and Store Low Result"
        ],
        "documentation": [
            "Performs a SIMD signed multiply of the packed signed dword/qword integers from each element of the first source operand with the corresponding element in the second source operand. The low 32/64 bits of each 64/128-bit intermediate results are stored to the destination operand.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMULLD:PMULLQ.html"
        ]
    },
    "fcom": {
        "detail": [
            "Compare Floating Point Values"
        ],
        "documentation": [
            "Compares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below). The source operand can be a data register or a memory location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is ignored, so that –0.0 is equal to +0.0."
        ],
        "operands": [
            "reg.wq, mem.d, reg",
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCOM:FCOMP:FCOMPP.html"
        ]
    },
    "enterw": {
        "detail": [
            "Make Stack Frame for Procedure Parameters"
        ],
        "documentation": [
            "Creates a stack frame (comprising of space for dynamic storage and 1-32 frame pointer storage) for a procedure. The first operand (imm16) specifies the size of the dynamic storage in the stack frame (that is, the number of bytes of dynamically allocated on the stack for the procedure). The second operand (imm8) gives the lexical nesting level (0 to 31) of the procedure. The nesting level (imm8 mod 32) and the OperandSize attribute determine the size in bytes of the storage space for frame pointers.",
            "The nesting level determines the number of frame pointers that are copied into the “display area” of the new stack frame from the preceding frame. The default size of the frame pointer is the StackAddrSize attribute, but can be overridden using the 66H prefix. Thus, the OperandSize attribute determines the size of each frame pointer that will be copied into the stack frame and the data being transferred from SP/ESP/RSP register into the BP/EBP/RBP register.",
            "The ENTER and companion LEAVE instructions are provided to support block structured languages. The ENTER instruction (when used) is typically the first instruction in a procedure and is used to set up a new stack frame for a procedure. The LEAVE instruction is then used at the end of the procedure (just before the RET instruction) to release the stack frame.",
            "If the nesting level is 0, the processor pushes the frame pointer from the BP/EBP/RBP register onto the stack, copies the current stack pointer from the SP/ESP/RSP register into the BP/EBP/RBP register, and loads the SP/ESP/RSP register with the current stack-pointer value minus the value in the size operand. For nesting levels of 1 or greater, the processor pushes additional frame pointers on the stack before adjusting the stack pointer. These additional frame pointers provide the called procedure with access points to other nested frames on the stack. See “Procedure Calls for Block-Structured Languages” in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information about the actions of the ENTER instruction.",
            "The ENTER instruction causes a page fault whenever a write using the final value of the stack pointer (within the current stack segment) would do so.",
            "In 64-bit mode, default operation size is 64 bits; 32-bit operation size cannot be encoded. Use of 66H prefix changes frame pointer operand size to 16 bits.",
            "When the 66H prefix is used and causing the OperandSize attribute to be less than the StackAddrSize, software is responsible for the following:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "imm.w, imm.b, reg.q, reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/ENTER.html"
        ]
    },
    "fcos": {
        "detail": [
            "Cosine"
        ],
        "documentation": [
            "Computes the approximate cosine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range −263 to +263. The following table shows the results obtained when taking the cosine of various classes of numbers."
        ],
        "operands": [
            "reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCOS.html"
        ]
    },
    "vfmadd231ss": {
        "detail": [
            "Fused Multiply-Add of Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD multiply-add computation on single-precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The first and second operands are XMM registers. The third source operand can be a XMM register or a 32-bit memory location.",
            "VFMADD132SS: Multiplies the low single-precision floating-point value from the first source operand to the low single-precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low single-precision floating-point value in the second source operand, performs rounding and stores the resulting single-precision floating-point value to the destination operand (first source operand).",
            "VFMADD213SS: Multiplies the low single-precision floating-point value from the second source operand to the low single-precision floating-point value in the first source operand, adds the infinite precision intermediate result to the low single-precision floating-point value in the third source operand, performs rounding and stores the resulting single-precision floating-point value to the destination operand (first source operand).",
            "VFMADD231SS: Multiplies the low single-precision floating-point value from the second source operand to the low single-precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low single-precision floating-point value in the first source operand, performs rounding and stores the resulting single-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADD132SS:VFMADD213SS:VFMADD231SS.html"
        ]
    },
    "vpmovb2m": {
        "detail": [
            "Convert a Vector Register to a Mask"
        ],
        "documentation": [
            "Converts a vector register to a mask register. Each element in the destination register is set to 1 or 0 depending on the value of most significant bit of the corresponding element in the source register.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a mask register.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVB2M:VPMOVW2M:VPMOVD2M:VPMOVQ2M.html"
        ]
    },
    "fscale": {
        "detail": [
            "Scale"
        ],
        "documentation": [
            "Truncates the value in the source operand (toward 0) to an integral value and adds that value to the exponent of the destination operand. The destination and source operands are floating-point values located in registers ST(0) and ST(1), respectively. This instruction provides rapid multiplication or division by integral powers of 2. The following table shows the results obtained when scaling various classes of numbers, assuming that neither overflow nor underflow occurs."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FSCALE.html"
        ]
    },
    "vpmullq": {
        "detail": [
            "Multiply Packed Integers and Store Low Result"
        ],
        "documentation": [
            "Performs a SIMD signed multiply of the packed signed dword/qword integers from each element of the first source operand with the corresponding element in the second source operand. The low 32/64 bits of each 64/128-bit intermediate results are stored to the destination operand.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMULLD:PMULLQ.html"
        ]
    },
    "vpmullw": {
        "detail": [
            "Multiply Packed Signed Integers and Store Low Result"
        ],
        "documentation": [
            "Performs a SIMD signed multiply of the packed signed word integers in the destination operand (first operand) and the source operand (second operand), and stores the low 16 bits of each intermediate 32-bit result in the destination operand. (Figure 4-12 shows this operation when using 64-bit operands.)",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMULLW.html"
        ]
    },
    "rcl": {
        "detail": [
            "Rotate"
        ],
        "documentation": [
            "Shifts (rotates) the bits of the first operand (destination operand) the number of bit positions specified in the second operand (count operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the count operand is an unsigned integer that can be an immediate or a value in the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W = 1).",
            "The rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location.",
            "The RCL and RCR instructions include the CF flag in the rotation. The RCL instruction shifts the CF flag into the least-significant bit and shifts the most-significant bit into the CF flag. The RCR instruction shifts the CF flag into the most-significant bit and shifts the least-significant bit into the CF flag. For the ROL and ROR instructions, the original value of the CF flag is not a part of the result, but the CF flag receives a copy of the bit that was shifted from one end to the other.",
            "The OF flag is defined only for the 1-bit rotates; it is undefined in all other cases (except RCL and RCR instructions only: a zero-bit rotate does nothing, that is affects no flags). For left rotates, the OF flag is set to the exclusive OR of the CF bit (after the rotate) and the most-significant bit of the result. For right rotates, the OF flag is set to the exclusive OR of the two most-significant bits of the result.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Use of REX.W promotes the first operand to 64 bits and causes the count operand to become a 6-bit counter.",
            "Flags Affected:",
            "If the masked count is 0, the flags are not affected. If the masked count is 1, then the OF flag is affected, otherwise (masked count is greater than 1) the OF flag is undefined. The CF flag is affected when the masked count is nonzero. The SF, ZF, AF, and PF flags are always unaffected."
        ],
        "operands": [
            "mem.b, imm.b",
            "reg.b, reg",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/RCL:RCR:ROL:ROR.html"
        ]
    },
    "xor": {
        "detail": [
            "Logical Exclusive OR"
        ],
        "documentation": [
            "Performs a bitwise exclusive OR (XOR) operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is 1 if the corresponding bits of the operands are different; each bit is 0 if the corresponding bits are the same.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined."
        ],
        "operands": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/XOR.html"
        ]
    },
    "vp2intersectd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, reg.x, mem.x",
            "reg.q, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vfnmadd213pd": {
        "detail": [
            "Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMADD132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source operand to the two, four or eight packed double-precision floating-point values in the third source operand, adds the negated infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFNMADD213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source operand to the two, four or eight packed double-precision floating-point values in the first source operand, adds the negated infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFNMADD231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source to the two, four or eight packed double-precision floating-point values in the third source operand, the negated infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMADD132PD:VFNMADD213PD:VFNMADD231PD.html"
        ]
    },
    "prefetch": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.z"
        ],
        "url": [
            "https://"
        ]
    },
    "pavgusb": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "tdpbusd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, reg, reg"
        ],
        "url": [
            "https://"
        ]
    },
    "lwpval": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.d, imm.d",
            "reg.d, mem.d, imm.d"
        ],
        "url": [
            "https://"
        ]
    },
    "rcr": {
        "detail": [
            "Rotate"
        ],
        "documentation": [
            "Shifts (rotates) the bits of the first operand (destination operand) the number of bit positions specified in the second operand (count operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the count operand is an unsigned integer that can be an immediate or a value in the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W = 1).",
            "The rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location.",
            "The RCL and RCR instructions include the CF flag in the rotation. The RCL instruction shifts the CF flag into the least-significant bit and shifts the most-significant bit into the CF flag. The RCR instruction shifts the CF flag into the most-significant bit and shifts the least-significant bit into the CF flag. For the ROL and ROR instructions, the original value of the CF flag is not a part of the result, but the CF flag receives a copy of the bit that was shifted from one end to the other.",
            "The OF flag is defined only for the 1-bit rotates; it is undefined in all other cases (except RCL and RCR instructions only: a zero-bit rotate does nothing, that is affects no flags). For left rotates, the OF flag is set to the exclusive OR of the CF bit (after the rotate) and the most-significant bit of the result. For right rotates, the OF flag is set to the exclusive OR of the two most-significant bits of the result.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Use of REX.W promotes the first operand to 64 bits and causes the count operand to become a 6-bit counter.",
            "Flags Affected:",
            "If the masked count is 0, the flags are not affected. If the masked count is 1, then the OF flag is affected, otherwise (masked count is greater than 1) the OF flag is undefined. The CF flag is affected when the masked count is nonzero. The SF, ZF, AF, and PF flags are always unaffected."
        ],
        "operands": [
            "mem.b, imm.b",
            "reg.b, reg",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/RCL:RCR:ROL:ROR.html"
        ]
    },
    "vp2intersectq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, reg.x, mem.x",
            "reg.q, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "repe xstore": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.b, reg, reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vzeroupper": {
        "detail": [
            "Zero Upper Bits of YMM Registers"
        ],
        "documentation": [
            "The instruction zeros the bits in position 128 and higher of all YMM registers. The lower 128-bits of the registers (the corresponding XMM registers) are unmodified.",
            "This instruction is recommended when transitioning between AVX and legacy SSE code - it will eliminate performance penalties caused by false dependencies.",
            "Note: VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD. In Compatibility and legacy 32-bit mode only the lower 8 registers are modified."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/VZEROUPPER.html"
        ]
    },
    "vfnmadd213ps": {
        "detail": [
            "Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFNMADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the first source operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting the four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFNMADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMADD132PS:VFNMADD213PS:VFNMADD231PS.html"
        ]
    },
    "pmuludq": {
        "detail": [
            "Multiply Packed Unsigned Doubleword Integers"
        ],
        "documentation": [
            "Multiplies the first operand (destination operand) by the second operand (source operand) and stores the result in the destination operand.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The source operand can be an unsigned doubleword integer stored in the low doubleword of an MMX technology register or a 64-bit memory location. The destination operand can be an unsigned doubleword integer stored in the low doubleword an MMX technology register. The result is an unsigned",
            "quadword integer stored in the destination an MMX technology register. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).",
            "For 64-bit memory operands, 64 bits are fetched from memory, but only the low doubleword is used in the computation.",
            "128-bit Legacy SSE version: The second source operand is two packed unsigned doubleword integers stored in the first (low) and third doublewords of an XMM register or a 128-bit memory location. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation. The first source operand is two packed unsigned doubleword integers stored in the first and third doublewords of an XMM register. The destination contains two packed unsigned quadword integers stored in an XMM register. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is two packed unsigned doubleword integers stored in the first (low) and third doublewords of an XMM register or a 128-bit memory location. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation. The first source operand is two packed unsigned doubleword integers stored in the first and third doublewords of an XMM register. The destination contains two packed unsigned quadword integers stored in an XMM register. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The second source operand is four packed unsigned doubleword integers stored in the first (low), third, fifth and seventh doublewords of a YMM register or a 256-bit memory location. For 256-bit memory operands, 256 bits are fetched from memory, but only the first, third, fifth and seventh doublewords are used in the computation. The first source operand is four packed unsigned doubleword integers stored in the first, third, fifth and seventh doublewords of an YMM register. The destination contains four packed unaligned quadword integers stored in an YMM register.",
            "EVEX encoded version: The input unsigned doubleword integers are taken from the even-numbered elements of the source operands. The first source operand is a ZMM/YMM/XMM registers. The second source operand can be an ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination is a ZMM/YMM/XMM register, and updated according to the writemask at 64-bit granularity.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMULUDQ.html"
        ]
    },
    "vpperm": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vmovdqa": {
        "detail": [
            "Move Aligned Packed Integer Values"
        ],
        "documentation": [
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX encoded versions:",
            "Moves 128, 256 or 512 bits of packed doubleword/quadword integer values from the source operand (the second operand) to the destination operand (the first operand). This instruction can be used to load a vector register from an int32/int64 memory location, to store the contents of a vector register into an int32/int64 memory location, or to move data between two ZMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16 (EVEX.128)/32(EVEX.256)/64(EVEX.512)-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction.",
            "The destination operand is updated at 32-bit (VMOVDQA32) or 64-bit (VMOVDQA64) granularity according to the writemask.",
            "VEX.256 encoded version:",
            "Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.",
            "When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "128-bit versions:",
            "Moves 128 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.",
            "When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVDQA:VMOVDQA32:VMOVDQA64.html"
        ]
    },
    "vpunpcklqdq": {
        "detail": [
            "Unpack Low Data"
        ],
        "documentation": [
            "Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-22 shows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html"
        ]
    },
    "vfmsub213pd": {
        "detail": [
            "Fused Multiply-Subtract of Packed Double- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a set of SIMD multiply-subtract computation on packed double-precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.",
            "VFMSUB132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source operand to the two, four or eight packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMSUB213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source operand to the two, four or eight packed double-precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMSUB231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source to the two, four or eight packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUB132PD:VFMSUB213PD:VFMSUB231PD.html"
        ]
    },
    "vpermb": {
        "detail": [
            "Permute Packed Bytes Elements"
        ],
        "documentation": [
            "Copies bytes from the second source operand (the third operand) to the destination operand (the first operand) according to the byte indices in the first source operand (the second operand). Note that this instruction permits a byte in the source operand to be copied to more than one location in the destination operand.",
            "Only the low 6(EVEX.512)/5(EVEX.256)/4(EVEX.128) bits of each byte index is used to select the location of the source byte from the second source operand.",
            "The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated at byte granularity by the writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMB.html"
        ]
    },
    "repe cmpsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.b, mem.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vpermd": {
        "detail": [
            "Permute Packed Doublewords/Words Elements"
        ],
        "documentation": [
            "Copies doublewords (or words) from the second source operand (the third operand) to the destination operand (the first operand) according to the indices in the first source operand (the second operand). Note that this instruction permits a doubleword (word) in the source operand to be copied to more than one location in the destination operand.",
            "VEX.256 encoded VPERMD: The first and second operands are YMM registers, the third operand can be a YMM register or memory location. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded VPERMD: The first and second operands are ZMM/YMM registers, the third operand can be a ZMM/YMM register, a 512/256-bit memory location or a 512/256-bit vector broadcasted from a 32-bit memory location. The elements in the destination are updated using the writemask k1.",
            "VPERMW: first and second operands are ZMM/YMM/XMM registers, the third operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The destination is updated using the writemask k1.",
            "EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.y, reg.y, mem.y",
            "reg.y, reg.y, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMD:VPERMW.html"
        ]
    },
    "vrndscalesd": {
        "detail": [
            "Round Scalar Float64 Value To Include A Given Number Of Fraction Bits"
        ],
        "documentation": [
            "Rounds a double-precision floating-point value in the low quadword (see Figure 5-29) element of the second source operand (the third operand) by the rounding mode specified in the immediate operand and places the result in the corresponding element of the destination operand (the first operand) according to the writemask. The quadword element at bits 127:64 of the destination is copied from the first source operand (the second operand).",
            "The destination and first source operands are XMM registers, the 2nd source operand can be an XMM register or memory location. Bits MAXVL-1:128 of the destination register are cleared.",
            "The rounding process rounds the input to an integral value, plus number bits of fraction that are specified by imm8[7:4] (to be included in the result) and returns the result as a double-precision floating-point value.",
            "It should be noticed that no overflow is induced while executing this instruction (although the source is scaled by the imm8[7:4] value).",
            "The immediate operand also specifies control fields for the rounding operation, three bit fields are defined and shown in the “Immediate Control Description” figure below. Bit 3 of the immediate byte controls the processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Immediate control table below lists the encoded values for rounding-mode field).",
            "The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.",
            "The sign of the result of this instruction is preserved, including the sign of zero.",
            "The formula of the operation for VRNDSCALESD is",
            "ROUND(x) = 2-M*Round_to_INT(x*2M, round_ctrl),",
            "round_ctrl = imm[3:0];",
            "M=imm[7:4];",
            "The operation of x*2M is computed as if the exponent range is unlimited (i.e. no overflow ever occurs).",
            "VRNDSCALESD is a more general form of the VEX-encoded VROUNDSD instruction. In VROUNDSD, the formula of the operation is",
            "ROUND(x) = Round_to_INT(x, round_ctrl),",
            "round_ctrl = imm[3:0];",
            "EVEX encoded version: The source operand is a XMM register or a 64-bit memory location. The destination operand is a XMM register.",
            "Handling of special case of input values are listed in Table 5-25."
        ],
        "operands": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRNDSCALESD.html"
        ]
    },
    "vmovdqu": {
        "detail": [
            "Move Unaligned Packed Integer Values"
        ],
        "documentation": [
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX encoded versions:",
            "Moves 128, 256 or 512 bits of packed byte/word/doubleword/quadword integer values from the source operand (the second operand) to the destination operand (first operand). This instruction can be used to load a vector register from a memory location, to store the contents of a vector register into a memory location, or to move data between two vector registers.",
            "The destination operand is updated at 8-bit (VMOVDQU8), 16-bit (VMOVDQU16), 32-bit (VMOVDQU32), or 64-bit (VMOVDQU64) granularity according to the writemask.",
            "VEX.256 encoded version:",
            "Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.",
            "Bits (MAXVL-1:256) of the destination register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html"
        ]
    },
    "vpcomb": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "repe cmpsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.d, mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vreducesd": {
        "detail": [
            "Perform a Reduction Transformation on a Scalar Float64 Value"
        ],
        "documentation": [
            "Perform a reduction transformation of the binary encoded double-precision FP value in the low qword element of the second source operand (the third operand) and store the reduced result in binary FP format to the low qword element of the destination operand (the first operand) under the writemask k1. Bits 127:64 of the destination operand are copied from respective qword elements of the first source operand (the second operand).",
            "The reduction transformation subtracts the integer part and the leading M fractional bits from the binary FP source value, where M is a unsigned integer specified by imm8[7:4], see Figure 5-28. Specifically, the reduction transformation can be expressed as:",
            "dest = src – (ROUND(2M*src))*2-M;",
            "where “Round()” treats “src”, “2M”, and their product as binary FP numbers with normalized significand and biased exponents.",
            "The magnitude of the reduced result can be expressed by considering src= 2p*man2,",
            "where ‘man2’ is the normalized significand and ‘p’ is the unbiased exponent",
            "Then if RC = RNE: 0<=|Reduced Result|<=2p-M-1",
            "Then if RC ≠ RNE: 0<=|Reduced Result|<2p-M",
            "This instruction might end up with a precision exception set. However, in case of SPE set (i.e. Suppress Precision Exception, which is imm8[3]=1), no precision exception is reported.",
            "The operation is write masked.",
            "Handling of special case of input values are listed in Table 5-24."
        ],
        "operands": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VREDUCESD.html"
        ]
    },
    "vpcomd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "idiv": {
        "detail": [
            "Signed Divide"
        ],
        "documentation": [
            "Divides the (signed) value in the AX, DX:AX, or EDX:EAX (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, or EDX:EAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor).",
            "Non-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magnitude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is applied, the instruction divides the signed value in RDX:RAX by the source operand. RAX contains a 64-bit quotient; RDX contains a 64-bit remainder.",
            "See the summary chart at the beginning of this section for encoding data and limits. See Table 3-51.",
            "Flags Affected:",
            "The CF, OF, SF, ZF, AF, and PF flags are undefined."
        ],
        "operands": [
            "reg.b, reg",
            "reg.w, reg.w, reg.w",
            "mem.b, reg",
            "mem.w, reg.w, reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/IDIV.html"
        ]
    },
    "repe scasb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vfmsub213ps": {
        "detail": [
            "Fused Multiply-Subtract of Packed Single- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a set of SIMD multiply-subtract computation on packed single-precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.",
            "VFMSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUB132PS:VFMSUB213PS:VFMSUB231PS.html"
        ]
    },
    "vpermq": {
        "detail": [
            "Qwords Element Permutation"
        ],
        "documentation": [
            "The imm8 version: Copies quadwords from the source operand (the second operand) to the destination operand (the first operand) according to the indices specified by the immediate operand (the third operand). Each two-bit value in the immediate byte selects a qword element in the source operand.",
            "VEX version: The source operand can be a YMM register or a memory location. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "In EVEX.512 encoded version, The elements in the destination are updated using the writemask k1 and the imm8 bits are reused as control bits for the upper 256-bit half when the control bits are coming from immediate. The source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location.",
            "Immediate control versions: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "The vector control version: Copies quadwords from the second source operand (the third operand) to the destination operand (the first operand) according to the indices in the first source operand (the second operand). The first 3 bits of each 64 bit element in the index operand selects which quadword in the second source operand to copy. The first and second operands are ZMM registers, the third operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The elements in the destination are updated using the writemask k1.",
            "Note that this instruction permits a qword in the source operand to be copied to multiple locations in the destination operand.",
            "If VPERMPQ is encoded with VEX.L= 0 or EVEX.128, an attempt to execute the instruction will cause an #UD exception."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.y, reg.y, imm.b",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.y, mem.y, imm.b",
            "reg.z, reg.z, reg.z",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMQ.html"
        ]
    },
    "vpmovusdb": {
        "detail": [
            "Down Convert DWord to Byte"
        ],
        "documentation": [
            "VPMOVDB down converts 32-bit integer elements in the source operand (the second operand) into packed bytes using truncation. VPMOVSDB converts signed 32-bit integers into packed signed bytes using signed saturation. VPMOVUSDB convert unsigned double-word values into unsigned byte values using unsigned saturation.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit memory location.",
            "Down-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:128/64/32) of the register destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.z",
            "mem.x, reg.q, reg.z",
            "mem.x, reg.z",
            "reg.x, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVDB:VPMOVSDB:VPMOVUSDB.html"
        ]
    },
    "vptestnmb": {
        "detail": [
            "Logical NAND and Set"
        ],
        "documentation": [
            "Performs a bitwise logical NAND operation on the byte/word/doubleword/quadword element of the first source operand (the second operand) with the corresponding element of the second source operand (the third operand) and stores the logical comparison result into each bit of the destination operand (the first operand) according to the writemask k1. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second src operands is zero; otherwise it is set to 0.",
            "EVEX encoded VPTESTNMD/Q: The first source operand is a ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination is updated according to the writemask.",
            "EVEX encoded VPTESTNMB/W: The first source operand is a ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the writemask."
        ],
        "operands": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.q, reg.x, mem.x",
            "reg.q, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPTESTNMB:VPTESTNMW:VPTESTNMD:VPTESTNMQ.html"
        ]
    },
    "vrndscaless": {
        "detail": [
            "Round Scalar Float32 Value To Include A Given Number Of Fraction Bits"
        ],
        "documentation": [
            "Rounds the single-precision floating-point value in the low doubleword element of the second source operand (the third operand) by the rounding mode specified in the immediate operand (see Figure 5-29) and places the result in the corresponding element of the destination operand (the first operand) according to the writemask. The double-word elements at bits 127:32 of the destination are copied from the first source operand (the second operand).",
            "The destination and first source operands are XMM registers, the 2nd source operand can be an XMM register or memory location. Bits MAXVL-1:128 of the destination register are cleared.",
            "The rounding process rounds the input to an integral value, plus number bits of fraction that are specified by imm8[7:4] (to be included in the result) and returns the result as a single-precision floating-point value.",
            "It should be noticed that no overflow is induced while executing this instruction (although the source is scaled by the imm8[7:4] value).",
            "The immediate operand also specifies control fields for the rounding operation, three bit fields are defined and shown in the “Immediate Control Description” figure below. Bit 3 of the immediate byte controls the processor behavior for a precision exception, bit 2 selects the source of rounding mode control. Bits 1:0 specify a non-sticky rounding-mode value (Immediate control tables below lists the encoded values for rounding-mode field).",
            "The Precision Floating-Point Exception is signaled according to the immediate operand. If any source operand is an SNaN then it will be converted to a QNaN. If DAZ is set to ‘1 then denormals will be converted to zero before rounding.",
            "The sign of the result of this instruction is preserved, including the sign of zero.",
            "The formula of the operation for VRNDSCALESS is",
            "ROUND(x) = 2-M*Round_to_INT(x*2M, round_ctrl),",
            "round_ctrl = imm[3:0];",
            "M=imm[7:4];",
            "The operation of x*2M is computed as if the exponent range is unlimited (i.e. no overflow ever occurs).",
            "VRNDSCALESS is a more general form of the VEX-encoded VROUNDSS instruction. In VROUNDSS, the formula of the operation on each element is",
            "ROUND(x) = Round_to_INT(x, round_ctrl),",
            "round_ctrl = imm[3:0];",
            "EVEX encoded version: The source operand is a XMM register or a 32-bit memory location. The destination operand is a XMM register.",
            "Handling of special case of input values are listed in Table 5-25."
        ],
        "operands": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRNDSCALESS.html"
        ]
    },
    "vptestnmd": {
        "detail": [
            "Logical NAND and Set"
        ],
        "documentation": [
            "Performs a bitwise logical NAND operation on the byte/word/doubleword/quadword element of the first source operand (the second operand) with the corresponding element of the second source operand (the third operand) and stores the logical comparison result into each bit of the destination operand (the first operand) according to the writemask k1. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second src operands is zero; otherwise it is set to 0.",
            "EVEX encoded VPTESTNMD/Q: The first source operand is a ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination is updated according to the writemask.",
            "EVEX encoded VPTESTNMB/W: The first source operand is a ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the writemask."
        ],
        "operands": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.q, reg.z, mem.z",
            "reg.q, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPTESTNMB:VPTESTNMW:VPTESTNMD:VPTESTNMQ.html"
        ]
    },
    "repe scasd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vpermw": {
        "detail": [
            "Permute Packed Doublewords/Words Elements"
        ],
        "documentation": [
            "Copies doublewords (or words) from the second source operand (the third operand) to the destination operand (the first operand) according to the indices in the first source operand (the second operand). Note that this instruction permits a doubleword (word) in the source operand to be copied to more than one location in the destination operand.",
            "VEX.256 encoded VPERMD: The first and second operands are YMM registers, the third operand can be a YMM register or memory location. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded VPERMD: The first and second operands are ZMM/YMM registers, the third operand can be a ZMM/YMM register, a 512/256-bit memory location or a 512/256-bit vector broadcasted from a 32-bit memory location. The elements in the destination are updated using the writemask k1.",
            "VPERMW: first and second operands are ZMM/YMM/XMM registers, the third operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The destination is updated using the writemask k1.",
            "EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMD:VPERMW.html"
        ]
    },
    "vreducess": {
        "detail": [
            "Perform a Reduction Transformation on a Scalar Float32 Value"
        ],
        "documentation": [
            "Perform a reduction transformation of the binary encoded single-precision FP value in the low dword element of the second source operand (the third operand) and store the reduced result in binary FP format to the low dword element of the destination operand (the first operand) under the writemask k1. Bits 127:32 of the destination operand are copied from respective dword elements of the first source operand (the second operand).",
            "The reduction transformation subtracts the integer part and the leading M fractional bits from the binary FP source value, where M is a unsigned integer specified by imm8[7:4], see Figure 5-28. Specifically, the reduction transformation can be expressed as:",
            "dest = src – (ROUND(2M*src))*2-M;",
            "where “Round()” treats “src”, “2M”, and their product as binary FP numbers with normalized significand and biased exponents.",
            "The magnitude of the reduced result can be expressed by considering src= 2p*man2,",
            "where ‘man2’ is the normalized significand and ‘p’ is the unbiased exponent",
            "Then if RC = RNE: 0<=|Reduced Result|<=2p-M-1",
            "Then if RC ≠ RNE: 0<=|Reduced Result|<2p-M",
            "This instruction might end up with a precision exception set. However, in case of SPE set (i.e. Suppress Precision Exception, which is imm8[3]=1), no precision exception is reported.",
            "Handling of special case of input values are listed in Table 5-24."
        ],
        "operands": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VREDUCESS.html"
        ]
    },
    "repe cmpsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.w, mem.w, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "psrldq": {
        "detail": [
            "Shift Double Quadword Right Logical"
        ],
        "documentation": [
            "Shifts the destination operand (first operand) to the right by the number of bytes specified in the count operand (second operand). The empty high-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The source and destination operands are the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The source and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The source operand is a YMM register. The destination operand is a YMM register. The count operand applies to both the low and high 128-bit lanes.",
            "VEX.256 encoded version: The source operand is YMM register. The destination operand is an YMM register. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed. The count operand applies to both the low and high 128-bit lanes.",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register. The count operand applies to each 128-bit lanes.",
            "Note: VEX.vvvv/EVEX.vvvv encodes the destination register.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSRLDQ.html"
        ]
    },
    "vpmacssdd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "repe cmpsq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.q, mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "psrad": {
        "detail": [
            "Shift Packed Data Right Arithmetic"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords or quadwords) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element. If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), each destination data element is filled with the initial value of the sign bit of the element. (Figure 4-18 gives an example of shifting words in a 64-bit operand.)",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html"
        ]
    },
    "repe scasq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vpcomq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "vpcomw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "psraw": {
        "detail": [
            "Shift Packed Data Right Arithmetic"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords or quadwords) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element. If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), each destination data element is filled with the initial value of the sign bit of the element. (Figure 4-18 gives an example of shifting words in a 64-bit operand.)",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html"
        ]
    },
    "vptestnmq": {
        "detail": [
            "Logical NAND and Set"
        ],
        "documentation": [
            "Performs a bitwise logical NAND operation on the byte/word/doubleword/quadword element of the first source operand (the second operand) with the corresponding element of the second source operand (the third operand) and stores the logical comparison result into each bit of the destination operand (the first operand) according to the writemask k1. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second src operands is zero; otherwise it is set to 0.",
            "EVEX encoded VPTESTNMD/Q: The first source operand is a ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination is updated according to the writemask.",
            "EVEX encoded VPTESTNMB/W: The first source operand is a ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the writemask."
        ],
        "operands": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.q, reg.z, mem.z",
            "reg.q, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPTESTNMB:VPTESTNMW:VPTESTNMD:VPTESTNMQ.html"
        ]
    },
    "repe scasw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.w, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vpmovusdw": {
        "detail": [
            "Down Convert DWord to Word"
        ],
        "documentation": [
            "VPMOVDW down converts 32-bit integer elements in the source operand (the second operand) into packed words using truncation. VPMOVSDW converts signed 32-bit integers into packed signed words using signed saturation. VPMOVUSDW convert unsigned double-word values into unsigned word values using unsigned saturation.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.",
            "Down-converted word elements are written to the destination operand (the first operand) from the least-significant word. Word elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.y, reg.z",
            "mem.y, reg.q, reg.z",
            "mem.y, reg.z",
            "reg.y, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVDW:VPMOVSDW:VPMOVUSDW.html"
        ]
    },
    "vptestnmw": {
        "detail": [
            "Logical NAND and Set"
        ],
        "documentation": [
            "Performs a bitwise logical NAND operation on the byte/word/doubleword/quadword element of the first source operand (the second operand) with the corresponding element of the second source operand (the third operand) and stores the logical comparison result into each bit of the destination operand (the first operand) according to the writemask k1. Each bit of the result is set to 1 if the bitwise AND of the corresponding elements of the first and second src operands is zero; otherwise it is set to 0.",
            "EVEX encoded VPTESTNMD/Q: The first source operand is a ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination is updated according to the writemask.",
            "EVEX encoded VPTESTNMB/W: The first source operand is a ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the writemask."
        ],
        "operands": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.q, reg.x, mem.x",
            "reg.q, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPTESTNMB:VPTESTNMW:VPTESTNMD:VPTESTNMQ.html"
        ]
    },
    "vshuff32x4": {
        "detail": [
            "Shuffle Packed Values at 128-bit Granularity"
        ],
        "documentation": [
            "256-bit Version: Moves one of the two 128-bit packed single-precision floating-point values from the first source operand (second operand) into the low 128-bit of the destination operand (first operand); moves one of the two packed 128-bit floating-point values from the second source operand (third operand) into the high 128-bit of the destination operand. The selector operand (third operand) determines which values are moved to the destination operand.",
            "512-bit Version: Moves two of the four 128-bit packed single-precision floating-point values from the first source operand (second operand) into the low 256-bit of each double qword of the destination operand (first operand); moves two of the four packed 128-bit floating-point values from the second source operand (third operand) into the high 256-bit of the destination operand. The selector operand (third operand) determines which values are moved to the destination operand.",
            "The first source operand is a vector register. The second source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a vector register.",
            "The writemask updates the destination operand with the granularity of 32/64-bit data elements."
        ],
        "operands": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSHUFF32x4:VSHUFF64x2:VSHUFI32x4:VSHUFI64x2.html"
        ]
    },
    "vmclear": {
        "detail": [
            "Clear Virtual-Machine Control Structure"
        ],
        "documentation": [
            "This instruction applies to the VMCS whose VMCS region resides at the physical address contained in the instruction operand. The instruction ensures that VMCS data for that VMCS (some of these data may be currently maintained on the processor) are copied to the VMCS region in memory. It also initializes parts of the VMCS region (for example, it sets the launch state of that VMCS to clear). See Chapter 24, “Virtual-Machine Control Structures”.",
            "The operand of this instruction is always 64 bits and is always in memory. If the operand is the current-VMCS pointer, then that pointer is made invalid (set to FFFFFFFF_FFFFFFFFH).",
            "Note that the VMCLEAR instruction might not explicitly write any VMCS data to memory; the data may be already resident in memory before the VMCLEAR is executed.",
            "Flags Affected:",
            "See the operation section and Section 30.2."
        ],
        "operands": [
            "mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VMCLEAR.html"
        ]
    },
    "crc32": {
        "detail": [
            "Accumulate CRC32 Value"
        ],
        "documentation": [
            "Starting with an initial value in the first operand (destination operand), accumulates a CRC32 (polynomial 11EDC6F41H) value for the second operand (source operand) and stores the result in the destination operand. The source operand can be a register or a memory location. The destination operand must be an r32 or r64 register. If the destination is an r64 register, then the 32-bit result is stored in the least significant double word and 00000000H is stored in the most significant double word of the r64 register.",
            "The initial value supplied in the destination operand is a double word integer stored in the r32 register or the least significant double word of the r64 register. To incrementally accumulate a CRC32 value, software retains the result of the previous CRC32 operation in the destination operand, then executes the CRC32 instruction again with new input data in the source operand. Data contained in the source operand is processed in reflected bit order. This means that the most significant bit of the source operand is treated as the least significant bit of the quotient, and so on, for all the bits of the source operand. Likewise, the result of the CRC operation is stored in the destination operand in reflected bit order. This means that the most significant bit of the resulting CRC (bit 31) is stored in the least significant bit of the destination operand (bit 0), and so on, for all the bits of the CRC.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.d, mem.b",
            "reg.d, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/CRC32.html"
        ]
    },
    "vpmacswd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "hsubpd": {
        "detail": [
            "Packed Double-FP Horizontal Subtract"
        ],
        "documentation": [
            "The HSUBPD instruction subtracts horizontally the packed DP FP numbers of both operands.",
            "Subtracts the double-precision floating-point value in the high quadword of the destination operand from the low quadword of the destination operand and stores the result in the low quadword of the destination operand.",
            "Subtracts the double-precision floating-point value in the high quadword of the source operand from the low quadword of the source operand and stores the result in the high quadword of the destination operand.",
            "In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
            "See Figure 3-20 for HSUBPD; see Figure 3-21 for VHSUBPD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/HSUBPD.html"
        ]
    },
    "vmread": {
        "detail": [
            "Read Field from Virtual-Machine Control Structure"
        ],
        "documentation": [
            "Reads a specified field from a VMCS and stores it into a specified destination operand (register or memory). In VMX root operation, the instruction reads from the current VMCS. If executed in VMX non-root operation, the instruction reads from the VMCS referenced by the VMCS link pointer field in the current VMCS.",
            "The VMCS field is specified by the VMCS-field encoding contained in the register source operand. Outside IA-32e mode, the source operand has 32 bits, regardless of the value of CS.D. In 64-bit mode, the source operand has 64 bits.",
            "The effective size of the destination operand, which may be a register or in memory, is always 32 bits outside IA-32e mode (the setting of CS.D is ignored with respect to operand size) and 64 bits in 64-bit mode. If the VMCS field specified by the source operand is shorter than this effective operand size, the high bits of the destination operand are cleared to 0. If the VMCS field is longer, then the high bits of the field are not read.",
            "Note that any faults resulting from accessing a memory destination operand can occur only after determining, in the operation section below, that the relevant VMCS pointer is valid and that the specified VMCS field is supported.",
            "Flags Affected:",
            "See the operation section and Section 30.2."
        ],
        "operands": [
            "reg.q, reg.q",
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VMREAD.html"
        ]
    },
    "tdcall": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "aesdec": {
        "detail": [
            "Perform One Round of an AES Decryption Flow"
        ],
        "documentation": [
            "This instruction performs a single round of the AES decryption flow using the Equivalent Inverse Cipher, with the round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and store the result in the destination operand.",
            "Use the AESDEC instruction for all but the last decryption round. For the last decryption round, use the AESDECLAST instruction.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/AESDEC.html"
        ]
    },
    "vfmadd132sd": {
        "detail": [
            "Fused Multiply-Add of Scalar Double- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD multiply-add computation on the low double-precision floating-point values using three source operands and writes the multiply-add result in the destination operand. The destination operand is also the first source operand. The first and second operand are XMM registers. The third source operand can be an XMM register or a 64-bit memory location.",
            "VFMADD132SD: Multiplies the low double-precision floating-point value from the first source operand to the low double-precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low double-precision floating-point values in the second source operand, performs rounding and stores the resulting double-precision floating-point value to the destination operand (first source operand).",
            "VFMADD213SD: Multiplies the low double-precision floating-point value from the second source operand to the low double-precision floating-point value in the first source operand, adds the infinite precision intermediate result to the low double-precision floating-point value in the third source operand, performs rounding and stores the resulting double-precision floating-point value to the destination operand (first source operand).",
            "VFMADD231SD: Multiplies the low double-precision floating-point value from the second source to the low double-precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low double-precision floating-point value in the first source operand, performs rounding and stores the resulting double-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination is updated according to the writemask."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADD132SD:VFMADD213SD:VFMADD231SD.html"
        ]
    },
    "call far": {
        "detail": [
            "Call Procedure"
        ],
        "documentation": [
            "Saves procedure linking information on the stack and branches to the called procedure specified using the target operand. The target operand specifies the address of the first instruction in the called procedure. The operand can be an immediate value, a general-purpose register, or a memory location.",
            "This instruction can be used to execute four types of calls:",
            "Flags Affected:",
            "All flags are affected if a task switch occurs; no flags are affected if a task switch does not occur."
        ],
        "operands": [
            "mem.d, reg.q, reg.q, mem.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/CALL.html"
        ]
    },
    "vcvtsi2sd": {
        "detail": [
            "Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the “convert-from” source operand to a double-precision floating-point value in the destination operand. The result is stored in the low quadword of the destination operand, and the high quadword left unchanged. When conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.",
            "The second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: Use of the REX.W prefix promotes the instruction to 64-bit operands. The “convert-from” source operand (the second operand) is a general-purpose register or memory location. The destination is an XMM register Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded versions: The “convert-from” source operand (the third operand) can be a general-purpose register or a memory location. The first source and destination operands are XMM registers. Bits (127:64) of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX.W0 version: attempt to encode this instruction with EVEX embedded rounding is ignored.",
            "VEX.W1 and EVEX.W1 versions: promotes the instruction to use 64-bit input value in 64-bit mode.",
            "Software should ensure VCVTSI2SD is encoded with VEX.L=0. Encoding VCVTSI2SD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTSI2SD.html"
        ]
    },
    "vxorpd": {
        "detail": [
            "Bitwise Logical XOR of Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical XOR of the two, four or eight packed double-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand",
            "EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand can be a ZMM register or a vector memory location. The destination operand is a ZMM register conditionally updated with writemask k1.",
            "VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register (conditionally updated with writemask k1 in case of EVEX). The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register (conditionally updated with writemask k1 in case of EVEX). The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/XORPD.html"
        ]
    },
    "hsubps": {
        "detail": [
            "Packed Single-FP Horizontal Subtract"
        ],
        "documentation": [
            "Subtracts the single-precision floating-point value in the second dword of the destination operand from the first dword of the destination operand and stores the result in the first dword of the destination operand.",
            "Subtracts the single-precision floating-point value in the fourth dword of the destination operand from the third dword of the destination operand and stores the result in the second dword of the destination operand.",
            "Subtracts the single-precision floating-point value in the second dword of the source operand from the first dword of the source operand and stores the result in the third dword of the destination operand.",
            "Subtracts the single-precision floating-point value in the fourth dword of the source operand from the third dword of the source operand and stores the result in the fourth dword of the destination operand.",
            "In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
            "See Figure 3-22 for HSUBPS; see Figure 3-23 for VHSUBPS."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/HSUBPS.html"
        ]
    },
    "lock not": {
        "detail": [
            "One's Complement Negation"
        ],
        "documentation": [
            "Performs a bitwise NOT operation (each 1 is set to 0, and each 0 is set to 1) on the destination operand and stores the result in the destination operand location. The destination operand can be a register or a memory location.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/NOT.html"
        ]
    },
    "vpmacsww": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vfmadd132ss": {
        "detail": [
            "Fused Multiply-Add of Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD multiply-add computation on single-precision floating-point values using three source operands and writes the multiply-add results in the destination operand. The destination operand is also the first source operand. The first and second operands are XMM registers. The third source operand can be a XMM register or a 32-bit memory location.",
            "VFMADD132SS: Multiplies the low single-precision floating-point value from the first source operand to the low single-precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low single-precision floating-point value in the second source operand, performs rounding and stores the resulting single-precision floating-point value to the destination operand (first source operand).",
            "VFMADD213SS: Multiplies the low single-precision floating-point value from the second source operand to the low single-precision floating-point value in the first source operand, adds the infinite precision intermediate result to the low single-precision floating-point value in the third source operand, performs rounding and stores the resulting single-precision floating-point value to the destination operand (first source operand).",
            "VFMADD231SS: Multiplies the low single-precision floating-point value from the second source operand to the low single-precision floating-point value in the third source operand, adds the infinite precision intermediate result to the low single-precision floating-point value in the first source operand, performs rounding and stores the resulting single-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADD132SS:VFMADD213SS:VFMADD231SS.html"
        ]
    },
    "lmsw": {
        "detail": [
            "Load Machine Status Word"
        ],
        "documentation": [
            "Loads the source operand into the machine status word, bits 0 through 15 of register CR0. The source operand can be a 16-bit general-purpose register or a memory location. Only the low-order 4 bits of the source operand (which contains the PE, MP, EM, and TS flags) are loaded into CR0. The PG, CD, NW, AM, WP, NE, and ET flags of CR0 are not affected. The operand-size attribute has no effect on this instruction.",
            "If the PE flag of the source operand (bit 0) is set to 1, the instruction causes the processor to switch to protected mode. While in protected mode, the LMSW instruction cannot be used to clear the PE flag and force a switch back to real-address mode.",
            "The LMSW instruction is provided for use in operating-system software; it should not be used in application programs. In protected or virtual-8086 mode, it can only be executed at CPL 0.",
            "This instruction is provided for compatibility with the Intel 286 processor; programs and procedures intended to run on IA-32 and Intel 64 processors beginning with Intel386 processors should use the MOV (control registers) instruction to load the whole CR0 register. The MOV CR0 instruction can be used to set and clear the PE flag in CR0, allowing a procedure or program to switch between protected and real-address modes.",
            "This instruction is a serializing instruction.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode. Note that the operand size is fixed at 16 bits.",
            "See “Changes to Instruction Behavior in VMX Non-Root Operation” in Chapter 25 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, for more information about the behavior of this instruction in VMX non-root operation.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.w, reg",
            "mem.w, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/LMSW.html"
        ]
    },
    "vcvtsi2ss": {
        "detail": [
            "Convert Doubleword Integer to Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the “convert-from” source operand to a single-precision floating-point value in the destination operand (first operand). The “convert-from” source operand can be a general-purpose register or a memory location. The destination operand is an XMM register. The result is stored in the low doubleword of the destination operand, and the upper three doublewords are left unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits.",
            "128-bit Legacy SSE version: In 64-bit mode, Use of the REX.W prefix promotes the instruction to use 64-bit input value. The “convert-from” source operand (the second operand) is a general-purpose register or memory location. Bits (MAXVL-1:32) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded versions: The “convert-from” source operand (the third operand) can be a general-purpose register or a memory location. The first source and destination operands are XMM registers. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: the converted result in written to the low doubleword element of the destination under the writemask.",
            "Software should ensure VCVTSI2SS is encoded with VEX.L=0. Encoding VCVTSI2SS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTSI2SS.html"
        ]
    },
    "vxorps": {
        "detail": [
            "Bitwise Logical XOR of Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical XOR of the four, eight or sixteen packed single-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand",
            "EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand can be a ZMM register or a vector memory location. The destination operand is a ZMM register conditionally updated with writemask k1.",
            "VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register (conditionally updated with writemask k1 in case of EVEX). The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register (conditionally updated with writemask k1 in case of EVEX). The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/XORPS.html"
        ]
    },
    "rsqrtps": {
        "detail": [
            "Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD computation of the approximate reciprocals of the square roots of the four packed single-precision floating-point values in the source operand (second operand) and stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD single-precision floating-point operation.",
            "The relative error for this approximation is:",
            "|Relative Error| ≤ 1.5 ∗ 2−12",
            "The RSQRTPS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). When a source value is a negative value (other than −0.0), a floating-point indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/RSQRTPS.html"
        ]
    },
    "ret": {
        "detail": [
            "Return from Procedure"
        ],
        "documentation": [
            "Transfers program control to a return address located on the top of the stack. The address is usually placed on the stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction.",
            "The optional source operand specifies the number of stack bytes to be released after the return address is popped; the default is none. This operand can be used to release parameters from the stack that were passed to the called procedure and are no longer needed. It must be used when the CALL instruction used to switch to a new procedure uses a call gate with a non-zero word count to access the new procedure. Here, the source operand for the RET instruction must specify the same number of bytes as is specified in the word count field of the call gate.",
            "The RET instruction can be used to execute three different types of returns:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.q, mem.q",
            "imm.w, reg.q, reg.q, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/RET.html"
        ]
    },
    "tdpbuud": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, reg, reg"
        ],
        "url": [
            "https://"
        ]
    },
    "blendpd": {
        "detail": [
            "Blend Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Double-precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The immediate bits [3:0] determine whether the corresponding double-precision floating-point value in the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is ”1”, then the double-precision floating-point value in the second source operand is copied, else the value in the first source operand is copied.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: the first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/BLENDPD.html"
        ]
    },
    "vpmovswb": {
        "detail": [
            "Down Convert Word to Byte"
        ],
        "documentation": [
            "VPMOVWB down converts 16-bit integers into packed bytes using truncation. VPMOVSWB converts signed 16-bit integers into packed signed bytes using signed saturation. VPMOVUSWB convert unsigned word values into unsigned byte values using unsigned saturation.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.",
            "Down-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.",
            "Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.x",
            "mem.q, reg.q, reg.x",
            "mem.q, reg.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVWB:VPMOVSWB:VPMOVUSWB.html"
        ]
    },
    "blendps": {
        "detail": [
            "Blend Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Packed single-precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The immediate bits [7:0] determine whether the corresponding single precision floating-point value in the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is “1”, then the single-precision floating-point value in the second source operand is copied, else the value in the first source operand is copied.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: The first source operand an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/BLENDPS.html"
        ]
    },
    "vpsubsb": {
        "detail": [
            "Subtract Packed Signed Integers with Signed Saturation"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed signed integers of the source operand (second operand) from the packed signed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following paragraphs.",
            "The (V)PSUBSB instruction subtracts packed signed byte integers. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.",
            "The (V)PSUBSW instruction subtracts packed signed word integers. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBSB:PSUBSW.html"
        ]
    },
    "vscatterqpd": {
        "detail": [
            "Scatter Packed Single, Packed Double with Signed Dword and Qword Indices"
        ],
        "documentation": [
            "Stores up to 16 elements (or 8 elements) in doubleword/quadword vector zmm1 to the memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register (k1) are partially updated. If any traps or interrupts are pending from already scattered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "Note that:"
        ],
        "operands": [
            "mem.q, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCATTERDPS:VSCATTERDPD:VSCATTERQPS:VSCATTERQPD.html"
        ]
    },
    "mwait": {
        "detail": [
            "Monitor Wait"
        ],
        "documentation": [
            "MWAIT instruction provides hints to allow the processor to enter an implementation-dependent optimized state. There are two principal targeted usages: address-range monitor and advanced power management. Both usages of MWAIT require the use of the MONITOR instruction.",
            "CPUID.01H:ECX.MONITOR[bit 3] indicates the availability of MONITOR and MWAIT in the processor. When set, MWAIT may be executed only at privilege level 0 (use at any other privilege level results in an invalid-opcode exception). The operating system or system BIOS may disable this instruction by using the IA32_MISC_ENABLE MSR; disabling MWAIT clears the CPUID feature flag and causes execution to generate an invalid-opcode exception.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
            "ECX specifies optional extensions for the MWAIT instruction. EAX may contain hints such as the preferred optimized state the processor should enter. The first processors to implement MWAIT supported only the zero value for EAX and ECX. Later processors allowed setting ECX[0] to enable masked interrupts as break events for MWAIT (see below). Software can use the CPUID instruction to determine the extensions and hints supported by the processor."
        ],
        "operands": [
            "reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/MWAIT.html"
        ]
    },
    "vpsubsw": {
        "detail": [
            "Subtract Packed Signed Integers with Signed Saturation"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed signed integers of the source operand (second operand) from the packed signed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following paragraphs.",
            "The (V)PSUBSB instruction subtracts packed signed byte integers. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.",
            "The (V)PSUBSW instruction subtracts packed signed word integers. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBSB:PSUBSW.html"
        ]
    },
    "vscatterqps": {
        "detail": [
            "Scatter Packed Single, Packed Double with Signed Dword and Qword Indices"
        ],
        "documentation": [
            "Stores up to 16 elements (or 8 elements) in doubleword/quadword vector zmm1 to the memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register (k1) are partially updated. If any traps or interrupts are pending from already scattered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "Note that:"
        ],
        "operands": [
            "mem.d, reg.q, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCATTERDPS:VSCATTERDPD:VSCATTERQPS:VSCATTERQPD.html"
        ]
    },
    "cmovle": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "shl": {
        "detail": [
            "Shift"
        ],
        "documentation": [
            "Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF flag, then discarded. At the end of the shift operation, the CF flag contains the last bit shifted out of the destination operand.",
            "The destination operand can be a register or a memory location. The count operand can be an immediate value or the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W is used). The count range is limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used). A special opcode encoding is provided for a count of 1.",
            "The shift arithmetic left (SAL) and shift logical left (SHL) instructions perform the same operation; they shift the bits in the destination operand to the left (toward more significant bit locations). For each shift count, the most significant bit of the destination operand is shifted into the CF flag, and the least significant bit is cleared (see Figure 7-7 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1).",
            "The shift arithmetic right (SAR) and shift logical right (SHR) instructions shift the bits of the destination operand to the right (toward less significant bit locations). For each shift count, the least significant bit of the destination operand is shifted into the CF flag, and the most significant bit is either set or cleared depending on the instruction type. The SHR instruction clears the most significant bit (see Figure 7-8 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1); the SAR instruction sets or clears the most significant bit to correspond to the sign (most significant bit) of the original value in the destination operand. In effect, the SAR instruction fills the empty bit position’s shifted value with the sign of the unshifted value (see Figure 7-9 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1).",
            "The SAR and SHR instructions can be used to perform signed or unsigned division, respectively, of the destination operand by powers of 2. For example, using the SAR instruction to shift a signed integer 1 bit to the right divides the value by 2.",
            "Using the SAR instruction to perform a division operation does not produce the same result as the IDIV instruction. The quotient from the IDIV instruction is rounded toward zero, whereas the “quotient” of the SAR instruction is rounded toward negative infinity. This difference is apparent only for negative numbers. For example, when the IDIV instruction is used to divide -9 by 4, the result is -2 with a remainder of -1. If the SAR instruction is used to shift -9 right by two bits, the result is -3 and the “remainder” is +3; however, the SAR instruction stores only the most significant bit of the remainder (in the CF flag).",
            "The OF flag is affected only on 1-bit shifts. For left shifts, the OF flag is set to 0 if the most-significant bit of the result is the same as the CF flag (that is, the top two bits of the original operand were the same); otherwise, it is set to 1. For the SAR instruction, the OF flag is cleared for all 1-bit shifts. For the SHR instruction, the OF flag is set to the most-significant bit of the original operand.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits and the mask width for CL is 5 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64-bits and sets the mask width for CL to 6 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The CF flag contains the value of the last bit shifted out of the destination operand; it is undefined for SHL and SHR instructions where the count is greater than or equal to the size (in bits) of the destination operand. The OF flag is affected only for 1-bit shifts (see “Description” above); otherwise, it is undefined. The SF, ZF, and PF flags are set according to the result. If the count is 0, the flags are not affected. For a non-zero count, the AF flag is undefined."
        ],
        "operands": [
            "mem.b, imm.b",
            "reg.b, reg",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/SAL:SAR:SHL:SHR.html"
        ]
    },
    "vinserti64x2": {
        "detail": [
            "Insert Packed Integer Values"
        ],
        "documentation": [
            "VINSERTI32x4 and VINSERTI64x2 inserts 128-bits of packed integer values from the second source operand (the third operand) into the destination operand (the first operand) at an 128-bit granular offset multiplied by imm8[0] (256-bit) or imm8[1:0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit memory location. The high 6/7bits of the immediate are ignored. The destination operand is a ZMM/YMM register and updated at 32 and 64-bit granularity according to the writemask.",
            "VINSERTI32x8 and VINSERTI64x4 inserts 256-bits of packed integer values from the second source operand (the third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an YMM register or a 256-bit memory location. The upper bits of the immediate are ignored. The destination operand is a ZMM register and updated at 32 and 64-bit granularity according to the writemask.",
            "VINSERTI128 inserts 128-bits of packed integer data from the second source operand (the third operand) into the destination operand (the first operand) at a 128-bit granular offset multiplied by imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit memory location. The high 7 bits of the immediate are ignored. VEX.L must be 1, otherwise attempt to execute this instruction with VEX.L=0 will cause #UD."
        ],
        "operands": [
            "reg.y, reg.y, mem.x, imm.b",
            "reg.y, reg.q, reg.y, reg.x, imm.b",
            "reg.y, reg.q, reg.y, mem.x, imm.b",
            "reg.y, reg.y, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VINSERTI128:VINSERTI32x4:VINSERTI64x2:VINSERTI32x8:VINSERTI64x4.html"
        ]
    },
    "vfnmadd213sd": {
        "detail": [
            "Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMADD132SD: Multiplies the low packed double-precision floating-point value from the first source operand to the low packed double-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFNMADD213SD: Multiplies the low packed double-precision floating-point value from the second source operand to the low packed double-precision floating-point value in the first source operand, adds the negated infinite precision intermediate result to the low packed double-precision floating-point value in the third source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFNMADD231SD: Multiplies the low packed double-precision floating-point value from the second source to the low packed double-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed double-precision floating-point value in the first source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMADD132SD:VFNMADD213SD:VFNMADD231SD.html"
        ]
    },
    "vinserti64x4": {
        "detail": [
            "Insert Packed Integer Values"
        ],
        "documentation": [
            "VINSERTI32x4 and VINSERTI64x2 inserts 128-bits of packed integer values from the second source operand (the third operand) into the destination operand (the first operand) at an 128-bit granular offset multiplied by imm8[0] (256-bit) or imm8[1:0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit memory location. The high 6/7bits of the immediate are ignored. The destination operand is a ZMM/YMM register and updated at 32 and 64-bit granularity according to the writemask.",
            "VINSERTI32x8 and VINSERTI64x4 inserts 256-bits of packed integer values from the second source operand (the third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an YMM register or a 256-bit memory location. The upper bits of the immediate are ignored. The destination operand is a ZMM register and updated at 32 and 64-bit granularity according to the writemask.",
            "VINSERTI128 inserts 128-bits of packed integer data from the second source operand (the third operand) into the destination operand (the first operand) at a 128-bit granular offset multiplied by imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit memory location. The high 7 bits of the immediate are ignored. VEX.L must be 1, otherwise attempt to execute this instruction with VEX.L=0 will cause #UD."
        ],
        "operands": [
            "reg.z, reg.z, mem.y, imm.b",
            "reg.z, reg.q, reg.z, reg.y, imm.b",
            "reg.z, reg.q, reg.z, mem.y, imm.b",
            "reg.z, reg.z, reg.y, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VINSERTI128:VINSERTI32x4:VINSERTI64x2:VINSERTI32x8:VINSERTI64x4.html"
        ]
    },
    "shr": {
        "detail": [
            "Shift"
        ],
        "documentation": [
            "Shifts the bits in the first operand (destination operand) to the left or right by the number of bits specified in the second operand (count operand). Bits shifted beyond the destination operand boundary are first shifted into the CF flag, then discarded. At the end of the shift operation, the CF flag contains the last bit shifted out of the destination operand.",
            "The destination operand can be a register or a memory location. The count operand can be an immediate value or the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W is used). The count range is limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used). A special opcode encoding is provided for a count of 1.",
            "The shift arithmetic left (SAL) and shift logical left (SHL) instructions perform the same operation; they shift the bits in the destination operand to the left (toward more significant bit locations). For each shift count, the most significant bit of the destination operand is shifted into the CF flag, and the least significant bit is cleared (see Figure 7-7 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1).",
            "The shift arithmetic right (SAR) and shift logical right (SHR) instructions shift the bits of the destination operand to the right (toward less significant bit locations). For each shift count, the least significant bit of the destination operand is shifted into the CF flag, and the most significant bit is either set or cleared depending on the instruction type. The SHR instruction clears the most significant bit (see Figure 7-8 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1); the SAR instruction sets or clears the most significant bit to correspond to the sign (most significant bit) of the original value in the destination operand. In effect, the SAR instruction fills the empty bit position’s shifted value with the sign of the unshifted value (see Figure 7-9 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1).",
            "The SAR and SHR instructions can be used to perform signed or unsigned division, respectively, of the destination operand by powers of 2. For example, using the SAR instruction to shift a signed integer 1 bit to the right divides the value by 2.",
            "Using the SAR instruction to perform a division operation does not produce the same result as the IDIV instruction. The quotient from the IDIV instruction is rounded toward zero, whereas the “quotient” of the SAR instruction is rounded toward negative infinity. This difference is apparent only for negative numbers. For example, when the IDIV instruction is used to divide -9 by 4, the result is -2 with a remainder of -1. If the SAR instruction is used to shift -9 right by two bits, the result is -3 and the “remainder” is +3; however, the SAR instruction stores only the most significant bit of the remainder (in the CF flag).",
            "The OF flag is affected only on 1-bit shifts. For left shifts, the OF flag is set to 0 if the most-significant bit of the result is the same as the CF flag (that is, the top two bits of the original operand were the same); otherwise, it is set to 1. For the SAR instruction, the OF flag is cleared for all 1-bit shifts. For the SHR instruction, the OF flag is set to the most-significant bit of the original operand.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits and the mask width for CL is 5 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64-bits and sets the mask width for CL to 6 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The CF flag contains the value of the last bit shifted out of the destination operand; it is undefined for SHL and SHR instructions where the count is greater than or equal to the size (in bits) of the destination operand. The OF flag is affected only for 1-bit shifts (see “Description” above); otherwise, it is undefined. The SF, ZF, and PF flags are set according to the result. If the count is 0, the flags are not affected. For a non-zero count, the AF flag is undefined."
        ],
        "operands": [
            "mem.b, imm.b",
            "reg.b, reg",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/SAL:SAR:SHL:SHR.html"
        ]
    },
    "vpbroadcastmw2d": {
        "detail": [
            "Broadcast Mask to Vector Register"
        ],
        "documentation": [
            "Broadcasts the zero-extended 64/32 bit value of the low byte/word of the source operand (the second operand) to each 64/32 bit element of the destination operand (the first operand). The source operand is an opmask register. The destination operand is a ZMM register (EVEX.512), YMM register (EVEX.256), or XMM register (EVEX.128).",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPBROADCASTM.html"
        ]
    },
    "vfnmadd213ss": {
        "detail": [
            "Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMADD132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFNMADD213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFNMADD231SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMADD132SS:VFNMADD213SS:VFNMADD231SS.html"
        ]
    },
    "vextractf32x4": {
        "detail": [
            "Extra ct Packed Floating-Point Values"
        ],
        "documentation": [
            "VEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of single-precision floating-point values from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand). The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor. The destination may be either a vector register or an 128-bit memory location.",
            "VEXTRACTF32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the writemask.",
            "VEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of double-precision floating-point values from the source operand (second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor The destination may be either a vector register or a 256-bit memory location.",
            "VEXTRACTF64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the writemask.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "The high 6 bits of the immediate are ignored.",
            "If VEXTRACTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "mem.x, reg.q, reg.z, imm.b",
            "reg.x, reg.z, imm.b",
            "reg.x, reg.q, reg.z, imm.b",
            "mem.x, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VEXTRACTF128:VEXTRACTF32x4:VEXTRACTF64x2:VEXTRACTF32x8:VEXTRACTF64x4.html"
        ]
    },
    "cvtsi2sd": {
        "detail": [
            "Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the “convert-from” source operand to a double-precision floating-point value in the destination operand. The result is stored in the low quadword of the destination operand, and the high quadword left unchanged. When conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.",
            "The second source operand can be a general-purpose register or a 32/64-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: Use of the REX.W prefix promotes the instruction to 64-bit operands. The “convert-from” source operand (the second operand) is a general-purpose register or memory location. The destination is an XMM register Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded versions: The “convert-from” source operand (the third operand) can be a general-purpose register or a memory location. The first source and destination operands are XMM registers. Bits (127:64) of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX.W0 version: attempt to encode this instruction with EVEX embedded rounding is ignored.",
            "VEX.W1 and EVEX.W1 versions: promotes the instruction to use 64-bit input value in 64-bit mode.",
            "Software should ensure VCVTSI2SD is encoded with VEX.L=0. Encoding VCVTSI2SD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.q, mem.d",
            "reg.q, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTSI2SD.html"
        ]
    },
    "vextractf32x8": {
        "detail": [
            "Extra ct Packed Floating-Point Values"
        ],
        "documentation": [
            "VEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of single-precision floating-point values from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand). The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor. The destination may be either a vector register or an 128-bit memory location.",
            "VEXTRACTF32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the writemask.",
            "VEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of double-precision floating-point values from the source operand (second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor The destination may be either a vector register or a 256-bit memory location.",
            "VEXTRACTF64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the writemask.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "The high 6 bits of the immediate are ignored.",
            "If VEXTRACTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "mem.y, reg.q, reg.z, imm.b",
            "reg.y, reg.z, imm.b",
            "reg.y, reg.q, reg.z, imm.b",
            "mem.y, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VEXTRACTF128:VEXTRACTF32x4:VEXTRACTF64x2:VEXTRACTF32x8:VEXTRACTF64x4.html"
        ]
    },
    "movd": {
        "detail": [
            "Move Doubleword/Move Quadword"
        ],
        "documentation": [
            "Copies a doubleword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be general-purpose registers, MMX technology registers, XMM registers, or 32-bit memory locations. This instruction can be used to move a doubleword to and from the low doubleword of an MMX technology register and a general-purpose register or a 32-bit memory location, or to and from the low doubleword of an XMM register and a general-purpose register or a 32-bit memory location. The instruction cannot be used to transfer data between MMX technology registers, between XMM registers, between general-purpose registers, or between memory locations.",
            "When the destination operand is an MMX technology register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 64 bits. When the destination operand is an XMM register, the source operand is written to the low doubleword of the register, and the register is zero-extended to 128 bits.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, mem.d",
            "reg.q, reg.d",
            "mem.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVD:MOVQ.html"
        ]
    },
    "vfmsub213sd": {
        "detail": [
            "Fused Multiply-Subtract of Scalar Double- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD multiply-subtract computation on the low packed double-precision floating-point values using three source operands and writes the multiply-subtract result in the destination operand. The destination operand is also the first source operand. The second operand must be a XMM register. The third source operand can be a XMM register or a 64-bit memory location.",
            "VFMSUB132SD: Multiplies the low packed double-precision floating-point value from the first source operand to the low packed double-precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFMSUB213SD: Multiplies the low packed double-precision floating-point value from the second source operand to the low packed double-precision floating-point value in the first source operand. From the infinite precision intermediate result, subtracts the low packed double-precision floating-point value in the third source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFMSUB231SD: Multiplies the low packed double-precision floating-point value from the second source to the low packed double-precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed double-precision floating-point value in the first source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUB132SD:VFMSUB213SD:VFMSUB231SD.html"
        ]
    },
    "fldlg2": {
        "detail": [
            "Load Constant"
        ],
        "documentation": [
            "Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, π, log102, and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.",
            "See the section titled “Approximation of Pi” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a description of the π constant.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FLD1:FLDL2T:FLDL2E:FLDPI:FLDLG2:FLDLN2:FLDZ.html"
        ]
    },
    "cvtsi2ss": {
        "detail": [
            "Convert Doubleword Integer to Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Converts a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the “convert-from” source operand to a single-precision floating-point value in the destination operand (first operand). The “convert-from” source operand can be a general-purpose register or a memory location. The destination operand is an XMM register. The result is stored in the low doubleword of the destination operand, and the upper three doublewords are left unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits.",
            "128-bit Legacy SSE version: In 64-bit mode, Use of the REX.W prefix promotes the instruction to use 64-bit input value. The “convert-from” source operand (the second operand) is a general-purpose register or memory location. Bits (MAXVL-1:32) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded versions: The “convert-from” source operand (the third operand) can be a general-purpose register or a memory location. The first source and destination operands are XMM registers. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: the converted result in written to the low doubleword element of the destination under the writemask.",
            "Software should ensure VCVTSI2SS is encoded with VEX.L=0. Encoding VCVTSI2SS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTSI2SS.html"
        ]
    },
    "vpcompressb": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x",
            "mem.x, reg.q, reg.x",
            "mem.x, reg.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "movq": {
        "detail": [
            "Move Quadword"
        ],
        "documentation": [
            "Copies a quadword from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be MMX technology registers, XMM registers, or 64-bit memory locations. This instruction can be used to move a quadword between two MMX technology registers or between an MMX technology register and a 64-bit memory location, or to move data between two XMM registers or between an XMM register and a 64-bit memory location. The instruction cannot be used to transfer data between memory locations.",
            "When the source operand is an XMM register, the low quadword is moved; when the destination operand is an XMM register, the quadword is stored to the low quadword of the register, and the high quadword is cleared to all 0s.",
            "In 64-bit mode and if not encoded using VEX/EVEX, use of the REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "If VMOVQ is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVQ.html"
        ]
    },
    "vpcompressd": {
        "detail": [
            "Store Sparse Packed Doubleword Integer Values into Dense Memory/Register"
        ],
        "documentation": [
            "Compress (store) up to 16/8/4 doubleword integer values from the source operand (second operand) to the destination operand (first operand). The source operand is a ZMM/YMM/XMM register, the destination operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.",
            "The opmask register k1 selects the active elements (partial vector or possibly non-contiguous if less than 16 active elements) from the source operand to compress into a contiguous vector. The contiguous vector is written to the destination starting from the low element of the destination operand.",
            "Memory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z must be zero.",
            "Register destination version: If the vector length of the contiguous vector is less than that of the input vector in the source operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper bits are zeroed.",
            "Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector."
        ],
        "operands": [
            "reg.z, reg.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPCOMPRESSD.html"
        ]
    },
    "vpmovsxwd": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "documentation": [
            "Legacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVSX.html"
        ]
    },
    "vrcp28pd": {
        "detail": [
            "Approximation to the Reciprocal of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error"
        ],
        "documentation": [
            "Computes the reciprocal approximation of the float64 values in the source operand (the second operand) and store the results to the destination operand (the first operand). The approximate reciprocal is evaluated with less than 2^-28 of maximum relative error.",
            "Denormal input values are treated as zeros and do not signal #DE, irrespective of MXCSR.DAZ. Denormal results are flushed to zeros and do not signal #UE, irrespective of MXCSR.FTZ.",
            "If any source element is NaN, the quietized NaN source value is returned for that element. If any source element is ±∞, ±0.0 is returned for that element. Also, if any source element is ±0.0, ±∞ is returned for that element.",
            "The source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRCP28PD.html"
        ]
    },
    "vpexpandb": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpexpandd": {
        "detail": [
            "Load Sparse Packed Doubleword Integer Values from Dense Memory / Register"
        ],
        "documentation": [
            "Expand (load) up to 16 contiguous doubleword integer values of the input vector in the source operand (the second operand) to sparse elements in the destination operand (the first operand), selected by the writemask k1. The destination operand is a ZMM register, the source operand can be a ZMM register or memory location.",
            "The input vector starts from the lowest element in the source operand. The opmask register k1 selects the destination elements (a partial vector or sparse elements if less than 8 elements) to be replaced by the ascending elements in the input vector. Destination elements not selected by the writemask k1 are either unmodified or zeroed, depending on EVEX.z.",
            "Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPEXPANDD.html"
        ]
    },
    "vfmsub213ss": {
        "detail": [
            "Fused Multiply-Subtract of Scalar Single- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD multiply-subtract computation on the low packed single-precision floating-point values using three source operands and writes the multiply-subtract result in the destination operand. The destination operand is also the first source operand. The second operand must be a XMM register. The third source operand can be a XMM register or a 32-bit memory location.",
            "VFMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand. From the infinite precision intermediate result, subtracts the low packed single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low packed single-precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUB132SS:VFMSUB213SS:VFMSUB231SS.html"
        ]
    },
    "vphminposuw": {
        "detail": [
            "Packed Horizontal Word Minimum"
        ],
        "documentation": [
            "Determine the minimum unsigned word value in the source operand (second operand) and place the unsigned word in the low word (bits 0-15) of the destination operand (first operand). The word index of the minimum value is stored in bits 16-18 of the destination operand. The remaining upper bits of the destination are set to zero.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding XMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination XMM register are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PHMINPOSUW.html"
        ]
    },
    "xresldtrk": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "vpcompressq": {
        "detail": [
            "Store Sparse Packed Quadword Integer Values into Dense Memory/Register"
        ],
        "documentation": [
            "Compress (stores) up to 8/4/2 quadword integer values from the source operand (second operand) to the destination operand (first operand). The source operand is a ZMM/YMM/XMM register, the destination operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.",
            "The opmask register k1 selects the active elements (partial vector or possibly non-contiguous if less than 8 active elements) from the source operand to compress into a contiguous vector. The contiguous vector is written to the destination starting from the low element of the destination operand.",
            "Memory destination version: Only the contiguous vector is written to the destination memory location. EVEX.z must be zero.",
            "Register destination version: If the vector length of the contiguous vector is less than that of the input vector in the source operand, the upper bits of the destination register are unmodified if EVEX.z is not set, otherwise the upper bits are zeroed.",
            "Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector."
        ],
        "operands": [
            "reg.z, reg.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPCOMPRESSQ.html"
        ]
    },
    "vpscatterqd": {
        "detail": [
            "Scatter Packed Dword, Packed Qword with Signed Dword, Signed Qword Indices"
        ],
        "documentation": [
            "Stores up to 16 elements (8 elements for qword indices) in doubleword vector or 8 elements in quadword vector to the memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register are partially updated. If any traps or interrupts are pending from already scattered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "Note that:"
        ],
        "operands": [
            "mem.d, reg.q, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPSCATTERDD:VPSCATTERDQ:VPSCATTERQD:VPSCATTERQQ.html"
        ]
    },
    "vpmovsxwq": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "documentation": [
            "Legacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.d",
            "reg.x, reg.d",
            "reg.z, reg.q, mem.x",
            "reg.z, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVSX.html"
        ]
    },
    "vpmovzxbd": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "documentation": [
            "Legacy, VEX and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask.The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.d",
            "reg.x, reg.d",
            "reg.z, reg.q, mem.x",
            "reg.z, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVZX.html"
        ]
    },
    "vpcompressw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x",
            "mem.x, reg.q, reg.x",
            "mem.x, reg.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vrcp28ps": {
        "detail": [
            "Approximation to the Reciprocal of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error"
        ],
        "documentation": [
            "Computes the reciprocal approximation of the float32 values in the source operand (the second operand) and store the results to the destination operand (the first operand) using the writemask k1. The approximate reciprocal is evaluated with less than 2^-28 of maximum relative error prior to final rounding. The final results are rounded to < 2^-23 relative error before written to the destination.",
            "Denormal input values are treated as zeros and do not signal #DE, irrespective of MXCSR.DAZ. Denormal results are flushed to zeros and do not signal #UE, irrespective of MXCSR.FTZ.",
            "If any source element is NaN, the quietized NaN source value is returned for that element. If any source element is ±∞, ±0.0 is returned for that element. Also, if any source element is ±0.0, ±∞ is returned for that element.",
            "The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRCP28PS.html"
        ]
    },
    "vpexpandq": {
        "detail": [
            "Load Sparse Packed Quadword Integer Values from Dense Memory / Register"
        ],
        "documentation": [
            "Expand (load) up to 8 quadword integer values from the source operand (the second operand) to sparse elements in the destination operand (the first operand), selected by the writemask k1. The destination operand is a ZMM register, the source operand can be a ZMM register or memory location.",
            "The input vector starts from the lowest element in the source operand. The opmask register k1 selects the destination elements (a partial vector or sparse elements if less than 8 elements) to be replaced by the ascending elements in the input vector. Destination elements not selected by the writemask k1 are either unmodified or zeroed, depending on EVEX.z.",
            "Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPEXPANDQ.html"
        ]
    },
    "prefetchwt1": {
        "detail": [
            "Prefetch Vector Data Into Caches with Intent to Write and T1 Hint"
        ],
        "documentation": [
            "Fetches the line of data from memory that contains the byte specified with the source operand to a location in the cache hierarchy specified by an intent to write hint (so that data is brought into ‘Exclusive’ state via a request for ownership) and a locality hint:",
            "Flags Affected:",
            "All flags are affected"
        ],
        "operands": [
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PREFETCHWT1.html"
        ]
    },
    "cwde": {
        "detail": [
            "Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword"
        ],
        "documentation": [
            "Double the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to double-word) instruction copies the sign (bit 15) of the word in the AX register into the high 16 bits of the EAX register.",
            "CBW and CWDE reference the same opcode. The CBW instruction is intended for use when the operand-size attribute is 16; CWDE is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size. Others may treat these two mnemonics as synonyms (CBW/CWDE) and use the setting of the operand-size attribute to determine the size of values to be converted.",
            "In 64-bit mode, the default operation size is the size of the destination register. Use of the REX.W prefix promotes this instruction (CDQE when promoted) to operate on 64-bit operands. In which case, CDQE copies the sign (bit 31) of the doubleword in the EAX register into the high 32 bits of RAX.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/CBW:CWDE:CDQE.html"
        ]
    },
    "tdpbssd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, reg, reg"
        ],
        "url": [
            "https://"
        ]
    },
    "vpexpandw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpscatterqq": {
        "detail": [
            "Scatter Packed Dword, Packed Qword with Signed Dword, Signed Qword Indices"
        ],
        "documentation": [
            "Stores up to 16 elements (8 elements for qword indices) in doubleword vector or 8 elements in quadword vector to the memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register are partially updated. If any traps or interrupts are pending from already scattered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "Note that:"
        ],
        "operands": [
            "mem.q, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPSCATTERDD:VPSCATTERDQ:VPSCATTERQD:VPSCATTERQQ.html"
        ]
    },
    "vpmovzxbq": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "documentation": [
            "Legacy, VEX and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask.The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.w",
            "reg.x, reg.w",
            "reg.z, reg.q, mem.q",
            "reg.z, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVZX.html"
        ]
    },
    "wbnoinvd": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "tdpbf16ps": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, reg, reg"
        ],
        "url": [
            "https://"
        ]
    },
    "vpmovzxbw": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "documentation": [
            "Legacy, VEX and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask.The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.x, reg.q, mem.q",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVZX.html"
        ]
    },
    "vpxord": {
        "detail": [
            "Logical Exclusive OR"
        ],
        "documentation": [
            "Performs a bitwise logical exclusive-OR (XOR) operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is 1 if the corresponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding register destination are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/PXOR.html"
        ]
    },
    "vbroadcastf64x2": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "documentation": [
            "VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).",
            "VEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4 load floating-point values as tuples from the source operand (the second operand) in memory or register and broadcast to all elements of the destination operand (the first operand). The destination operand is a YMM/ZMM register updated according to the writemask k1. The source operand is either a register or 64-bit/128-bit/256-bit memory location.",
            "VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as 256-bit and 512-bit wide versions and up. VBROADCASTSS is supported in 128-bit, 256-bit and 512-bit wide versions. F32x8 and F64x4 are only supported as 512-bit wide versions.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32-bit granularity. VBROADCASTF64X2 and VBROADCASTF64X4 have 64-bit granularity.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.y, mem.x",
            "reg.y, reg.q, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBROADCAST.html"
        ]
    },
    "vbroadcastf64x4": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "documentation": [
            "VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).",
            "VEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4 load floating-point values as tuples from the source operand (the second operand) in memory or register and broadcast to all elements of the destination operand (the first operand). The destination operand is a YMM/ZMM register updated according to the writemask k1. The source operand is either a register or 64-bit/128-bit/256-bit memory location.",
            "VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as 256-bit and 512-bit wide versions and up. VBROADCASTSS is supported in 128-bit, 256-bit and 512-bit wide versions. F32x8 and F64x4 are only supported as 512-bit wide versions.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32-bit granularity. VBROADCASTF64X2 and VBROADCASTF64X4 have 64-bit granularity.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.z, mem.y",
            "reg.z, reg.q, mem.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBROADCAST.html"
        ]
    },
    "vmxoff": {
        "detail": [
            "Leave VMX Operation"
        ],
        "documentation": [
            "Takes the logical processor out of VMX operation, unblocks INIT signals, conditionally re-enables A20M, and clears any address-range monitoring.7",
            "Flags Affected:",
            "See the operation section and Section 30.2."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/VMXOFF.html"
        ]
    },
    "vpshufhw": {
        "detail": [
            "Shuffle Packed High Words"
        ],
        "documentation": [
            "Copies words from the high quadword of a 128-bit lane of the source operand and inserts them in the high quadword of the destination operand at word locations (of the respective lane) selected with the immediate operand. This 256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illustrated in Figure 4-16. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the immediate operand selects the contents of one word location in the high quadword of the destination operand. The binary encodings of the immediate operand fields select words (0, 1, 2 or 3, 4) from the high quadword of the source operand to be copied to the destination operand. The low quadword of the source operand is copied to the low quadword of the destination operand, for each 128-bit lane.",
            "Note that this instruction permits a word in the high quadword of the source operand to be copied to more than one word location in the high quadword of the destination operand.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.",
            "VEX.256 encoded version: The destination operand is an YMM register. The source operand can be an YMM register or a 256-bit memory location.",
            "EVEX encoded version: The destination operand is a ZMM/YMM/XMM registers. The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the writemask.",
            "Note: In VEX encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, mem.x, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSHUFHW.html"
        ]
    },
    "vpxorq": {
        "detail": [
            "Logical Exclusive OR"
        ],
        "documentation": [
            "Performs a bitwise logical exclusive-OR (XOR) operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is 1 if the corresponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding register destination are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/PXOR.html"
        ]
    },
    "getsec": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, reg"
        ],
        "url": [
            "https://"
        ]
    },
    "vpsubusb": {
        "detail": [
            "Subtract Packed Unsigned Integers with Unsigned Saturation"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed unsigned integers of the source operand (second operand) from the packed unsigned integers of the destination operand (first operand), and stores the packed unsigned integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs.",
            "These instructions can operate on either 64-bit or 128-bit operands.",
            "The (V)PSUBUSB instruction subtracts packed unsigned byte integers. When an individual byte result is less than zero, the saturated value of 00H is written to the destination operand.",
            "The (V)PSUBUSW instruction subtracts packed unsigned word integers. When an individual word result is less than zero, the saturated value of 0000H is written to the destination operand.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBUSB:PSUBUSW.html"
        ]
    },
    "cmovnb": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "rsqrtss": {
        "detail": [
            "Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Computes an approximate reciprocal of the square root of the low single-precision floating-point value in the source operand (second operand) stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a scalar single-precision floating-point operation.",
            "The relative error for this approximation is:",
            "|Relative Error| ≤ 1.5 ∗ 2−12",
            "The RSQRTSS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). When a source value is a negative value (other than −0.0), a floating-point indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/RSQRTSS.html"
        ]
    },
    "cmovnl": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "cmovno": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "vpsubusw": {
        "detail": [
            "Subtract Packed Unsigned Integers with Unsigned Saturation"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed unsigned integers of the source operand (second operand) from the packed unsigned integers of the destination operand (first operand), and stores the packed unsigned integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs.",
            "These instructions can operate on either 64-bit or 128-bit operands.",
            "The (V)PSUBUSB instruction subtracts packed unsigned byte integers. When an individual byte result is less than zero, the saturated value of 00H is written to the destination operand.",
            "The (V)PSUBUSW instruction subtracts packed unsigned word integers. When an individual word result is less than zero, the saturated value of 0000H is written to the destination operand.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBUSB:PSUBUSW.html"
        ]
    },
    "vscatterpf0qpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint with Intent to Write"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "cache lines will be brought into exclusive state (RFO) specified by a locality hint (T0):"
        ],
        "operands": [
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCATTERPF0DPS:VSCATTERPF0QPS:VSCATTERPF0DPD:VSCATTERPF0QPD.html"
        ]
    },
    "cmovnp": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "cmovns": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "sha256msg1": {
        "detail": [
            "Perform an Intermediate Calculation for the Next Four SHA256 Message Dwords"
        ],
        "documentation": [
            "The SHA256MSG1 instruction is one of two SHA256 message scheduling instructions. The instruction performs an intermediate calculation for the next four SHA256 message dwords.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/SHA256MSG1.html"
        ]
    },
    "mwaitx": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, reg"
        ],
        "url": [
            "https://"
        ]
    },
    "sha256msg2": {
        "detail": [
            "Perform a Final Calculation for the Next Four SHA256 Message Dwords"
        ],
        "documentation": [
            "The SHA256MSG2 instruction is one of two SHA2 message scheduling instructions. The instruction performs the final calculation for the next four SHA256 message dwords.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/SHA256MSG2.html"
        ]
    },
    "vpslldq": {
        "detail": [
            "Shift Double Quadword Left Logical"
        ],
        "documentation": [
            "Shifts the destination operand (first operand) to the left by the number of bytes specified in the count operand (second operand). The empty low-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate.",
            "128-bit Legacy SSE version: The source and destination operands are the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The source and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The source operand is YMM register. The destination operand is an YMM register. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed. The count operand applies to both the low and high 128-bit lanes.",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register. The count operand applies to each 128-bit lanes.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSLLDQ.html"
        ]
    },
    "cmovnz": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "cvttps2dq": {
        "detail": [
            "Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values"
        ],
        "documentation": [
            "Converts four, eight or sixteen packed single-precision floating-point values in the source operand to four, eight or sixteen signed doubleword integers in the destination operand.",
            "When a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTTPS2DQ.html"
        ]
    },
    "vscatterpf0qps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint with Intent to Write"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "cache lines will be brought into exclusive state (RFO) specified by a locality hint (T0):"
        ],
        "operands": [
            "mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCATTERPF0DPS:VSCATTERPF0QPS:VSCATTERPF0DPD:VSCATTERPF0QPD.html"
        ]
    },
    "palignr": {
        "detail": [
            "Packed Align Right"
        ],
        "documentation": [
            "(V)PALIGNR concatenates the destination operand (the first operand) and the source operand (the second operand) into an intermediate composite, shifts the composite at byte granularity to the right by a constant immediate, and extracts the right-aligned result into the destination. The first and the second operands can be an MMX,",
            "XMM or a YMM register. The immediate value is considered unsigned. Immediate shift counts larger than the 2L (i.e. 32 for 128-bit operands, or 16 for 64-bit operands) produce a zero result. Both operands can be MMX registers, XMM registers or YMM registers. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "In 64-bit mode and not encoded by VEX/EVEX prefix, use the REX prefix to access additional registers.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "EVEX.512 encoded version: The first source operand is a ZMM register and contains four 16-byte blocks. The second source operand is a ZMM register or a 512-bit memory location containing four 16-byte block. The destination operand is a ZMM register and contain four 16-byte results. The imm8[7:0] is the common shift count",
            "used for each of the four successive 16-byte block sources. The low 16-byte block of the two source operands produce the low 16-byte result of the destination operand, the high 16-byte block of the two source operands produce the high 16-byte result of the destination operand and so on for the blocks in the middle.",
            "VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register and contains two 16-byte blocks. The second source operand is a YMM register or a 256-bit memory location containing two 16-byte block. The destination operand is a YMM register and contain two 16-byte results. The imm8[7:0] is the common shift count used for the two lower 16-byte block sources and the two upper 16-byte block sources. The low 16-byte block of the two source operands produce the low 16-byte result of the destination operand, the high 16-byte block of the two source operands produce the high 16-byte result of the destination operand. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "Concatenation is done with 128-bit data in the first and second source operand for both 128-bit and 256-bit instructions. The high 128-bits of the intermediate composite 256-bit result came from the 128-bit data from the first source operand; the low 128-bits of the intermediate result came from the 128-bit data of the second source operand.",
            "Note: VEX.L must be 0, otherwise the instruction will #UD.",
            "0 127 0 127"
        ],
        "operands": [
            "reg.q, reg.q, imm.b",
            "reg.q, mem.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PALIGNR.html"
        ]
    },
    "vmovapd": {
        "detail": [
            "Move Aligned Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Moves 2, 4 or 8 double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM, YMM or ZMM register from an 128-bit, 256-bit or 512-bit memory location, to store the contents of an XMM, YMM or ZMM register into a 128-bit, 256-bit or 512-bit memory location, or to move data between two XMM, two YMM or two ZMM registers.",
            "When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte (128-bit versions), 32-byte (256-bit version) or 64-byte (EVEX.512 encoded version) boundary or a general-protection exception (#GP) will be generated. For EVEX encoded versions, the operand must be aligned to the size of the memory operand. To move double-precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX.512 encoded version:",
            "Moves 512 bits of packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a ZMM register from a 512-bit float64 memory location, to store the contents of a ZMM register into a 512-bit float64 memory location, or to move data between two ZMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 64-byte boundary or a general-protection exception (#GP) will be generated. To move single-precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.",
            "VEX.256 and EVEX.256 encoded versions:",
            "Moves 256 bits of packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary or a general-protection exception (#GP) will be generated. To move double-precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.",
            "128-bit versions:",
            "Moves 128 bits of packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. To move single-precision floating-point values to and from unaligned memory locations, use the VMOVUPD instruction.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.",
            "(E)VEX.128 encoded version: Bits (MAXVL-1:128) of the destination ZMM register destination are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.x, reg.x",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVAPD.html"
        ]
    },
    "vpacksswb": {
        "detail": [
            "Pack with Signed Saturation"
        ],
        "documentation": [
            "Converts packed signed word integers into packed signed byte integers (PACKSSWB) or converts packed signed doubleword integers into packed signed word integers (PACKSSDW), using saturation to handle overflow conditions. See Figure 4-6 for an example of the packing operation."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PACKSSWB:PACKSSDW.html"
        ]
    },
    "tilestored": {
        "detail": [
            ""
        ],
        "operands": [
            "mem, reg"
        ],
        "url": [
            "https://"
        ]
    },
    "vexp2pd": {
        "detail": [
            "Approximation to the Exponential 2^x of Packed Double-Precision Floating-Point Values with Less Than 2^-23 Relative Error"
        ],
        "documentation": [
            "Computes the approximate base-2 exponential evaluation of the double-precision floating-point values in the source operand (the second operand) and stores the results to the destination operand (the first operand) using the writemask k1. The approximate base-2 exponential is evaluated with less than 2^-23 of relative error.",
            "Denormal input values are treated as zeros and do not signal #DE, irrespective of MXCSR.DAZ. Denormal results are flushed to zeros and do not signal #UE, irrespective of MXCSR.FTZ.",
            "The source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VEXP2PD.html"
        ]
    },
    "pmovsxwd": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "documentation": [
            "Legacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVSX.html"
        ]
    },
    "vphaddsw": {
        "detail": [
            "Packed Horizontal Add and Saturate"
        ],
        "documentation": [
            "(V)PHADDSW adds two adjacent signed 16-bit integers horizontally from the source and destination operands and saturates the signed results; packs the signed, saturated 16-bit results to the destination operand (first operand) When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "In 64-bit mode, use the REX prefix to access additional registers.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.",
            "Note: VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PHADDSW.html"
        ]
    },
    "tlbsync": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "vmovaps": {
        "detail": [
            "Move Aligned Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Moves 4, 8 or 16 single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM, YMM or ZMM register from an 128-bit, 256-bit or 512-bit memory location, to store the contents of an XMM, YMM or ZMM register into a 128-bit, 256-bit or 512-bit memory location, or to move data between two XMM, two YMM or two ZMM registers.",
            "When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary or a general-protection exception (#GP) will be generated. For EVEX.512 encoded versions, the operand must be aligned to the size of the memory operand. To move single-precision floating-point values to and from unaligned memory locations, use the VMOVUPS instruction.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX.512 encoded version:",
            "Moves 512 bits of packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a ZMM register from a 512-bit float32 memory location, to store the contents of a ZMM register into a float32 memory location, or to move data between two ZMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 64-byte boundary or a general-protection exception (#GP) will be generated. To move single-precision floating-point values to and from unaligned memory locations, use the VMOVUPS instruction.",
            "VEX.256 and EVEX.256 encoded version:",
            "Moves 256 bits of packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary or a general-protection exception (#GP) will be generated.",
            "128-bit versions:",
            "Moves 128 bits of packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. To move single-precision floating-point values to and from unaligned memory locations, use the VMOVUPS instruction.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.",
            "(E)VEX.128 encoded version: Bits (MAXVL-1:128) of the destination ZMM register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.x, reg.x",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVAPS.html"
        ]
    },
    "minpd": {
        "detail": [
            "Minimum of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed double-precision floating-point values in the first source operand and the second source operand and returns the minimum value for each pair of values to the destination operand.",
            "If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MINPD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MINPD.html"
        ]
    },
    "pmovsxwq": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "documentation": [
            "Legacy and VEX encoded versions: Packed byte, word, or dword integers in the low bytes of the source operand (second operand) are sign extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed byte, word or dword integers starting from the low bytes of the source operand (second operand) are sign extended to word, dword or quadword integers and stored to the destination operand under the writemask. The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.d",
            "reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVSX.html"
        ]
    },
    "vexp2ps": {
        "detail": [
            "Approximation to the Exponential 2^x of Packed Single-Precision Floating-Point Values with Less Than 2^-23 Relative Error"
        ],
        "documentation": [
            "Computes the approximate base-2 exponential evaluation of the single-precision floating-point values in the source operand (the second operand) and store the results in the destination operand (the first operand) using the writemask k1. The approximate base-2 exponential is evaluated with less than 2^-23 of relative error.",
            "Denormal input values are treated as zeros and do not signal #DE, irrespective of MXCSR.DAZ. Denormal results are flushed to zeros and do not signal #UE, irrespective of MXCSR.FTZ.",
            "The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VEXP2PS.html"
        ]
    },
    "pushfq": {
        "detail": [
            "Push EFLAGS Register onto the Stack"
        ],
        "documentation": [
            "Decrements the stack pointer by 4 (if the current operand-size attribute is 32) and pushes the entire contents of the EFLAGS register onto the stack, or decrements the stack pointer by 2 (if the operand-size attribute is 16) and pushes the lower 16 bits of the EFLAGS register (that is, the FLAGS register) onto the stack. These instructions reverse the operation of the POPF/POPFD instructions.",
            "When copying the entire EFLAGS register to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead, the values for these flags are cleared in the EFLAGS image stored on the stack. See Chapter 3 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information about the EFLAGS register.",
            "The PUSHF (push flags) and PUSHFD (push flags double) mnemonics reference the same opcode. The PUSHF instruction is intended for use when the operand-size attribute is 16 and the PUSHFD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when PUSHF is used and to 32 when PUSHFD is used. Others may treat these mnemonics as synonyms (PUSHF/PUSHFD) and use the current setting of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the mnemonic used.",
            "In 64-bit mode, the instruction’s default operation is to decrement the stack pointer (RSP) by 8 and pushes RFLAGS on the stack. 16-bit operation is supported using the operand size override prefix 66H. 32-bit operand size cannot be encoded in this mode. When copying RFLAGS to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead, values for these flags are cleared in the RFLAGS image stored on the stack.",
            "When operating in virtual-8086 mode (EFLAGS.VM = 1) without the virtual-8086 mode extensions (CR4.VME = 0), the PUSHF/PUSHFD instructions can be used only if IOPL = 3; otherwise, a general-protection exception (#GP) occurs. If the virtual-8086 mode extensions are enabled (CR4.VME = 1), PUSHF (but not PUSHFD) can be executed in virtual-8086 mode with IOPL < 3.",
            "(The protected-mode virtual-interrupt feature — enabled by setting CR4.PVI — affects the CLI and STI instructions in the same manner as the virtual-8086 mode extensions. PUSHF, however, is not affected by CR4.PVI.)",
            "In the real-address mode, if the ESP or SP register is 1 when PUSHF/PUSHFD instruction executes: an #SS exception is generated but not delivered (the stack error reported prevents #SS delivery). Next, the processor generates a #DF exception and enters a shutdown state as described in the #DF discussion in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUSHF:PUSHFD:PUSHFQ.html"
        ]
    },
    "f2xm1": {
        "detail": [
            "Compute 2x-1"
        ],
        "documentation": [
            "Computes the exponential value of 2 to the power of the source operand minus 1. The source operand is located in register ST(0) and the result is also stored in ST(0). The value of the source operand must lie in the range –1.0 to +1.0. If the source value is outside this range, the result is undefined.",
            "The following table shows the results obtained when computing the exponential value of various classes of numbers, assuming that neither overflow nor underflow occurs."
        ],
        "operands": [
            "reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/F2XM1.html"
        ]
    },
    "pmovzxbd": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "documentation": [
            "Legacy, VEX and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask.The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.d",
            "reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVZX.html"
        ]
    },
    "ffree": {
        "detail": [
            "Free Floating-Point Register"
        ],
        "documentation": [
            "Sets the tag in the FPU tag register associated with register ST(i) to empty (11B). The contents of ST(i) and the FPU stack-top pointer (TOP) are not affected.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FFREE.html"
        ]
    },
    "pushfw": {
        "detail": [
            "Push EFLAGS Register onto the Stack"
        ],
        "documentation": [
            "Decrements the stack pointer by 4 (if the current operand-size attribute is 32) and pushes the entire contents of the EFLAGS register onto the stack, or decrements the stack pointer by 2 (if the operand-size attribute is 16) and pushes the lower 16 bits of the EFLAGS register (that is, the FLAGS register) onto the stack. These instructions reverse the operation of the POPF/POPFD instructions.",
            "When copying the entire EFLAGS register to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead, the values for these flags are cleared in the EFLAGS image stored on the stack. See Chapter 3 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information about the EFLAGS register.",
            "The PUSHF (push flags) and PUSHFD (push flags double) mnemonics reference the same opcode. The PUSHF instruction is intended for use when the operand-size attribute is 16 and the PUSHFD instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when PUSHF is used and to 32 when PUSHFD is used. Others may treat these mnemonics as synonyms (PUSHF/PUSHFD) and use the current setting of the operand-size attribute to determine the size of values to be pushed from the stack, regardless of the mnemonic used.",
            "In 64-bit mode, the instruction’s default operation is to decrement the stack pointer (RSP) by 8 and pushes RFLAGS on the stack. 16-bit operation is supported using the operand size override prefix 66H. 32-bit operand size cannot be encoded in this mode. When copying RFLAGS to the stack, the VM and RF flags (bits 16 and 17) are not copied; instead, values for these flags are cleared in the RFLAGS image stored on the stack.",
            "When operating in virtual-8086 mode (EFLAGS.VM = 1) without the virtual-8086 mode extensions (CR4.VME = 0), the PUSHF/PUSHFD instructions can be used only if IOPL = 3; otherwise, a general-protection exception (#GP) occurs. If the virtual-8086 mode extensions are enabled (CR4.VME = 1), PUSHF (but not PUSHFD) can be executed in virtual-8086 mode with IOPL < 3.",
            "(The protected-mode virtual-interrupt feature — enabled by setting CR4.PVI — affects the CLI and STI instructions in the same manner as the virtual-8086 mode extensions. PUSHF, however, is not affected by CR4.PVI.)",
            "In the real-address mode, if the ESP or SP register is 1 when PUSHF/PUSHFD instruction executes: an #SS exception is generated but not delivered (the stack error reported prevents #SS delivery). Next, the processor generates a #DF exception and enters a shutdown state as described in the #DF discussion in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUSHF:PUSHFD:PUSHFQ.html"
        ]
    },
    "minps": {
        "detail": [
            "Minimum of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed single-precision floating-point values in the first source operand and the second source operand and returns the minimum value for each pair of values to the destination operand.",
            "If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MINPS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MINPS.html"
        ]
    },
    "pmovzxbq": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "documentation": [
            "Legacy, VEX and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask.The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.w",
            "reg.x, reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVZX.html"
        ]
    },
    "tdpbsud": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, reg, reg"
        ],
        "url": [
            "https://"
        ]
    },
    "vfmsubpd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "pmovzxbw": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "documentation": [
            "Legacy, VEX and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask.The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVZX.html"
        ]
    },
    "vpmovzxdq": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "documentation": [
            "Legacy, VEX and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask.The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVZX.html"
        ]
    },
    "t1mskc": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://"
        ]
    },
    "maskmovdqu": {
        "detail": [
            "Store Selected Bytes of Double Quadword"
        ],
        "documentation": [
            "Stores selected bytes from the source operand (first operand) into an 128-bit memory location. The mask operand (second operand) selects which bytes from the source operand are written to memory. The source and mask operands are XMM registers. The memory location specified by the effective address in the DI/EDI/RDI register (the default segment register is DS, but this may be overridden with a segment-override prefix). The memory location does not need to be aligned on a natural boundary. (The size of the store address depends on the address-size attribute.)",
            "The most significant bit in each byte of the mask operand determines whether the corresponding byte in the source operand is written to the corresponding byte location in memory: 0 indicates no write and 1 indicates write.",
            "The MASKMOVDQU instruction generates a non-temporal hint to the processor to minimize cache pollution. The non-temporal hint is implemented by using a write combining (WC) memory type protocol (see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10, of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MASKMOVDQU instructions if multiple processors might use different memory types to read/write the destination memory locations.",
            "Behavior with a mask of all 0s is as follows:"
        ],
        "operands": [
            "reg.x, reg.x, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MASKMOVDQU.html"
        ]
    },
    "vshuff64x2": {
        "detail": [
            "Shuffle Packed Values at 128-bit Granularity"
        ],
        "documentation": [
            "256-bit Version: Moves one of the two 128-bit packed single-precision floating-point values from the first source operand (second operand) into the low 128-bit of the destination operand (first operand); moves one of the two packed 128-bit floating-point values from the second source operand (third operand) into the high 128-bit of the destination operand. The selector operand (third operand) determines which values are moved to the destination operand.",
            "512-bit Version: Moves two of the four 128-bit packed single-precision floating-point values from the first source operand (second operand) into the low 256-bit of each double qword of the destination operand (first operand); moves two of the four packed 128-bit floating-point values from the second source operand (third operand) into the high 256-bit of the destination operand. The selector operand (third operand) determines which values are moved to the destination operand.",
            "The first source operand is a vector register. The second source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a vector register.",
            "The writemask updates the destination operand with the granularity of 32/64-bit data elements."
        ],
        "operands": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSHUFF32x4:VSHUFF64x2:VSHUFI32x4:VSHUFI64x2.html"
        ]
    },
    "iretd": {
        "detail": [
            "Interrupt Return"
        ],
        "documentation": [
            "Returns program control from an exception or interrupt handler to a program or procedure that was interrupted by an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform a return from a nested task. (A nested task is created when a CALL instruction is used to initiate a task switch or when an interrupt or exception causes a task switch to an interrupt or exception handler.) See the section titled “Task Linking” in Chapter 7 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.",
            "IRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt return double) is intended for use when returning from an interrupt when using the 32-bit operand size; however, most assemblers use the IRET mnemonic interchangeably for both operand sizes.",
            "In Real-Address Mode, the IRET instruction preforms a far return to the interrupted program or procedure. During this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.",
            "In Protected Mode, the action of the IRET instruction depends on the settings of the NT (nested task) and VM flags in the EFLAGS register and the VM flag in the EFLAGS image stored on the current stack. Depending on the setting of these flags, the processor performs the following types of interrupt returns:",
            "Flags Affected:",
            "All the flags and fields in the EFLAGS register are potentially modified, depending on the mode of operation of the processor. If performing a return from a nested task to a previous task, the EFLAGS register will be modified according to the EFLAGS image stored in the previous task’s TSS."
        ],
        "operands": [
            "reg.q, reg.q, mem.dx"
        ],
        "url": [
            "https://felixcloutier.com/x86/IRET:IRETD.html"
        ]
    },
    "vfmsubps": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "repne movsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.b, mem.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "encodekey128": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.d, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "repne movsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.d, mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "iretq": {
        "detail": [
            "Interrupt Return"
        ],
        "documentation": [
            "Returns program control from an exception or interrupt handler to a program or procedure that was interrupted by an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform a return from a nested task. (A nested task is created when a CALL instruction is used to initiate a task switch or when an interrupt or exception causes a task switch to an interrupt or exception handler.) See the section titled “Task Linking” in Chapter 7 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.",
            "IRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt return double) is intended for use when returning from an interrupt when using the 32-bit operand size; however, most assemblers use the IRET mnemonic interchangeably for both operand sizes.",
            "In Real-Address Mode, the IRET instruction preforms a far return to the interrupted program or procedure. During this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.",
            "In Protected Mode, the action of the IRET instruction depends on the settings of the NT (nested task) and VM flags in the EFLAGS register and the VM flag in the EFLAGS image stored on the current stack. Depending on the setting of these flags, the processor performs the following types of interrupt returns:",
            "Flags Affected:",
            "All the flags and fields in the EFLAGS register are potentially modified, depending on the mode of operation of the processor. If performing a return from a nested task to a previous task, the EFLAGS register will be modified according to the EFLAGS image stored in the previous task’s TSS."
        ],
        "operands": [
            "reg.q, reg.q, mem.wq"
        ],
        "url": [
            "https://felixcloutier.com/x86/IRET:IRETD.html"
        ]
    },
    "iretw": {
        "detail": [
            "Interrupt Return"
        ],
        "documentation": [
            "Returns program control from an exception or interrupt handler to a program or procedure that was interrupted by an exception, an external interrupt, or a software-generated interrupt. These instructions are also used to perform a return from a nested task. (A nested task is created when a CALL instruction is used to initiate a task switch or when an interrupt or exception causes a task switch to an interrupt or exception handler.) See the section titled “Task Linking” in Chapter 7 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.",
            "IRET and IRETD are mnemonics for the same opcode. The IRETD mnemonic (interrupt return double) is intended for use when returning from an interrupt when using the 32-bit operand size; however, most assemblers use the IRET mnemonic interchangeably for both operand sizes.",
            "In Real-Address Mode, the IRET instruction preforms a far return to the interrupted program or procedure. During this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.",
            "In Protected Mode, the action of the IRET instruction depends on the settings of the NT (nested task) and VM flags in the EFLAGS register and the VM flag in the EFLAGS image stored on the current stack. Depending on the setting of these flags, the processor performs the following types of interrupt returns:",
            "Flags Affected:",
            "All the flags and fields in the EFLAGS register are potentially modified, depending on the mode of operation of the processor. If performing a return from a nested task to a previous task, the EFLAGS register will be modified according to the EFLAGS image stored in the previous task’s TSS."
        ],
        "operands": [
            "reg.q, reg.q, mem.wq"
        ],
        "url": [
            "https://felixcloutier.com/x86/IRET:IRETD.html"
        ]
    },
    "encls": {
        "detail": [
            "Execute an Enclave System Function of Specified Leaf Number"
        ],
        "documentation": [
            "The ENCLS instruction invokes the specified privileged Intel SGX leaf function for managing and debugging enclaves. Software specifies the leaf function by setting the appropriate value in the register EAX as input. The registers RBX, RCX, and RDX have leaf-specific purpose, and may act as input, as output, or may be unused. In 64-bit mode, the instruction ignores upper 32 bits of the RAX register.",
            "The ENCLS instruction produces an invalid-opcode exception (#UD) if CR0.PE = 0 or RFLAGS.VM = 1, or if it is executed in system-management mode (SMM). Additionally, any attempt to execute the instruction when CPL > 0 results in #UD. The instruction produces a general-protection exception (#GP) if CR0.PG = 0 or if an attempt is made to invoke an undefined leaf function.",
            "In VMX non-root operation, execution of ENCLS may cause a VM exit if the “enable ENCLS exiting” VM-execution control is 1. In this case, execution of individual leaf functions of ENCLS is governed by the ENCLS-exiting bitmap field in the VMCS. Each bit in that field corresponds to the index of an ENCLS leaf function (as provided in EAX).",
            "Software in VMX root operation can thus intercept the invocation of various ENCLS leaf functions in VMX non-root operation by setting the “enable ENCLS exiting” VM-execution control and setting the corresponding bits in the ENCLS-exiting bitmap.",
            "Addresses and operands are 32 bits outside 64-bit mode (IA32_EFER.LMA = 0 || CS.L = 0) and are 64 bits in 64-bit mode (IA32_EFER.LMA = 1 || CS.L = 1). CS.D value has no impact on address calculation. The DS segment is used to create linear addresses.",
            "Segment override prefixes and address-size override prefixes are ignored, and is the REX prefix in 64-bit mode.",
            "Flags Affected:",
            "See individual leaf functions"
        ],
        "operands": [
            "reg, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/ENCLS.html"
        ]
    },
    "enclu": {
        "detail": [
            "Execute an Enclave User Function of Specified Leaf Number"
        ],
        "documentation": [
            "The ENCLU instruction invokes the specified non-privileged Intel SGX leaf functions. Software specifies the leaf function by setting the appropriate value in the register EAX as input. The registers RBX, RCX, and RDX have leaf-specific purpose, and may act as input, as output, or may be unused. In 64-bit mode, the instruction ignores upper 32 bits of the RAX register.",
            "The ENCLU instruction produces an invalid-opcode exception (#UD) if CR0.PE = 0 or RFLAGS.VM = 1, or if it is executed in system-management mode (SMM). Additionally, any attempt to execute this instruction when CPL < 3 results in #UD. The instruction produces a general-protection exception (#GP) if either CR0.PG or CR0.NE is 0, or if an attempt is made to invoke an undefined leaf function. The ENCLU instruction produces a device not available exception (#NM) if CR0.TS = 1.",
            "Addresses and operands are 32 bits outside 64-bit mode (IA32_EFER.LMA = 0 or CS.L = 0) and are 64 bits in 64-bit mode (IA32_EFER.LMA = 1 and CS.L = 1). CS.D value has no impact on address calculation. The DS segment is used to create linear addresses.",
            "Segment override prefixes and address-size override prefixes are ignored, as is the REX prefix in 64-bit mode.",
            "Flags Affected:",
            "See individual leaf functions"
        ],
        "operands": [
            "reg, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/ENCLU.html"
        ]
    },
    "repne movsq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.q, mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vrcp28sd": {
        "detail": [
            "Approximation to the Reciprocal of Scalar Double-Precision Floating-Point Value with Less Than 2^-28 Relative Error"
        ],
        "documentation": [
            "Computes the reciprocal approximation of the low float64 value in the second source operand (the third operand) and store the result to the destination operand (the first operand). The approximate reciprocal is evaluated with less than 2^-28 of maximum relative error. The result is written into the low float64 element of the destination operand according to the writemask k1. Bits 127:64 of the destination is copied from the corresponding bits of the first source operand (the second operand).",
            "A denormal input value is treated as zero and does not signal #DE, irrespective of MXCSR.DAZ. A denormal result is flushed to zero and does not signal #UE, irrespective of MXCSR.FTZ.",
            "If any source element is NaN, the quietized NaN source value is returned for that element. If any source element is ±∞, ±0.0 is returned for that element. Also, if any source element is ±0.0, ±∞ is returned for that element.",
            "The first source operand is an XMM register. The second source operand is an XMM register or a 64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRCP28SD.html"
        ]
    },
    "repne insb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.b, reg, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "repne insd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.d, reg, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "repne movsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.w, mem.w, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "syscall": {
        "detail": [
            "Fast System Call"
        ],
        "documentation": [
            "SYSCALL invokes an OS system-call handler at privilege level 0. It does so by loading RIP from the IA32_LSTAR MSR (after saving the address of the instruction following SYSCALL into RCX). (The WRMSR instruction ensures that the IA32_LSTAR MSR always contain a canonical address.)",
            "SYSCALL also saves RFLAGS into R11 and then masks RFLAGS using the IA32_FMASK MSR (MSR address C0000084H); specifically, the processor clears in RFLAGS every bit corresponding to a bit that is set in the IA32_FMASK MSR.",
            "SYSCALL loads the CS and SS selectors with values derived from bits 47:32 of the IA32_STAR MSR. However, the CS and SS descriptor caches are not loaded from the descriptors (in GDT or LDT) referenced by those selectors. Instead, the descriptor caches are loaded with fixed values. See the Operation section for details. It is the responsibility of OS software to ensure that the descriptors (in GDT or LDT) referenced by those selector values correspond to the fixed values loaded into the descriptor caches; the SYSCALL instruction does not ensure this correspondence.",
            "The SYSCALL instruction does not save the stack pointer (RSP). If the OS system-call handler will change the stack pointer, it is the responsibility of software to save the previous value of the stack pointer. This might be done prior to executing SYSCALL, with software restoring the stack pointer with the instruction following SYSCALL (which will be executed after SYSRET). Alternatively, the OS system-call handler may save the stack pointer and restore it before executing SYSRET.",
            "Instruction ordering. Instructions following a SYSCALL may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the SYSCALL have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).",
            "Flags Affected:",
            "All."
        ],
        "operands": [
            "reg.q, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/SYSCALL.html"
        ]
    },
    "popw": {
        "detail": [
            "Pop a Value from the Stack"
        ],
        "documentation": [
            "Loads the value from the top of the stack to the location specified with the destination operand (or explicit opcode) and then increments the stack pointer. The destination operand can be a general-purpose register, memory location, or segment register.",
            "Address and operand sizes are determined and used as follows:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg, reg.q, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/POP.html"
        ]
    },
    "fbstp": {
        "detail": [
            "Store BCD Integer and Pop"
        ],
        "documentation": [
            "Converts the value in the ST(0) register to an 18-digit packed BCD integer, stores the result in the destination operand, and pops the register stack. If the source value is a non-integral value, it is rounded to an integer value, according to rounding mode specified by the RC field of the FPU control word. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.",
            "The destination operand specifies the address where the first byte destination value is to be stored. The BCD value (including its sign bit) requires 10 bytes of space in memory.",
            "The following table shows the results obtained when storing various classes of numbers in packed BCD format."
        ],
        "operands": [
            "mem.wq, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FBSTP.html"
        ]
    },
    "sttilecfg": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.z"
        ],
        "url": [
            "https://"
        ]
    },
    "vpcmov": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vcvtpd2udq": {
        "detail": [
            "Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers"
        ],
        "documentation": [
            "Converts packed double-precision floating-point values in the source operand (the second operand) to packed unsigned doubleword integers in the destination operand (the first operand).",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w – 1 is returned, where w represents the number of bits in the destination format.",
            "The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1. The upper bits (MAXVL-1:256) of the corresponding destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.y, mem.z",
            "reg.y, reg.z",
            "reg.y, reg.q, mem.z",
            "reg.y, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTPD2UDQ.html"
        ]
    },
    "vrcp28ss": {
        "detail": [
            "Approximation to the Reciprocal of Scalar Single-Precision Floating-Point Value with Less Than 2^-28 Relative Error"
        ],
        "documentation": [
            "Computes the reciprocal approximation of the low float32 value in the second source operand (the third operand) and store the result to the destination operand (the first operand). The approximate reciprocal is evaluated with less than 2^-28 of maximum relative error prior to final rounding. The final result is rounded to < 2^-23 relative error before written into the low float32 element of the destination according to writemask k1. Bits 127:32 of the destination is copied from the corresponding bits of the first source operand (the second operand).",
            "A denormal input value is treated as zero and does not signal #DE, irrespective of MXCSR.DAZ. A denormal result is flushed to zero and does not signal #UE, irrespective of MXCSR.FTZ.",
            "If any source element is NaN, the quietized NaN source value is returned for that element. If any source element is ±∞, ±0.0 is returned for that element. Also, if any source element is ±0.0, ±∞ is returned for that element.",
            "The first source operand is an XMM register. The second source operand is an XMM register or a 32-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRCP28SS.html"
        ]
    },
    "repne insw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.w, reg, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "lock cmpxchg": {
        "detail": [
            "Compare and Exchange"
        ],
        "documentation": [
            "Compares the value in the AL, AX, EAX, or RAX register with the first operand (destination operand). If the two values are equal, the second operand (source operand) is loaded into the destination operand. Otherwise, the destination operand is loaded into the AL, AX, EAX or RAX register. RAX register is available only in 64-bit mode.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor’s bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The ZF flag is set if the values in the destination operand and register AL, AX, or EAX are equal; otherwise it is cleared. The CF, PF, AF, SF, and OF flags are set according to the results of the comparison operation."
        ],
        "operands": [
            "mem.b, reg.b, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPXCHG.html"
        ]
    },
    "vsubpd": {
        "detail": [
            "Subtract Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD subtract of the two, four or eight packed double-precision floating-point values of the second Source operand from the first Source operand, and stores the packed double-precision floating-point results in the destination operand.",
            "VEX.128 and EVEX.128 encoded versions: The second source operand is an XMM register or an 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX.512 encoded version: The second source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The first source operand and destination operands are ZMM registers. The destination operand is conditionally updated according to the writemask.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/SUBPD.html"
        ]
    },
    "packsswb": {
        "detail": [
            "Pack with Signed Saturation"
        ],
        "documentation": [
            "Converts packed signed word integers into packed signed byte integers (PACKSSWB) or converts packed signed doubleword integers into packed signed word integers (PACKSSDW), using saturation to handle overflow conditions. See Figure 4-6 for an example of the packing operation."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PACKSSWB:PACKSSDW.html"
        ]
    },
    "rdsspd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "encodekey256": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.d, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "stmxcsr": {
        "detail": [
            "Store MXCSR Register State"
        ],
        "documentation": [
            "Stores the contents of the MXCSR control and status register to the destination operand. The destination operand is a 32-bit memory location. The reserved bits in the MXCSR register are stored as 0s.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
            "VEX.L must be 0, otherwise instructions will #UD.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/STMXCSR.html"
        ]
    },
    "vsubps": {
        "detail": [
            "Subtract Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed single-precision floating-point values in the second Source operand from the First Source operand, and stores the packed single-precision floating-point results in the destination operand.",
            "VEX.128 and EVEX.128 encoded versions: The second source operand is an XMM register or an 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX.512 encoded version: The second source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The first source operand and destination operands are ZMM registers. The destination operand is conditionally updated according to the writemask.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/SUBPS.html"
        ]
    },
    "setnbe": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "rdsspq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "movupd": {
        "detail": [
            "Move Unaligned Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Note: VEX.vvvv and EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX.512 encoded version:",
            "Moves 512 bits of packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a ZMM register from a float64 memory location, to store the contents of a ZMM register into a memory. The destination operand is updated according to the writemask.",
            "VEX.256 encoded version:",
            "Moves 256 bits of packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers. Bits (MAXVL-1:256) of the destination register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVUPD.html"
        ]
    },
    "vpcmpb": {
        "detail": [
            "Compare Packed Byte Values Into Mask"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed byte values in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).",
            "VPCMPB performs a comparison between pairs of signed byte values.",
            "VPCMPUB performs a comparison between pairs of unsigned byte values.",
            "The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand (first operand) is a mask register k1. Up to 64/32/16 comparisons are performed with results written to the destination operand under the writemask k2.",
            "The comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table 5-17."
        ],
        "operands": [
            "reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.q, reg.x, reg.x, imm.b",
            "reg.q, reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPCMPB:VPCMPUB.html"
        ]
    },
    "bndcl": {
        "detail": [
            "Check Lower Bound"
        ],
        "documentation": [
            "Compare the address in the second operand with the lower bound in bnd. The second operand can be either a register or memory operand. If the address is lower than the lower bound in bnd.LB, it will set BNDSTATUS to 01H and signal a #BR exception.",
            "This instruction does not cause any memory access, and does not read or write any flags.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, reg.q",
            "reg, agen"
        ],
        "url": [
            "https://felixcloutier.com/x86/BNDCL.html"
        ]
    },
    "vpcmpd": {
        "detail": [
            "Compare Packed Integer Values into Mask"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed integer values in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).",
            "VPCMPD/VPCMPUD performs a comparison between pairs of signed/unsigned doubleword integer values.",
            "The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register k1. Up to 16/8/4 comparisons are performed with results written to the destination operand under the writemask k2.",
            "The comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table 5-17."
        ],
        "operands": [
            "reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.q, reg.z, reg.z, imm.b",
            "reg.q, reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.z, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPCMPD:VPCMPUD.html"
        ]
    },
    "bndcn": {
        "detail": [
            "Check Upper Bound"
        ],
        "documentation": [
            "Compare the address in the second operand with the upper bound in bnd. The second operand can be either a register or a memory operand. If the address is higher than the upper bound in bnd.UB, it will set BNDSTATUS to 01H and signal a #BR exception.",
            "BNDCU perform 1’s complement operation on the upper bound of bnd first before proceeding with address comparison. BNDCN perform address comparison directly using the upper bound in bnd that is already reverted out of 1’s complement form.",
            "This instruction does not cause any memory access, and does not read or write any flags.",
            "Effective address computation of m32/64 has identical behavior to LEA",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, reg.q",
            "reg, agen"
        ],
        "url": [
            "https://felixcloutier.com/x86/BNDCU:BNDCN.html"
        ]
    },
    "vpaddb": {
        "detail": [
            "Add Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.",
            "The PADDB and VPADDB instructions add packed byte integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 8 bits (overflow), the result is wrapped around and the low 8 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDW and VPADDW instructions add packed word integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 16 bits (overflow), the result is wrapped around and the low 16 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDD and VPADDD instructions add packed doubleword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 32 bits (overflow), the result is wrapped around and the low 32 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDQ and VPADDQ instructions add packed quadword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When a quadword result is too",
            "large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination operand (that is, the carry is ignored).",
            "Note that the (V)PADDB, (V)PADDW, (V)PADDD and (V)PADDQ instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values operated on.",
            "EVEX encoded VPADDD/Q: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "EVEX encoded VPADDB/W: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. the upper bits (MAXVL-1:256) of the destination are cleared.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html"
        ]
    },
    "vpaddd": {
        "detail": [
            "Add Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.",
            "The PADDB and VPADDB instructions add packed byte integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 8 bits (overflow), the result is wrapped around and the low 8 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDW and VPADDW instructions add packed word integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 16 bits (overflow), the result is wrapped around and the low 16 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDD and VPADDD instructions add packed doubleword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 32 bits (overflow), the result is wrapped around and the low 32 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDQ and VPADDQ instructions add packed quadword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When a quadword result is too",
            "large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination operand (that is, the carry is ignored).",
            "Note that the (V)PADDB, (V)PADDW, (V)PADDD and (V)PADDQ instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values operated on.",
            "EVEX encoded VPADDD/Q: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "EVEX encoded VPADDB/W: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. the upper bits (MAXVL-1:256) of the destination are cleared.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html"
        ]
    },
    "bndcu": {
        "detail": [
            "Check Upper Bound"
        ],
        "documentation": [
            "Compare the address in the second operand with the upper bound in bnd. The second operand can be either a register or a memory operand. If the address is higher than the upper bound in bnd.UB, it will set BNDSTATUS to 01H and signal a #BR exception.",
            "BNDCU perform 1’s complement operation on the upper bound of bnd first before proceeding with address comparison. BNDCN perform address comparison directly using the upper bound in bnd that is already reverted out of 1’s complement form.",
            "This instruction does not cause any memory access, and does not read or write any flags.",
            "Effective address computation of m32/64 has identical behavior to LEA",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, reg.q",
            "reg, agen"
        ],
        "url": [
            "https://felixcloutier.com/x86/BNDCU:BNDCN.html"
        ]
    },
    "movups": {
        "detail": [
            "Move Unaligned Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Note: VEX.vvvv and EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX.512 encoded version:",
            "Moves 512 bits of packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a ZMM register from a 512-bit float32 memory location, to store the contents of a ZMM register into memory. The destination operand is updated according to the writemask.",
            "VEX.256 and EVEX.256 encoded versions:",
            "Moves 256 bits of packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers. Bits (MAXVL-1:256) of the destination register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVUPS.html"
        ]
    },
    "vpcmpq": {
        "detail": [
            "Compare Packed Integer Values into Mask"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed integer values in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).",
            "VPCMPQ/VPCMPUQ performs a comparison between pairs of signed/unsigned quadword integer values.",
            "The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register k1. Up to 8/4/2 comparisons are performed with results written to the destination operand under the writemask k2.",
            "The comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table 5-17."
        ],
        "operands": [
            "reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.q, reg.z, reg.z, imm.b",
            "reg.q, reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.z, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPCMPQ:VPCMPUQ.html"
        ]
    },
    "vfmsubadd231pd": {
        "detail": [
            "Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFMSUBADD132PD: Multiplies the two, four, or eight packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the even double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMSUBADD213PD: Multiplies the two, four, or eight packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the even double-precision floating-point values in the third source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMSUBADD231PD: Multiplies the two, four, or eight packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the even double-precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUBADD132PD:VFMSUBADD213PD:VFMSUBADD231PD.html"
        ]
    },
    "vcvtph2ps": {
        "detail": [
            "Convert 16-bit FP values to Single-Precision FP values"
        ],
        "documentation": [
            "Converts packed half precision (16-bits) floating-point values in the low-order bits of the source operand (the second operand) to packed single-precision floating-point values and writes the converted values into the destination operand (the first operand).",
            "If case of a denormal operand, the correct normal result is returned. MXCSR.DAZ is ignored and is treated as if it 0. No denormal exception is reported on MXCSR.",
            "VEX.128 version: The source operand is a XMM register or 64-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 version: The source operand is a XMM register or 128-bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64-bits) register or a 256/128/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "The diagram below illustrates how data is converted from four packed half precision (in 64 bits) to four single precision (in 128 bits) FP values.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved (must be 1111b).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.z, mem.y",
            "reg.z, reg.y",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTPH2PS.html"
        ]
    },
    "fdecstp": {
        "detail": [
            "Decrement Stack-Top Pointer"
        ],
        "documentation": [
            "Subtracts one from the TOP field of the FPU status word (decrements the top-of-stack pointer). If the TOP field contains a 0, it is set to 7. The effect of this instruction is to rotate the stack by one position. The contents of the FPU data registers and tag register are not affected.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FDECSTP.html"
        ]
    },
    "vpaddq": {
        "detail": [
            "Add Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.",
            "The PADDB and VPADDB instructions add packed byte integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 8 bits (overflow), the result is wrapped around and the low 8 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDW and VPADDW instructions add packed word integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 16 bits (overflow), the result is wrapped around and the low 16 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDD and VPADDD instructions add packed doubleword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 32 bits (overflow), the result is wrapped around and the low 32 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDQ and VPADDQ instructions add packed quadword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When a quadword result is too",
            "large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination operand (that is, the carry is ignored).",
            "Note that the (V)PADDB, (V)PADDW, (V)PADDD and (V)PADDQ instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values operated on.",
            "EVEX encoded VPADDD/Q: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "EVEX encoded VPADDB/W: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. the upper bits (MAXVL-1:256) of the destination are cleared.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html"
        ]
    },
    "vpcmpw": {
        "detail": [
            "Compare Packed Word Values Into Mask"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed integer word in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).",
            "VPCMPW performs a comparison between pairs of signed word values.",
            "VPCMPUW performs a comparison between pairs of unsigned word values.",
            "The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand (first operand) is a mask register k1. Up to 32/16/8 comparisons are performed with results written to the destination operand under the writemask k2.",
            "The comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table 5-17."
        ],
        "operands": [
            "reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.q, reg.x, reg.x, imm.b",
            "reg.q, reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPCMPW:VPCMPUW.html"
        ]
    },
    "cvttss2si": {
        "detail": [
            "Convert with Truncation Scalar Single-Precision Floating-Point Value to Integer"
        ],
        "documentation": [
            "Converts a single-precision floating-point value in the source operand (the second operand) to a signed double-word integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand). The source operand can be an XMM register or a 32-bit memory location. The destination operand is a general purpose register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register.",
            "When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised. If this exception is masked, the indefinite integer value (80000000H or 80000000_00000000H if operand size is 64 bits) is returned.",
            "Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation. See the summary chart at the beginning of this section for encoding data and limits.",
            "VEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCVTTSS2SI is encoded with VEX.L=0. Encoding VCVTTSS2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTTSS2SI.html"
        ]
    },
    "pmovzxdq": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "documentation": [
            "Legacy, VEX and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask.The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVZX.html"
        ]
    },
    "vpaddw": {
        "detail": [
            "Add Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD add of the packed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.",
            "The PADDB and VPADDB instructions add packed byte integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 8 bits (overflow), the result is wrapped around and the low 8 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDW and VPADDW instructions add packed word integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 16 bits (overflow), the result is wrapped around and the low 16 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDD and VPADDD instructions add packed doubleword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When an individual result is too large to be represented in 32 bits (overflow), the result is wrapped around and the low 32 bits are written to the destination operand (that is, the carry is ignored).",
            "The PADDQ and VPADDQ instructions add packed quadword integers from the first source operand and second source operand and store the packed integer results in the destination operand. When a quadword result is too",
            "large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination operand (that is, the carry is ignored).",
            "Note that the (V)PADDB, (V)PADDW, (V)PADDD and (V)PADDQ instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values operated on.",
            "EVEX encoded VPADDD/Q: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "EVEX encoded VPADDB/W: The first source operand is a ZMM/YMM/XMM register. The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. the upper bits (MAXVL-1:256) of the destination are cleared.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html"
        ]
    },
    "vscatterpf1qpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint with Intent to Write"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "cache lines will be brought into exclusive state (RFO) specified by a locality hint (T1):"
        ],
        "operands": [
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCATTERPF1DPS:VSCATTERPF1QPS:VSCATTERPF1DPD:VSCATTERPF1QPD.html"
        ]
    },
    "vfmsubadd231ps": {
        "detail": [
            "Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFMSUBADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the corresponding packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements and adds the even single-precision floating-point values in the second source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMSUBADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the corresponding packed single-precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements and adds the even single-precision floating-point values in the third source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMSUBADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the corresponding packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements and adds the even single-precision floating-point values in the first source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUBADD132PS:VFMSUBADD213PS:VFMSUBADD231PS.html"
        ]
    },
    "setbe": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "pvalidate": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, reg, reg"
        ],
        "url": [
            "https://"
        ]
    },
    "fxam": {
        "detail": [
            "Examine Floating-Point"
        ],
        "documentation": [
            "Examines the contents of the ST(0) register and sets the condition code flags C0, C2, and C3 in the FPU status word to indicate the class of value or number in the register (see the table below)."
        ],
        "operands": [
            "reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FXAM.html"
        ]
    },
    "swapgs": {
        "detail": [
            "Swap GS Base Register"
        ],
        "documentation": [
            "SWAPGS exchanges the current GS base register value with the value contained in MSR address C0000102H (IA32_KERNEL_GS_BASE). The SWAPGS instruction is a privileged instruction intended for use by system software.",
            "When using SYSCALL to implement system calls, there is no kernel stack at the OS entry point. Neither is there a straightforward method to obtain a pointer to kernel structures from which the kernel stack pointer could be read. Thus, the kernel cannot save general purpose registers or reference memory.",
            "By design, SWAPGS does not require any general purpose registers or memory operands. No registers need to be saved before using the instruction. SWAPGS exchanges the CPL 0 data pointer from the IA32_KERNEL_GS_BASE MSR with the GS base register. The kernel can then use the GS prefix on normal memory references to access kernel data structures. Similarly, when the OS kernel is entered using an interrupt or exception (where the kernel stack is already set up), SWAPGS can be used to quickly get a pointer to the kernel data structures.",
            "The IA32_KERNEL_GS_BASE MSR itself is only accessible using RDMSR/WRMSR instructions. Those instructions are only accessible at privilege level 0. The WRMSR instruction ensures that the IA32_KERNEL_GS_BASE MSR contains a canonical address.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/SWAPGS.html"
        ]
    },
    "vscatterpf1qps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint with Intent to Write"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "cache lines will be brought into exclusive state (RFO) specified by a locality hint (T1):"
        ],
        "operands": [
            "mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCATTERPF1DPS:VSCATTERPF1QPS:VSCATTERPF1DPD:VSCATTERPF1QPD.html"
        ]
    },
    "pextrb": {
        "detail": [
            "Extract Byte/Dword/Qword"
        ],
        "documentation": [
            "Extract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a register, the upper bits of the register are zero extended.",
            "In legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros. PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.",
            "Note: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD. In EVEX.128 encoded versions, EVEX.vvvv is reserved and must be 1111b, EVEX.L”L must be",
            "0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRB/VPEXTRD is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.d, reg.x, imm.b",
            "mem.b, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PEXTRB:PEXTRD:PEXTRQ.html"
        ]
    },
    "pextrd": {
        "detail": [
            "Extract Byte/Dword/Qword"
        ],
        "documentation": [
            "Extract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a register, the upper bits of the register are zero extended.",
            "In legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros. PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.",
            "Note: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD. In EVEX.128 encoded versions, EVEX.vvvv is reserved and must be 1111b, EVEX.L”L must be",
            "0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRB/VPEXTRD is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.d, reg.x, imm.b",
            "mem.d, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PEXTRB:PEXTRD:PEXTRQ.html"
        ]
    },
    "vextractf64x2": {
        "detail": [
            "Extra ct Packed Floating-Point Values"
        ],
        "documentation": [
            "VEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of single-precision floating-point values from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand). The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor. The destination may be either a vector register or an 128-bit memory location.",
            "VEXTRACTF32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the writemask.",
            "VEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of double-precision floating-point values from the source operand (second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor The destination may be either a vector register or a 256-bit memory location.",
            "VEXTRACTF64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the writemask.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "The high 6 bits of the immediate are ignored.",
            "If VEXTRACTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "mem.x, reg.q, reg.y, imm.b",
            "reg.x, reg.y, imm.b",
            "reg.x, reg.q, reg.y, imm.b",
            "mem.x, reg.y, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VEXTRACTF128:VEXTRACTF32x4:VEXTRACTF64x2:VEXTRACTF32x8:VEXTRACTF64x4.html"
        ]
    },
    "aesenc": {
        "detail": [
            "Perform One Round of an AES Encryption Flow"
        ],
        "documentation": [
            "This instruction performs a single round of an AES encryption flow using a round key from the second source operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination operand.",
            "Use the AESENC instruction for all but the last encryption rounds. For the last encryption round, use the AESENCCLAST instruction.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/AESENC.html"
        ]
    },
    "vpshuflw": {
        "detail": [
            "Shuffle Packed Low Words"
        ],
        "documentation": [
            "Copies words from the low quadword of a 128-bit lane of the source operand and inserts them in the low quadword of the destination operand at word locations (of the respective lane) selected with the immediate operand. The 256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illustrated in Figure 4-16. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the immediate operand selects the contents of one word location in the low quadword of the destination operand. The binary encodings of the immediate operand fields select words (0, 1, 2 or 3) from the low quadword of the source operand to be copied to the destination operand. The high quadword of the source operand is copied to the high quadword of the destination operand, for each 128-bit lane.",
            "Note that this instruction permits a word in the low quadword of the source operand to be copied to more than one word location in the low quadword of the destination operand.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The destination operand is an YMM register. The source operand can be an YMM register or a 256-bit memory location.",
            "EVEX encoded version: The destination operand is a ZMM/YMM/XMM registers. The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the writemask.",
            "Note: In VEX encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, mem.x, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSHUFLW.html"
        ]
    },
    "vextractf64x4": {
        "detail": [
            "Extra ct Packed Floating-Point Values"
        ],
        "documentation": [
            "VEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of single-precision floating-point values from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand). The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor. The destination may be either a vector register or an 128-bit memory location.",
            "VEXTRACTF32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the writemask.",
            "VEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of double-precision floating-point values from the source operand (second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor The destination may be either a vector register or a 256-bit memory location.",
            "VEXTRACTF64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the writemask.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "The high 6 bits of the immediate are ignored.",
            "If VEXTRACTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "mem.y, reg.q, reg.z, imm.b",
            "reg.y, reg.z, imm.b",
            "reg.y, reg.q, reg.z, imm.b",
            "mem.y, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VEXTRACTF128:VEXTRACTF32x4:VEXTRACTF64x2:VEXTRACTF32x8:VEXTRACTF64x4.html"
        ]
    },
    "pextrq": {
        "detail": [
            "Extract Byte/Dword/Qword"
        ],
        "documentation": [
            "Extract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a register, the upper bits of the register are zero extended.",
            "In legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros. PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.",
            "Note: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD. In EVEX.128 encoded versions, EVEX.vvvv is reserved and must be 1111b, EVEX.L”L must be",
            "0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRB/VPEXTRD is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.x, imm.b",
            "mem.q, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PEXTRB:PEXTRD:PEXTRQ.html"
        ]
    },
    "pminsb": {
        "detail": [
            "Minimum of Packed Signed Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed signed byte, word, or dword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMINSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMINSB:PMINSW.html"
        ]
    },
    "pminsd": {
        "detail": [
            "Minimum of Packed Signed Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed signed dword or qword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMINSD:PMINSQ.html"
        ]
    },
    "pextrw": {
        "detail": [
            "Extract Word"
        ],
        "documentation": [
            "Copies the word in the source operand (second operand) specified by the count operand (third operand) to the destination operand (first operand). The source operand can be an MMX technology register or an XMM register. The destination operand can be the low word of a general-purpose register or a 16-bit memory address. The count operand is an 8-bit immediate. When specifying a word location in an MMX technology register, the 2 least-significant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the location. The content of the destination register above bit 16 is cleared (set to all 0s).",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). If the destination operand is a general-purpose register, the default operand size is 64-bits in 64-bit mode.",
            "Note: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD. In EVEX.128 encoded versions, EVEX.vvvv is reserved and must be 1111b, EVEX.L must be 0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRW is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.d, reg.q, imm.b",
            "mem.w, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PEXTRW.html"
        ]
    },
    "extrq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, reg.x",
            "reg.q, imm.b, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "xabort": {
        "detail": [
            "Transactional Abort"
        ],
        "documentation": [
            "XABORT forces an RTM abort. Following an RTM abort, the logical processor resumes execution at the fallback address computed through the outermost XBEGIN instruction. The EAX register is updated to reflect an XABORT instruction caused the abort, and the imm8 argument will be provided in bits 31:24 of EAX.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/XABORT.html"
        ]
    },
    "minsd": {
        "detail": [
            "Return Minimum Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Compares the low double-precision floating-point values in the first source operand and the second source operand, and returns the minimum value to the low quadword of the destination operand. When the source operand is a memory operand, only the 64 bits are accessed.",
            "If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, then SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second source) be returned, the action of MINSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.",
            "The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination operand is updated according to the writemask.",
            "Software should ensure VMINSD is encoded with VEX.L=0. Encoding VMINSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MINSD.html"
        ]
    },
    "vrcp14pd": {
        "detail": [
            "Compute Approximate Reciprocals of Packed Float64 Values"
        ],
        "documentation": [
            "This instruction performs a SIMD computation of the approximate reciprocals of eight/four/two packed double-precision floating-point values in the source operand (the second operand) and stores the packed double-precision floating-point results in the destination operand. The maximum relative error for this approximation is less than 2-14.",
            "The source operand can be a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register conditionally updated according to the writemask.",
            "The VRCP14PD instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ with the sign of the source value is returned. A denormal source value will be treated as zero only in case of DAZ bit set in MXCSR. Otherwise it is treated correctly (i.e. not as a 0.0). Underflow results are flushed to zero only in case of FTZ bit set in MXCSR. Otherwise it will be treated correctly (i.e. correct underflow result is written) with the sign of the operand. When a source value is a SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRCP14PD.html"
        ]
    },
    "fcomip": {
        "detail": [
            "Compare Floating Point Values and Set EFLAGS"
        ],
        "documentation": [
            "Performs an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and CF in the EFLAGS register according to the results (see the table below). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCOMI:FCOMIP:FUCOMI:FUCOMIP.html"
        ]
    },
    "vgatherpf0dpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T0):"
        ],
        "operands": [
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGATHERPF0DPS:VGATHERPF0QPS:VGATHERPF0DPD:VGATHERPF0QPD.html"
        ]
    },
    "pminsw": {
        "detail": [
            "Minimum of Packed Signed Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed signed byte, word, or dword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMINSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMINSB:PMINSW.html"
        ]
    },
    "minss": {
        "detail": [
            "Return Minimum Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Compares the low single-precision floating-point values in the first source operand and the second source operand and returns the minimum value to the low doubleword of the destination operand.",
            "If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN in either source operand be returned, the action of MINSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.",
            "The second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL:32) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded version: The first source operand is an xmm register encoded by (E)VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination operand is updated according to the writemask.",
            "Software should ensure VMINSS is encoded with VEX.L=0. Encoding VMINSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/MINSS.html"
        ]
    },
    "vrcp14ps": {
        "detail": [
            "Compute Approximate Reciprocals of Packed Float32 Values"
        ],
        "documentation": [
            "This instruction performs a SIMD computation of the approximate reciprocals of the packed single-precision floating-point values in the source operand (the second operand) and stores the packed single-precision floating-point results in the destination operand (the first operand). The maximum relative error for this approximation is less than 2-14.",
            "The source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register conditionally updated according to the writemask.",
            "The VRCP14PS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ with the sign of the source value is returned. A denormal source value will be treated as zero only in case of DAZ bit set in MXCSR. Otherwise it is treated correctly (i.e. not as a 0.0). Underflow results are flushed to zero only in case of FTZ bit set in MXCSR. Otherwise it will be treated correctly (i.e. correct underflow result is written) with the sign of the operand. When a source value is a SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRCP14PS.html"
        ]
    },
    "vgatherpf0dps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T0):"
        ],
        "operands": [
            "mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGATHERPF0DPS:VGATHERPF0QPS:VGATHERPF0DPD:VGATHERPF0QPD.html"
        ]
    },
    "vfmsubsd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.q, mem.q",
            "reg.x, reg.q, reg.q, reg.q",
            "reg.x, reg.q, mem.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "pavgb": {
        "detail": [
            "Average Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD average of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the results in the destination operand. For each corresponding pair of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary sum, and that result is shifted right one bit position.",
            "The (V)PAVGB instruction operates on packed unsigned bytes and the (V)PAVGW instruction operates on packed unsigned words.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register or a 512-bit memory location. The destination operand is a ZMM register.",
            "VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PAVGB:PAVGW.html"
        ]
    },
    "fninit": {
        "detail": [
            "Initialize Floating-Point Unit"
        ],
        "documentation": [
            "Sets the FPU control, status, tag, instruction pointer, and data pointer registers to their default states. The FPU control word is set to 037FH (round to nearest, all exceptions masked, 64-bit precision). The status word is cleared (no exception flags set, TOP is set to 0). The data registers in the register stack are left unchanged, but they are all tagged as empty (11B). Both the instruction and data pointers are cleared.",
            "The FINIT instruction checks for and handles any pending unmasked floating-point exceptions before performing the initialization; the FNINIT instruction does not.",
            "The assembler issues two instructions for the FINIT instruction (an FWAIT instruction followed by an FNINIT instruction), and the processor executes each of these instructions in separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FINIT:FNINIT.html"
        ]
    },
    "repe xcryptofb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.b, reg, reg.d, reg, reg.q, mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vphaddwd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpblendmb": {
        "detail": [
            "Blend Byte/Word Vectors Using an Opmask Control"
        ],
        "documentation": [
            "Performs an element-by-element blending of byte/word elements between the first source operand byte vector register and the second source operand byte vector from memory or register, using the instruction mask as selector. The result is written into the destination byte vector register.",
            "The destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit memory location.",
            "The mask is not used as a writemask for this instruction. Instead, the mask is used as an element selector: every element of the destination is conditionally selected between first source or second source using the value of the related mask bit (0 for first source, 1 for second source)."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPBLENDMB:VPBLENDMW.html"
        ]
    },
    "vfmsubss": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.d, reg.d, mem.d",
            "reg.x, reg.d, reg.d, reg.d",
            "reg.x, reg.d, mem.d, reg.d"
        ],
        "url": [
            "https://"
        ]
    },
    "vpblendmd": {
        "detail": [
            "Blend Int32/Int64 Vectors Using an OpMask Control"
        ],
        "documentation": [
            "Performs an element-by-element blending of dword/qword elements between the first source operand (the second operand) and the elements of the second source operand (the third operand) using an opmask register as select control. The blended result is written into the destination.",
            "The destination and first source operands are ZMM registers. The second source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location.",
            "The opmask register is not used as a writemask for this instruction. Instead, the mask is used as an element selector: every element of the destination is conditionally selected between first source or second source using the value of the related mask bit (0 for the first source operand, 1 for the second source operand).",
            "If EVEX.z is set, the elements with corresponding mask bit value of 0 in the destination operand are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPBLENDMD:VPBLENDMQ.html"
        ]
    },
    "sha1nexte": {
        "detail": [
            "Calculate SHA1 State Variable E after Four Rounds"
        ],
        "documentation": [
            "The SHA1NEXTE calculates the SHA1 state variable E after four rounds of operation from the current SHA1 state variable A in the destination operand. The calculated value of the SHA1 state variable E is added to the source operand, which contains the scheduled dwords.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/SHA1NEXTE.html"
        ]
    },
    "blcic": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://"
        ]
    },
    "pavgw": {
        "detail": [
            "Average Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD average of the packed unsigned integers from the source operand (second operand) and the destination operand (first operand), and stores the results in the destination operand. For each corresponding pair of data elements in the first and second operands, the elements are added together, a 1 is added to the temporary sum, and that result is shifted right one bit position.",
            "The (V)PAVGB instruction operates on packed unsigned bytes and the (V)PAVGW instruction operates on packed unsigned words.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register or a 512-bit memory location. The destination operand is a ZMM register.",
            "VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PAVGB:PAVGW.html"
        ]
    },
    "vphaddwq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "fucomip": {
        "detail": [
            "Compare Floating Point Values and Set EFLAGS"
        ],
        "documentation": [
            "Performs an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and CF in the EFLAGS register according to the results (see the table below). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCOMI:FCOMIP:FUCOMI:FUCOMIP.html"
        ]
    },
    "vpblendmq": {
        "detail": [
            "Blend Int32/Int64 Vectors Using an OpMask Control"
        ],
        "documentation": [
            "Performs an element-by-element blending of dword/qword elements between the first source operand (the second operand) and the elements of the second source operand (the third operand) using an opmask register as select control. The blended result is written into the destination.",
            "The destination and first source operands are ZMM registers. The second source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location.",
            "The opmask register is not used as a writemask for this instruction. Instead, the mask is used as an element selector: every element of the destination is conditionally selected between first source or second source using the value of the related mask bit (0 for the first source operand, 1 for the second source operand).",
            "If EVEX.z is set, the elements with corresponding mask bit value of 0 in the destination operand are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPBLENDMD:VPBLENDMQ.html"
        ]
    },
    "invlpg": {
        "detail": [
            "Invalidate TLB Entries"
        ],
        "documentation": [
            "Invalidates any translation lookaside buffer (TLB) entries specified with the source operand. The source operand is a memory address. The processor determines the page that contains that address and flushes all TLB entries for that page.1",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/INVLPG.html"
        ]
    },
    "vpblendmw": {
        "detail": [
            "Blend Byte/Word Vectors Using an Opmask Control"
        ],
        "documentation": [
            "Performs an element-by-element blending of byte/word elements between the first source operand byte vector register and the second source operand byte vector from memory or register, using the instruction mask as selector. The result is written into the destination byte vector register.",
            "The destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit memory location.",
            "The mask is not used as a writemask for this instruction. Instead, the mask is used as an element selector: every element of the destination is conditionally selected between first source or second source using the value of the related mask bit (0 for first source, 1 for second source)."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPBLENDMB:VPBLENDMW.html"
        ]
    },
    "phaddd": {
        "detail": [
            "Packed Horizontal Add"
        ],
        "documentation": [
            "(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and packs the 16-bit signed results to the destination operand (first operand). (V)PHADDD adds two adjacent 32-bit signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Note that these instructions can operate on either unsigned or signed (two’s complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.",
            "Legacy SSE instructions: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "In 64-bit mode, use the REX prefix to access additional registers.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: Horizontal addition of two adjacent data elements of the low 16-bytes of the first and second source operands are packed into the low 16-bytes of the destination operand. Horizontal addition of two adjacent data elements of the high 16-bytes of the first and second source operands are packed into the high 16-bytes of the destination operand. The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.",
            "Note: VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PHADDW:PHADDD.html"
        ]
    },
    "vfmsubadd132pd": {
        "detail": [
            "Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFMSUBADD132PD: Multiplies the two, four, or eight packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the even double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMSUBADD213PD: Multiplies the two, four, or eight packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the even double-precision floating-point values in the third source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMSUBADD231PD: Multiplies the two, four, or eight packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd double-precision floating-point elements and adds the even double-precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUBADD132PD:VFMSUBADD213PD:VFMSUBADD231PD.html"
        ]
    },
    "neg": {
        "detail": [
            "Two's Complement Negation"
        ],
        "documentation": [
            "Replaces the value of operand (the destination operand) with its two's complement. (This operation is equivalent to subtracting the operand from 0.) The destination operand is located in a general-purpose register or a memory location.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The CF flag set to 0 if the source operand is 0; otherwise it is set to 1. The OF, SF, ZF, AF, and PF flags are set according to the result."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/NEG.html"
        ]
    },
    "sldt": {
        "detail": [
            "Store Local Descriptor Table Register"
        ],
        "documentation": [
            "Stores the segment selector from the local descriptor table register (LDTR) in the destination operand. The destination operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the segment descriptor (located in the GDT) for the current LDT. This instruction can only be executed in protected mode.",
            "Outside IA-32e mode, when the destination operand is a 32-bit register, the 16-bit segment selector is copied into the low-order 16 bits of the register. The high-order 16 bits of the register are cleared for the Pentium 4, Intel Xeon, and P6 family processors. They are undefined for Pentium, Intel486, and Intel386 processors. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of the operand size.",
            "In compatibility mode, when the destination operand is a 32-bit register, the 16-bit segment selector is copied into the low-order 16 bits of the register. The high-order 16 bits of the register are cleared. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of the operand size.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). The behavior of SLDT with a 64-bit register is to zero-extend the 16-bit selector and store it in the register. If the destination is memory and operand size is 64, SLDT will write the 16-bit selector to memory as a 16-bit quantity, regardless of the operand size.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg",
            "mem.w, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/SLDT.html"
        ]
    },
    "phaddw": {
        "detail": [
            "Packed Horizontal Add"
        ],
        "documentation": [
            "(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and packs the 16-bit signed results to the destination operand (first operand). (V)PHADDD adds two adjacent 32-bit signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Note that these instructions can operate on either unsigned or signed (two’s complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.",
            "Legacy SSE instructions: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "In 64-bit mode, use the REX prefix to access additional registers.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: Horizontal addition of two adjacent data elements of the low 16-bytes of the first and second source operands are packed into the low 16-bytes of the destination operand. Horizontal addition of two adjacent data elements of the high 16-bytes of the first and second source operands are packed into the high 16-bytes of the destination operand. The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.",
            "Note: VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PHADDW:PHADDD.html"
        ]
    },
    "vfnmadd231pd": {
        "detail": [
            "Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMADD132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source operand to the two, four or eight packed double-precision floating-point values in the third source operand, adds the negated infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFNMADD213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source operand to the two, four or eight packed double-precision floating-point values in the first source operand, adds the negated infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFNMADD231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source to the two, four or eight packed double-precision floating-point values in the third source operand, the negated infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMADD132PD:VFNMADD213PD:VFNMADD231PD.html"
        ]
    },
    "vinsertf32x4": {
        "detail": [
            "Insert Packed Floating-Point Values"
        ],
        "documentation": [
            "VINSERTF128/VINSERTF32x4 and VINSERTF64x2 insert 128-bits of packed floating-point values from the second source operand (the third operand) into the destination operand (the first operand) at an 128-bit granularity offset multiplied by imm8[0] (256-bit) or imm8[1:0]. The remaining portions of the destination operand are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit memory location. The destination and first source operands are vector registers.",
            "VINSERTF32x4: The destination operand is a ZMM/YMM register and updated at 32-bit granularity according to the writemask. The high 6/7 bits of the immediate are ignored.",
            "VINSERTF64x2: The destination operand is a ZMM/YMM register and updated at 64-bit granularity according to the writemask. The high 6/7 bits of the immediate are ignored.",
            "VINSERTF32x8 and VINSERTF64x4 inserts 256-bits of packed floating-point values from the second source operand (the third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an YMM register or a 256-bit memory location. The high 7 bits of the immediate are ignored. The destination operand is a ZMM register and updated at 32/64-bit granularity according to the writemask."
        ],
        "operands": [
            "reg.z, reg.z, mem.x, imm.b",
            "reg.z, reg.q, reg.z, reg.x, imm.b",
            "reg.z, reg.q, reg.z, mem.x, imm.b",
            "reg.z, reg.z, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html"
        ]
    },
    "lar": {
        "detail": [
            "Load Access Rights Byte"
        ],
        "documentation": [
            "Loads the access rights from the segment descriptor specified by the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the flag register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. If the source operand is a memory address, only 16 bits of data are accessed. The destination operand is a general-purpose register.",
            "The processor performs access checks as part of the loading process. Once loaded in the destination register, software can perform additional checks on the access rights information.",
            "The access rights for a segment descriptor include fields located in the second doubleword (bytes 4–7) of the segment descriptor. The following fields are loaded by the LAR instruction:",
            "Flags Affected:",
            "The ZF flag is set to 1 if the access rights are loaded successfully; otherwise, it is cleared to 0."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/LAR.html"
        ]
    },
    "vfmsubadd132ps": {
        "detail": [
            "Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFMSUBADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the corresponding packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements and adds the even single-precision floating-point values in the second source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMSUBADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the corresponding packed single-precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements and adds the even single-precision floating-point values in the third source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMSUBADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the corresponding packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the odd single-precision floating-point elements and adds the even single-precision floating-point values in the first source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUBADD132PS:VFMSUBADD213PS:VFMSUBADD231PS.html"
        ]
    },
    "vinsertf32x8": {
        "detail": [
            "Insert Packed Floating-Point Values"
        ],
        "documentation": [
            "VINSERTF128/VINSERTF32x4 and VINSERTF64x2 insert 128-bits of packed floating-point values from the second source operand (the third operand) into the destination operand (the first operand) at an 128-bit granularity offset multiplied by imm8[0] (256-bit) or imm8[1:0]. The remaining portions of the destination operand are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit memory location. The destination and first source operands are vector registers.",
            "VINSERTF32x4: The destination operand is a ZMM/YMM register and updated at 32-bit granularity according to the writemask. The high 6/7 bits of the immediate are ignored.",
            "VINSERTF64x2: The destination operand is a ZMM/YMM register and updated at 64-bit granularity according to the writemask. The high 6/7 bits of the immediate are ignored.",
            "VINSERTF32x8 and VINSERTF64x4 inserts 256-bits of packed floating-point values from the second source operand (the third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an YMM register or a 256-bit memory location. The high 7 bits of the immediate are ignored. The destination operand is a ZMM register and updated at 32/64-bit granularity according to the writemask."
        ],
        "operands": [
            "reg.z, reg.z, mem.y, imm.b",
            "reg.z, reg.q, reg.z, reg.y, imm.b",
            "reg.z, reg.q, reg.z, mem.y, imm.b",
            "reg.z, reg.z, reg.y, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html"
        ]
    },
    "fxch": {
        "detail": [
            "Exchange Register Contents"
        ],
        "documentation": [
            "Exchanges the contents of registers ST(0) and ST(i). If no source operand is specified, the contents of ST(0) and ST(1) are exchanged.",
            "This instruction provides a simple means of moving values in the FPU register stack to the top of the stack [ST(0)], so that they can be operated on by those floating-point instructions that can only operate on values in ST(0). For example, the following instruction sequence takes the square root of the third register from the top of the register stack:",
            "FXCH ST(3);",
            "FSQRT;",
            "FXCH ST(3);",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FXCH.html"
        ]
    },
    "vsubsd": {
        "detail": [
            "Subtract Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Subtract the low double-precision floating-point value in the second source operand from the first source operand and stores the double-precision floating-point result in the low quadword of the destination operand.",
            "The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded versions: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination operand is updated according to the writemask.",
            "Software should ensure VSUBSD is encoded with VEX.L=0. Encoding VSUBSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/SUBSD.html"
        ]
    },
    "vfnmadd231ps": {
        "detail": [
            "Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFNMADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the first source operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting the four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFNMADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMADD132PS:VFNMADD213PS:VFNMADD231PS.html"
        ]
    },
    "vmovntdqa": {
        "detail": [
            "Load Double Quadword Non-Temporal Aligned Hint"
        ],
        "documentation": [
            "MOVNTDQA loads a double quadword from the source operand (second operand) to the destination operand (first operand) using a non-temporal hint if the memory source is WC (write combining) memory type. For WC memory type, the nontemporal hint may be implemented by loading a temporary internal buffer with the equivalent of an aligned cache line without filling this data to the cache. Any memory-type aliased lines in the cache will be snooped and flushed. Subsequent MOVNTDQA reads to unread portions of the WC cache line will receive data from the temporary internal buffer if data is available. The temporary internal buffer may be flushed by the processor at any time for any reason, for example:"
        ],
        "operands": [
            "reg.x, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVNTDQA.html"
        ]
    },
    "lock inc": {
        "detail": [
            "Increment by 1"
        ],
        "documentation": [
            "Adds 1 to the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (Use a ADD instruction with an immediate operand of 1 to perform an increment operation that does updates the CF flag.)",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, INC r16 and INC r32 are not encodable (because opcodes 40H through 47H are REX prefixes). Otherwise, the instruction’s 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits."
        ],
        "operands": [
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/INC.html"
        ]
    },
    "vsubss": {
        "detail": [
            "Subtract Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Subtract the low single-precision floating-point value from the second source operand and the first source operand and store the double-precision floating-point result in the low doubleword of the destination operand.",
            "The second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL-1:32) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded versions: Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination operand is updated according to the writemask.",
            "Software should ensure VSUBSS is encoded with VEX.L=0. Encoding VSUBSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/SUBSS.html"
        ]
    },
    "pminub": {
        "detail": [
            "Minimum of Packed Unsigned Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed unsigned byte or word integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMINUB: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMINUB:PMINUW.html"
        ]
    },
    "pminud": {
        "detail": [
            "Minimum of Packed Unsigned Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed unsigned dword/qword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMINUD:PMINUQ.html"
        ]
    },
    "fldln2": {
        "detail": [
            "Load Constant"
        ],
        "documentation": [
            "Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, π, log102, and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.",
            "See the section titled “Approximation of Pi” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a description of the π constant.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FLD1:FLDL2T:FLDL2E:FLDPI:FLDLG2:FLDLN2:FLDZ.html"
        ]
    },
    "jrcxz": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "stui": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.1"
        ],
        "url": [
            "https://"
        ]
    },
    "vfmsub231pd": {
        "detail": [
            "Fused Multiply-Subtract of Packed Double- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a set of SIMD multiply-subtract computation on packed double-precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.",
            "VFMSUB132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source operand to the two, four or eight packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMSUB213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source operand to the two, four or eight packed double-precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMSUB231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source to the two, four or eight packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUB132PD:VFMSUB213PD:VFMSUB231PD.html"
        ]
    },
    "movsb": {
        "detail": [
            "Move Data from String to String"
        ],
        "documentation": [
            "Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified with the first operand (destination operand). Both the source and destination operands are located in memory. The address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The address of the destination operand is read from the ES:EDI or the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the MOVS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source and destination operands should be symbols that indicate the size and location of the source value and the destination, respectively. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source and destination operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords), but they do not have to specify the correct location. The locations of the source and destination operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the move string instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the MOVS instructions. Here also DS:(E)SI and ES:(E)DI are assumed to be the source and destination operands, respectively. The size of the source and destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW (word move), or MOVSD (doubleword move).",
            "After the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incre-",
            "mented; if the DF flag is 1, the (E)SI and (E)DI registers are decremented.) The registers are incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "mem.b, mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVS:MOVSB:MOVSW:MOVSD:MOVSQ.html"
        ]
    },
    "fnstenv": {
        "detail": [
            "Store x87 FPU Environment"
        ],
        "documentation": [
            "Saves the current FPU operating environment at the memory location specified with the destination operand, and then masks all floating-point exceptions. The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.",
            "The FSTENV instruction checks for and handles any pending unmasked floating-point exceptions before storing the FPU environment; the FNSTENV instruction does not. The saved image reflects the state of the FPU after all floating-point instructions preceding the FSTENV/FNSTENV instruction in the instruction stream have been executed.",
            "These instructions are often used by exception handlers because they provide access to the FPU instruction and data pointers. The environment is typically saved in the stack. Masking all exceptions after saving the environment prevents floating-point exceptions from interrupting the exception handler.",
            "The assembler issues two instructions for the FSTENV instruction (an FWAIT instruction followed by an FNSTENV instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "mem.wdq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FSTENV:FNSTENV.html"
        ]
    },
    "movsd": {
        "detail": [
            "Move or Merge Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Moves a scalar double-precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be XMM registers or 64-bit memory locations. This instruction can be used to move a double-precision floating-point value to and from the low quadword of an XMM register and a 64-bit memory location, or to move a double-precision floating-point value between the low quadwords of two XMM registers. The instruction cannot be used to transfer data between memory locations.",
            "Legacy version: When the source and destination operands are XMM registers, bits MAXVL:64 of the destination operand remains unchanged. When the source operand is a memory location and destination operand is an XMM registers, the quadword at bits 127:64 of the destination operand is cleared to all 0s, bits MAXVL:128 of the destination operand remains unchanged.",
            "VEX and EVEX encoded register-register syntax: Moves a scalar double-precision floating-point value from the second source operand (the third operand) to the low quadword element of the destination operand (the first operand). Bits 127:64 of the destination operand are copied from the first source operand (the second operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX and EVEX encoded memory store syntax: When the source operand is a memory location and destination operand is an XMM registers, bits MAXVL:64 of the destination operand is cleared to all 0s.",
            "EVEX encoded versions: The low quadword of the destination is updated according to the writemask.",
            "Note: For VMOVSD (memory store and load forms), VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instruction will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "mem.d, mem.d",
            "reg.q, reg.q",
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVSD.html"
        ]
    },
    "vmfunc": {
        "detail": [
            "Invoke VM function"
        ],
        "documentation": [
            "This instruction allows software in VMX non-root operation to invoke a VM function, which is processor functionality enabled and configured by software in VMX root operation. The value of EAX selects the specific VM function being invoked.",
            "The behavior of each VM function (including any additional fault checking) is specified in Section 25.5.5, “VM Functions”.",
            "Flags Affected:",
            "Depends on the VM function specified in EAX. See Section 25.5.5, “VM Functions”."
        ],
        "operands": [
            "reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/VMFUNC.html"
        ]
    },
    "kortestb": {
        "detail": [
            "OR Masks And Set Flags"
        ],
        "documentation": [
            "Performs a bitwise OR between the vector mask register k2, and the vector mask register k1, and sets CF and ZF based on the operation result.",
            "ZF flag is set if both sources are 0x0. CF is set if, after the OR operation is done, the operation result is all 1’s.",
            "Flags Affected:",
            "The ZF flag is set if the result of OR-ing both sources is all 0s.",
            "The CF flag is set if the result of OR-ing both sources is all 1s.",
            "The OF, SF, AF, and PF flags are set to 0."
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KORTESTW:KORTESTB:KORTESTQ:KORTESTD.html"
        ]
    },
    "vgf2p8mulb": {
        "detail": [
            "Galois Field Multiply Bytes"
        ],
        "documentation": [
            "The instruction multiplies elements in the finite field GF(28), operating on a byte (field element) in the first source operand and the corresponding byte in a second source operand. The field GF(28) is represented in polynomial representation with the reduction polynomial x8 + x4 + x3 + x + 1.",
            "This instruction does not support broadcasting.",
            "The SSE encoded forms of the instruction require16B alignment on their memory operations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/GF2P8MULB.html"
        ]
    },
    "kortestd": {
        "detail": [
            "OR Masks And Set Flags"
        ],
        "documentation": [
            "Performs a bitwise OR between the vector mask register k2, and the vector mask register k1, and sets CF and ZF based on the operation result.",
            "ZF flag is set if both sources are 0x0. CF is set if, after the OR operation is done, the operation result is all 1’s.",
            "Flags Affected:",
            "The ZF flag is set if the result of OR-ing both sources is all 0s.",
            "The CF flag is set if the result of OR-ing both sources is all 1s.",
            "The OF, SF, AF, and PF flags are set to 0."
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KORTESTW:KORTESTB:KORTESTQ:KORTESTD.html"
        ]
    },
    "pminuw": {
        "detail": [
            "Minimum of Packed Unsigned Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed unsigned byte or word integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMINUB: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMINUB:PMINUW.html"
        ]
    },
    "vfmsub231ps": {
        "detail": [
            "Fused Multiply-Subtract of Packed Single- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a set of SIMD multiply-subtract computation on packed single-precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.",
            "VFMSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUB132PS:VFMSUB213PS:VFMSUB231PS.html"
        ]
    },
    "fcomi": {
        "detail": [
            "Compare Floating Point Values and Set EFLAGS"
        ],
        "documentation": [
            "Performs an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and CF in the EFLAGS register according to the results (see the table below). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCOMI:FCOMIP:FUCOMI:FUCOMIP.html"
        ]
    },
    "movsq": {
        "detail": [
            "Move Data from String to String"
        ],
        "documentation": [
            "Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified with the first operand (destination operand). Both the source and destination operands are located in memory. The address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The address of the destination operand is read from the ES:EDI or the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the MOVS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source and destination operands should be symbols that indicate the size and location of the source value and the destination, respectively. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source and destination operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords), but they do not have to specify the correct location. The locations of the source and destination operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the move string instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the MOVS instructions. Here also DS:(E)SI and ES:(E)DI are assumed to be the source and destination operands, respectively. The size of the source and destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW (word move), or MOVSD (doubleword move).",
            "After the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incre-",
            "mented; if the DF flag is 1, the (E)SI and (E)DI registers are decremented.) The registers are incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "mem.q, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVS:MOVSB:MOVSW:MOVSD:MOVSQ.html"
        ]
    },
    "movss": {
        "detail": [
            "Move or Merge Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Moves a scalar single-precision floating-point value from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be XMM registers or 32-bit memory locations. This instruction can be used to move a single-precision floating-point value to and from the low doubleword of an XMM register and a 32-bit memory location, or to move a single-precision floating-point value between the low doublewords of two XMM registers. The instruction cannot be used to transfer data between memory locations.",
            "Legacy version: When the source and destination operands are XMM registers, bits (MAXVL-1:32) of the corresponding destination register are unmodified. When the source operand is a memory location and destination operand is an XMM registers, Bits (127:32) of the destination operand is cleared to all 0s, bits MAXVL:128 of the destination operand remains unchanged.",
            "VEX and EVEX encoded register-register syntax: Moves a scalar single-precision floating-point value from the second source operand (the third operand) to the low doubleword element of the destination operand (the first operand). Bits 127:32 of the destination operand are copied from the first source operand (the second operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX and EVEX encoded memory load syntax: When the source operand is a memory location and destination operand is an XMM registers, bits MAXVL:32 of the destination operand is cleared to all 0s.",
            "EVEX encoded versions: The low doubleword of the destination is updated according to the writemask.",
            "Note: For memory store form instruction “VMOVSS m32, xmm1”, VEX.vvvv is reserved and must be 1111b otherwise instruction will #UD. For memory store form instruction “VMOVSS mv {k1}, xmm1”, EVEX.vvvv is reserved and must be 1111b otherwise instruction will #UD.",
            "Software should ensure VMOVSS is encoded with VEX.L=0. Encoding VMOVSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, mem.d",
            "reg.d, reg.d",
            "mem.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVSS.html"
        ]
    },
    "fcomp": {
        "detail": [
            "Compare Floating Point Values"
        ],
        "documentation": [
            "Compares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below). The source operand can be a data register or a memory location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is ignored, so that –0.0 is equal to +0.0."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg",
            "reg.wq, mem.q, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCOM:FCOMP:FCOMPP.html"
        ]
    },
    "movsw": {
        "detail": [
            "Move Data from String to String"
        ],
        "documentation": [
            "Moves the byte, word, or doubleword specified with the second operand (source operand) to the location specified with the first operand (destination operand). Both the source and destination operands are located in memory. The address of the source operand is read from the DS:ESI or the DS:SI registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). The address of the destination operand is read from the ES:EDI or the ES:DI registers (again depending on the address-size attribute of the instruction). The DS segment may be overridden with a segment override prefix, but the ES segment cannot be overridden.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the MOVS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source and destination operands should be symbols that indicate the size and location of the source value and the destination, respectively. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source and destination operand symbols must specify the correct type (size) of the operands (bytes, words, or doublewords), but they do not have to specify the correct location. The locations of the source and destination operands are always specified by the DS:(E)SI and ES:(E)DI registers, which must be loaded correctly before the move string instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the MOVS instructions. Here also DS:(E)SI and ES:(E)DI are assumed to be the source and destination operands, respectively. The size of the source and destination operands is selected with the mnemonic: MOVSB (byte move), MOVSW (word move), or MOVSD (doubleword move).",
            "After the move operation, the (E)SI and (E)DI registers are incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI and (E)DI register are incre-",
            "mented; if the DF flag is 1, the (E)SI and (E)DI registers are decremented.) The registers are incremented or decremented by 1 for byte operations, by 2 for word operations, or by 4 for doubleword operations.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "mem.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVS:MOVSB:MOVSW:MOVSD:MOVSQ.html"
        ]
    },
    "movsx": {
        "detail": [
            "Move with Sign-Extension"
        ],
        "documentation": [
            "Copies the contents of the source operand (register or memory location) to the destination operand (register) and sign extends the value to 16 or 32 bits (see Figure 7-6 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). The size of the converted value depends on the operand-size attribute.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, mem.b",
            "reg.w, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVSX:MOVSXD.html"
        ]
    },
    "kortestq": {
        "detail": [
            "OR Masks And Set Flags"
        ],
        "documentation": [
            "Performs a bitwise OR between the vector mask register k2, and the vector mask register k1, and sets CF and ZF based on the operation result.",
            "ZF flag is set if both sources are 0x0. CF is set if, after the OR operation is done, the operation result is all 1’s.",
            "Flags Affected:",
            "The ZF flag is set if the result of OR-ing both sources is all 0s.",
            "The CF flag is set if the result of OR-ing both sources is all 1s.",
            "The OF, SF, AF, and PF flags are set to 0."
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KORTESTW:KORTESTB:KORTESTQ:KORTESTD.html"
        ]
    },
    "kortestw": {
        "detail": [
            "OR Masks And Set Flags"
        ],
        "documentation": [
            "Performs a bitwise OR between the vector mask register k2, and the vector mask register k1, and sets CF and ZF based on the operation result.",
            "ZF flag is set if both sources are 0x0. CF is set if, after the OR operation is done, the operation result is all 1’s.",
            "Flags Affected:",
            "The ZF flag is set if the result of OR-ing both sources is all 0s.",
            "The CF flag is set if the result of OR-ing both sources is all 1s.",
            "The OF, SF, AF, and PF flags are set to 0."
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KORTESTW:KORTESTB:KORTESTQ:KORTESTD.html"
        ]
    },
    "clflushopt": {
        "detail": [
            "Flush Cache Line Optimized"
        ],
        "documentation": [
            "Invalidates from every level of the cache hierarchy in the cache coherence domain the cache line that contains the linear address specified with the memory operand. If that cache line contains modified data at any level of the cache hierarchy, that data is written back to memory. The source operand is a byte memory location.",
            "The availability of CLFLUSHOPT is indicated by the presence of the CPUID feature flag CLFLUSHOPT (CPUID.(EAX=7,ECX=0):EBX[bit 23]). The aligned cache line size affected is also indicated with the CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).",
            "The memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It should be noted that processors are free to speculatively fetch and cache data from system memory regions assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types). PREFETCHh instructions can be used to provide the processor with hints for this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, the CLFLUSH instruction is not ordered with respect to PREFETCHh instructions or any of the speculative fetching mechanisms (that is, data can be speculatively loaded into a cache line just before, during, or after the execution of a CLFLUSH instruction that references the cache line).",
            "Executions of the CLFLUSHOPT instruction are ordered with respect to fence instructions and to locked read-modify-write instructions; they are also ordered with respect to the following accesses to the cache line being invalidated: older writes and older executions of CLFLUSH. They are not ordered with respect to writes, executions of CLFLUSH that access other cache lines, or executions of CLFLUSHOPT regardless of cache line; to enforce CLFLUSHOPT ordering with any write, CLFLUSH, or CLFLUSHOPT operation, software can insert an SFENCE instruction between CLFLUSHOPT and that operation.",
            "The CLFLUSHOPT instruction can be used at all privilege levels and is subject to all permission checking and faults associated with a byte load (and in addition, a CLFLUSHOPT instruction is allowed to flush a linear address in an execute-only segment). Like a load, the CLFLUSHOPT instruction sets the A bit but not the D bit in the page tables.",
            "In some implementations, the CLFLUSHOPT instruction may always cause transactional abort with Transactional Synchronization Extensions (TSX). The CLFLUSHOPT instruction is not expected to be commonly used inside typical transactional regions. However, programmers must not rely on CLFLUSHOPT instruction to force a transactional abort, since whether they cause transactional abort is implementation dependent.",
            "CLFLUSHOPT operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "mem.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/CLFLUSHOPT.html"
        ]
    },
    "vcvtps2udq": {
        "detail": [
            "Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values"
        ],
        "documentation": [
            "Converts sixteen packed single-precision floating-point values in the source operand to sixteen unsigned double-word integers in the destination operand.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w – 1 is returned, where w represents the number of bits in the destination format.",
            "The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTPS2UDQ.html"
        ]
    },
    "vmulpd": {
        "detail": [
            "Multiply Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Multiply packed double-precision floating-point values from the first source operand with corresponding values in the second source operand, and stores the packed double-precision floating-point results in the destination operand.",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the destination YMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MULPD.html"
        ]
    },
    "repne stosb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.b, reg, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "repne stosd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.d, reg, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "fcmovb": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "documentation": [
            "Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Description column above and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).",
            "The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.",
            "A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “COMISS—Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS” in this chapter). If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCMOVcc.html"
        ]
    },
    "lock dec": {
        "detail": [
            "Decrement by 1"
        ],
        "documentation": [
            "Subtracts 1 from the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (To perform a decrement operation that updates the CF flag, use a SUB instruction with an immediate operand of 1.)",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, DEC r16 and DEC r32 are not encodable (because opcodes 48H through 4FH are REX prefixes). Otherwise, the instruction’s 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.",
            "See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The CF flag is not affected. The OF, SF, ZF, AF, and PF flags are set according to the result."
        ],
        "operands": [
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/DEC.html"
        ]
    },
    "vpackuswb": {
        "detail": [
            "Pack with Unsigned Saturation"
        ],
        "documentation": [
            "Converts 4, 8, 16 or 32 signed word integers from the destination operand (first operand) and 4, 8, 16 or 32 signed word integers from the source operand (second operand) into 8, 16, 32 or 64 unsigned byte integers and stores the result in the destination operand. (See Figure 4-6 for an example of the packing operation.) If a signed word integer value is beyond the range of an unsigned byte integer (that is, greater than FFH or less than 00H), the saturated unsigned byte integer value of FFH or 00H, respectively, is stored in the destination.",
            "EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register or a 512-bit memory location. The destination operand is a ZMM register.",
            "VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PACKUSWB.html"
        ]
    },
    "fcmove": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "documentation": [
            "Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Description column above and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).",
            "The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.",
            "A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “COMISS—Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS” in this chapter). If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCMOVcc.html"
        ]
    },
    "vmulps": {
        "detail": [
            "Multiply Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Multiply the packed single-precision floating-point values from the first source operand with the corresponding values in the second source operand, and stores the packed double-precision floating-point results in the destination operand.",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the destination YMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MULPS.html"
        ]
    },
    "repne stosq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.q, reg, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "repne stosw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.w, reg, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vrcp14sd": {
        "detail": [
            "Compute Approximate Reciprocal of Scalar Float64 Value"
        ],
        "documentation": [
            "This instruction performs a SIMD computation of the approximate reciprocal of the low double-precision floating-point value in the second source operand (the third operand) stores the result in the low quadword element of the destination operand (the first operand) according to the writemask k1. Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand (the second operand). The maximum relative error for this approximation is less than 2-14. The source operand can be an XMM register or a 64-bit memory location. The destination operand is an XMM register.",
            "The VRCP14SD instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ with the sign of the source value is returned. A denormal source value will be treated as zero only in case of DAZ bit set in MXCSR. Otherwise it is treated correctly (i.e. not as a 0.0). Underflow results are flushed to zero only in case of FTZ bit set in MXCSR. Otherwise it will be treated correctly (i.e. correct underflow result is written) with the sign of the operand. When a source value is a SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned. See Table 5-22 for special-case input values.",
            "MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported.",
            "A numerically exact implementation of VRCP14xx can be found at:"
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRCP14SD.html"
        ]
    },
    "psrld": {
        "detail": [
            "Shift Packed Data Right Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-19 gives an example of shifting words in a 64-bit operand.",
            "Note that only the low 64-bits of a 128-bit count operand are checked to compute the count.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html"
        ]
    },
    "vpdpbusds": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "fcmovu": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "documentation": [
            "Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Description column above and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).",
            "The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.",
            "A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “COMISS—Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS” in this chapter). If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCMOVcc.html"
        ]
    },
    "vgatherpf1dpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T1):"
        ],
        "operands": [
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGATHERPF1DPS:VGATHERPF1QPS:VGATHERPF1DPD:VGATHERPF1QPD.html"
        ]
    },
    "rol": {
        "detail": [
            "Rotate"
        ],
        "documentation": [
            "Shifts (rotates) the bits of the first operand (destination operand) the number of bit positions specified in the second operand (count operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the count operand is an unsigned integer that can be an immediate or a value in the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W = 1).",
            "The rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location.",
            "The RCL and RCR instructions include the CF flag in the rotation. The RCL instruction shifts the CF flag into the least-significant bit and shifts the most-significant bit into the CF flag. The RCR instruction shifts the CF flag into the most-significant bit and shifts the least-significant bit into the CF flag. For the ROL and ROR instructions, the original value of the CF flag is not a part of the result, but the CF flag receives a copy of the bit that was shifted from one end to the other.",
            "The OF flag is defined only for the 1-bit rotates; it is undefined in all other cases (except RCL and RCR instructions only: a zero-bit rotate does nothing, that is affects no flags). For left rotates, the OF flag is set to the exclusive OR of the CF bit (after the rotate) and the most-significant bit of the result. For right rotates, the OF flag is set to the exclusive OR of the two most-significant bits of the result.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Use of REX.W promotes the first operand to 64 bits and causes the count operand to become a 6-bit counter.",
            "Flags Affected:",
            "If the masked count is 0, the flags are not affected. If the masked count is 1, then the OF flag is affected, otherwise (masked count is greater than 1) the OF flag is undefined. The CF flag is affected when the masked count is nonzero. The SF, ZF, AF, and PF flags are always unaffected."
        ],
        "operands": [
            "mem.b, imm.b",
            "reg.b, reg",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/RCL:RCR:ROL:ROR.html"
        ]
    },
    "psrlq": {
        "detail": [
            "Shift Packed Data Right Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-19 gives an example of shifting words in a 64-bit operand.",
            "Note that only the low 64-bits of a 128-bit count operand are checked to compute the count.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html"
        ]
    },
    "ror": {
        "detail": [
            "Rotate"
        ],
        "documentation": [
            "Shifts (rotates) the bits of the first operand (destination operand) the number of bit positions specified in the second operand (count operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the count operand is an unsigned integer that can be an immediate or a value in the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W = 1).",
            "The rotate left (ROL) and rotate through carry left (RCL) instructions shift all the bits toward more-significant bit positions, except for the most-significant bit, which is rotated to the least-significant bit location. The rotate right (ROR) and rotate through carry right (RCR) instructions shift all the bits toward less significant bit positions, except for the least-significant bit, which is rotated to the most-significant bit location.",
            "The RCL and RCR instructions include the CF flag in the rotation. The RCL instruction shifts the CF flag into the least-significant bit and shifts the most-significant bit into the CF flag. The RCR instruction shifts the CF flag into the most-significant bit and shifts the least-significant bit into the CF flag. For the ROL and ROR instructions, the original value of the CF flag is not a part of the result, but the CF flag receives a copy of the bit that was shifted from one end to the other.",
            "The OF flag is defined only for the 1-bit rotates; it is undefined in all other cases (except RCL and RCR instructions only: a zero-bit rotate does nothing, that is affects no flags). For left rotates, the OF flag is set to the exclusive OR of the CF bit (after the rotate) and the most-significant bit of the result. For right rotates, the OF flag is set to the exclusive OR of the two most-significant bits of the result.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Use of REX.W promotes the first operand to 64 bits and causes the count operand to become a 6-bit counter.",
            "Flags Affected:",
            "If the masked count is 0, the flags are not affected. If the masked count is 1, then the OF flag is affected, otherwise (masked count is greater than 1) the OF flag is undefined. The CF flag is affected when the masked count is nonzero. The SF, ZF, AF, and PF flags are always unaffected."
        ],
        "operands": [
            "mem.b, imm.b",
            "reg.b, reg",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/RCL:RCR:ROL:ROR.html"
        ]
    },
    "vrcp14ss": {
        "detail": [
            "Compute Approximate Reciprocal of Scalar Float32 Value"
        ],
        "documentation": [
            "This instruction performs a SIMD computation of the approximate reciprocal of the low single-precision floating-point value in the second source operand (the third operand) and stores the result in the low quadword element of the destination operand (the first operand) according to the writemask k1. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand (the second operand). The maximum relative error for this approximation is less than 2-14. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register.",
            "The VRCP14SS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ with the sign of the source value is returned. A denormal source value will be treated as zero only in case of DAZ bit set in MXCSR. Otherwise it is treated correctly (i.e. not as a 0.0). Underflow results are flushed to zero only in case of FTZ bit set in MXCSR. Otherwise it will be treated correctly (i.e. correct underflow result is written) with the sign of the operand. When a source value is a SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned. See Table 5-23 for special-case input values.",
            "MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRCP14SS.html"
        ]
    },
    "psrlw": {
        "detail": [
            "Shift Packed Data Right Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-19 gives an example of shifting words in a 64-bit operand.",
            "Note that only the low 64-bits of a 128-bit count operand are checked to compute the count.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html"
        ]
    },
    "vfnmadd132pd": {
        "detail": [
            "Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMADD132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source operand to the two, four or eight packed double-precision floating-point values in the third source operand, adds the negated infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFNMADD213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source operand to the two, four or eight packed double-precision floating-point values in the first source operand, adds the negated infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFNMADD231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source to the two, four or eight packed double-precision floating-point values in the third source operand, the negated infinite precision intermediate result to the two, four or eight packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMADD132PD:VFNMADD213PD:VFNMADD231PD.html"
        ]
    },
    "vgatherpf1dps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "Lines prefetched are loaded into to a location in the cache hierarchy specified by a locality hint (T1):"
        ],
        "operands": [
            "mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGATHERPF1DPS:VGATHERPF1QPS:VGATHERPF1DPD:VGATHERPF1QPD.html"
        ]
    },
    "pushw": {
        "detail": [
            "Push Word, Doubleword or Quadword Onto the Stack"
        ],
        "documentation": [
            "Decrements the stack pointer and then stores the source operand on the top of the stack. Address and operand sizes are determined and used as follows:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg, reg.q, mem.w",
            "imm.w, reg.q, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUSH.html"
        ]
    },
    "enqcmds": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, mem.z"
        ],
        "url": [
            "https://"
        ]
    },
    "movntdqa": {
        "detail": [
            "Load Double Quadword Non-Temporal Aligned Hint"
        ],
        "documentation": [
            "MOVNTDQA loads a double quadword from the source operand (second operand) to the destination operand (first operand) using a non-temporal hint if the memory source is WC (write combining) memory type. For WC memory type, the nontemporal hint may be implemented by loading a temporary internal buffer with the equivalent of an aligned cache line without filling this data to the cache. Any memory-type aliased lines in the cache will be snooped and flushed. Subsequent MOVNTDQA reads to unread portions of the WC cache line will receive data from the temporary internal buffer if data is available. The temporary internal buffer may be flushed by the processor at any time for any reason, for example:"
        ],
        "operands": [
            "reg.x, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVNTDQA.html"
        ]
    },
    "vfnmadd132ps": {
        "detail": [
            "Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMADD132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFNMADD213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the first source operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting the four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFNMADD231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand, adds the negated infinite precision intermediate result to the four, eight or sixteen packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMADD132PS:VFNMADD213PS:VFNMADD231PS.html"
        ]
    },
    "vp4dpwssd": {
        "detail": [
            "Dot Product of Signed Words with Dword Accumulation (4-iterations)"
        ],
        "documentation": [
            "This instruction computes 4 sequential register source-block dot-products of two signed word operands with doubleword accumulation; see Figure 7-1 below. The memory operand is sequentially selected in each of the four steps.",
            "In the above box, the notation of “+3”' is used to denote that the instruction accesses 4 source registers based on that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.",
            "This instruction supports memory fault suppression. The entire memory operand is loaded if any bit of the lowest 16-bits of the mask is set to 1 or if a “no masking” encoding is used.",
            "The tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.z, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VP4DPWSSD.html"
        ]
    },
    "cvtpi2pd": {
        "detail": [
            "Convert Packed Dword Integers to Packed Double-Precision FP Values"
        ],
        "documentation": [
            "Converts two packed signed doubleword integers in the source operand (second operand) to two packed double-precision floating-point values in the destination operand (first operand).",
            "The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an XMM register. In addition, depending on the operand configuration:"
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTPI2PD.html"
        ]
    },
    "vfmsub132pd": {
        "detail": [
            "Fused Multiply-Subtract of Packed Double- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a set of SIMD multiply-subtract computation on packed double-precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.",
            "VFMSUB132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source operand to the two, four or eight packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMSUB213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source operand to the two, four or eight packed double-precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMSUB231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source to the two, four or eight packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the two, four or eight packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUB132PD:VFMSUB213PD:VFMSUB231PD.html"
        ]
    },
    "cvtpi2ps": {
        "detail": [
            "Convert Packed Dword Integers to Packed Single-Precision FP Values"
        ],
        "documentation": [
            "Converts two packed signed doubleword integers in the source operand (second operand) to two packed single-precision floating-point values in the destination operand (first operand).",
            "The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an XMM register. The results are stored in the low quadword of the destination operand, and the high quadword remains unchanged. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.",
            "This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTPI2PS instruction is executed.",
            "In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15)."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTPI2PS.html"
        ]
    },
    "vfmsub132ps": {
        "detail": [
            "Fused Multiply-Subtract of Packed Single- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a set of SIMD multiply-subtract computation on packed single-precision floating-point values using three source operands and writes the multiply-subtract results in the destination operand. The destination operand is also the first source operand. The second operand must be a SIMD register. The third source operand can be a SIMD register or a memory location.",
            "VFMSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the first source operand. From the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, subtracts the four, eight or sixteen packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUB132PS:VFMSUB213PS:VFMSUB231PS.html"
        ]
    },
    "punpcklbw": {
        "detail": [
            "Unpack Low Data"
        ],
        "documentation": [
            "Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-22 shows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.d",
            "reg.q, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html"
        ]
    },
    "vfnmadd231sd": {
        "detail": [
            "Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMADD132SD: Multiplies the low packed double-precision floating-point value from the first source operand to the low packed double-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFNMADD213SD: Multiplies the low packed double-precision floating-point value from the second source operand to the low packed double-precision floating-point value in the first source operand, adds the negated infinite precision intermediate result to the low packed double-precision floating-point value in the third source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFNMADD231SD: Multiplies the low packed double-precision floating-point value from the second source to the low packed double-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed double-precision floating-point value in the first source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMADD132SD:VFNMADD213SD:VFNMADD231SD.html"
        ]
    },
    "vpshrdvd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "ficomp": {
        "detail": [
            "Compare Integer"
        ],
        "documentation": [
            "Compares the value in ST(0) with an integer source operand and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results (see table below). The integer value is converted to double extended-precision floating-point format before the comparison is made."
        ],
        "operands": [
            "reg.wq, mem.d, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FICOM:FICOMP.html"
        ]
    },
    "vpermi2pd": {
        "detail": [
            "Full Permute From Two Tables Overwriting the Index"
        ],
        "documentation": [
            "Permutes 16-bit/32-bit/64-bit values in the second operand (the first source operand) and the third operand (the second source operand) using indices in the first operand to select elements from the second and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.",
            "The first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the result.",
            "D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).",
            "Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.",
            "Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.",
            "Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.",
            "Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. Note also that in this case, the same table can be reused for example for a second iteration, while the index elements are overwritten.",
            "Bits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMI2W:VPERMI2D:VPERMI2Q:VPERMI2PS:VPERMI2PD.html"
        ]
    },
    "vextractf128": {
        "detail": [
            "Extra ct Packed Floating-Point Values"
        ],
        "documentation": [
            "VEXTRACTF128/VEXTRACTF32x4 and VEXTRACTF64x2 extract 128-bits of single-precision floating-point values from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand). The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor. The destination may be either a vector register or an 128-bit memory location.",
            "VEXTRACTF32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the writemask.",
            "VEXTRACTF32x8 and VEXTRACTF64x4 extract 256-bits of double-precision floating-point values from the source operand (second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor The destination may be either a vector register or a 256-bit memory location.",
            "VEXTRACTF64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the writemask.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "The high 6 bits of the immediate are ignored.",
            "If VEXTRACTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "mem.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VEXTRACTF128:VEXTRACTF32x4:VEXTRACTF64x2:VEXTRACTF32x8:VEXTRACTF64x4.html"
        ]
    },
    "vpclmulqdq": {
        "detail": [
            "Carry-Less Multiplication Quadword"
        ],
        "documentation": [
            "Performs a carry-less multiplication of two quadwords, selected from the first source and second source operand according to the value of the immediate byte. Bits 4 and 0 are used to select which 64-bit half of each operand to use according to Table 4-13, other bits of the immediate byte are ignored."
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCLMULQDQ.html"
        ]
    },
    "vfnmadd231ss": {
        "detail": [
            "Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMADD132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFNMADD213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFNMADD231SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMADD132SS:VFNMADD213SS:VFNMADD231SS.html"
        ]
    },
    "vpshrdvq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpermt2d": {
        "detail": [
            "Full Permute from Two Tables Overwriting one Table"
        ],
        "documentation": [
            "Permutes 16-bit/32-bit/64-bit values in the first operand and the third operand (the second source operand) using indices in the second operand (the first source operand) to select elements from the first and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.",
            "The first and second operands are ZMM/YMM/XMM registers. The second operand contains input indices to select elements from the two input tables in the 1st and 3rd operands. The first operand is also the destination of the result.",
            "D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).",
            "Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.",
            "Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.",
            "Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.",
            "Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. Note also that in this case, the same index can be reused for example for a second iteration, while the table elements being permuted are overwritten.",
            "Bits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMT2W:VPERMT2D:VPERMT2Q:VPERMT2PS:VPERMT2PD.html"
        ]
    },
    "vpermt2b": {
        "detail": [
            "Full Permute of Bytes from Two Tables Overwriting a Table"
        ],
        "documentation": [
            "Permutes byte values from two tables, comprising of the first operand (also the destination operand) and the third operand (the second source operand). The second operand (the first source operand) provides byte indices to select byte results from the two tables. The selected byte elements are written to the destination at byte granularity under the writemask k1.",
            "The first and second operands are ZMM/YMM/XMM registers. The second operand contains input indices to select elements from the two input tables in the 1st and 3rd operands. The first operand is also the destination of the result. The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. In each index byte, the id bit for table selection is bit 6/5/4, and bits [5:0]/[4:0]/[3:0] selects element within each input table.",
            "Note that these instructions permit a byte value in the source operands to be copied to more than one location in the destination operand. Also, the second table and the indices can be reused in subsequent iterations, but the first table is overwritten.",
            "Bits (MAX_VL-1:256/128) of the destination are zeroed for VL=256,128."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMT2B.html"
        ]
    },
    "vpshrdvw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "packuswb": {
        "detail": [
            "Pack with Unsigned Saturation"
        ],
        "documentation": [
            "Converts 4, 8, 16 or 32 signed word integers from the destination operand (first operand) and 4, 8, 16 or 32 signed word integers from the source operand (second operand) into 8, 16, 32 or 64 unsigned byte integers and stores the result in the destination operand. (See Figure 4-6 for an example of the packing operation.) If a signed word integer value is beyond the range of an unsigned byte integer (that is, greater than FFH or less than 00H), the saturated unsigned byte integer value of FFH or 00H, respectively, is stored in the destination.",
            "EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand is a ZMM register or a 512-bit memory location. The destination operand is a ZMM register.",
            "VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PACKUSWB.html"
        ]
    },
    "fnsave": {
        "detail": [
            "Store x87 FPU State"
        ],
        "documentation": [
            "Stores the current FPU state (operating environment and register stack) at the specified destination in memory, and then re-initializes the FPU. The FSAVE instruction checks for and handles pending unmasked floating-point exceptions before storing the FPU state; the FNSAVE instruction does not.",
            "The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately follow the operating environment image.",
            "The saved image reflects the state of the FPU after all floating-point instructions preceding the FSAVE/FNSAVE instruction in the instruction stream have been executed.",
            "After the FPU state has been saved, the FPU is reset to the same default values it is set to with the FINIT/FNINIT instructions (see “FINIT/FNINIT—Initialize Floating-Point Unit” in this chapter).",
            "The FSAVE/FNSAVE instructions are typically used when the operating system needs to perform a context switch, an exception handler needs to use the FPU, or an application program needs to pass a “clean” FPU to a procedure.",
            "The assembler issues two instructions for the FSAVE instruction (an FWAIT instruction followed by an FNSAVE instruction), and the processor executes each of these instructions separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "mem.wdqxz, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FSAVE:FNSAVE.html"
        ]
    },
    "vpermi2ps": {
        "detail": [
            "Full Permute From Two Tables Overwriting the Index"
        ],
        "documentation": [
            "Permutes 16-bit/32-bit/64-bit values in the second operand (the first source operand) and the third operand (the second source operand) using indices in the first operand to select elements from the second and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.",
            "The first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the result.",
            "D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).",
            "Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.",
            "Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.",
            "Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.",
            "Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. Note also that in this case, the same table can be reused for example for a second iteration, while the index elements are overwritten.",
            "Bits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMI2W:VPERMI2D:VPERMI2Q:VPERMI2PS:VPERMI2PD.html"
        ]
    },
    "vptest": {
        "detail": [
            "Logical Compare"
        ],
        "documentation": [
            "PTEST and VPTEST set the ZF flag if all bits in the result are 0 of the bitwise AND of the first source operand (first operand) and the second source operand (second operand). VPTEST sets the CF flag if all bits in the result are 0 of the bitwise AND of the second source operand (second operand) and the logical NOT of the destination operand.",
            "The first source register is specified by the ModR/M reg field.",
            "128-bit versions: The first source register is an XMM register. The second source register can be an XMM register or a 128-bit memory location. The destination register is not modified.",
            "VEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination register is not modified.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
            "Flags Affected:",
            "The 0F, AF, PF, SF flags are cleared and the ZF, CF flags are set according to the operation."
        ],
        "operands": [
            "reg.x, reg.x",
            "reg.x, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PTEST.html"
        ]
    },
    "vpermt2q": {
        "detail": [
            "Full Permute from Two Tables Overwriting one Table"
        ],
        "documentation": [
            "Permutes 16-bit/32-bit/64-bit values in the first operand and the third operand (the second source operand) using indices in the second operand (the first source operand) to select elements from the first and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.",
            "The first and second operands are ZMM/YMM/XMM registers. The second operand contains input indices to select elements from the two input tables in the 1st and 3rd operands. The first operand is also the destination of the result.",
            "D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).",
            "Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.",
            "Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.",
            "Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.",
            "Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. Note also that in this case, the same index can be reused for example for a second iteration, while the table elements being permuted are overwritten.",
            "Bits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMT2W:VPERMT2D:VPERMT2Q:VPERMT2PS:VPERMT2PD.html"
        ]
    },
    "vcvtudq2pd": {
        "detail": [
            "Convert Packed Unsigned Doubleword Integers to Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Converts packed unsigned doubleword integers in the source operand (second operand) to packed double-precision floating-point values in the destination operand (first operand).",
            "The source operand is a YMM/XMM/XMM (low 64 bits) register, a 256/128/64-bit memory location or a 256/128/64-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Attempt to encode this instruction with EVEX embedded rounding is ignored.",
            "Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.y",
            "reg.z, reg.y",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTUDQ2PD.html"
        ]
    },
    "vpermt2w": {
        "detail": [
            "Full Permute from Two Tables Overwriting one Table"
        ],
        "documentation": [
            "Permutes 16-bit/32-bit/64-bit values in the first operand and the third operand (the second source operand) using indices in the second operand (the first source operand) to select elements from the first and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.",
            "The first and second operands are ZMM/YMM/XMM registers. The second operand contains input indices to select elements from the two input tables in the 1st and 3rd operands. The first operand is also the destination of the result.",
            "D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).",
            "Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.",
            "Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.",
            "Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.",
            "Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. Note also that in this case, the same index can be reused for example for a second iteration, while the table elements being permuted are overwritten.",
            "Bits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMT2W:VPERMT2D:VPERMT2Q:VPERMT2PS:VPERMT2PD.html"
        ]
    },
    "vfmsub231sd": {
        "detail": [
            "Fused Multiply-Subtract of Scalar Double- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD multiply-subtract computation on the low packed double-precision floating-point values using three source operands and writes the multiply-subtract result in the destination operand. The destination operand is also the first source operand. The second operand must be a XMM register. The third source operand can be a XMM register or a 64-bit memory location.",
            "VFMSUB132SD: Multiplies the low packed double-precision floating-point value from the first source operand to the low packed double-precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFMSUB213SD: Multiplies the low packed double-precision floating-point value from the second source operand to the low packed double-precision floating-point value in the first source operand. From the infinite precision intermediate result, subtracts the low packed double-precision floating-point value in the third source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFMSUB231SD: Multiplies the low packed double-precision floating-point value from the second source to the low packed double-precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed double-precision floating-point value in the first source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUB132SD:VFMSUB213SD:VFMSUB231SD.html"
        ]
    },
    "vfixupimmpd": {
        "detail": [
            "Fix Up Special Packed Float64 Values"
        ],
        "documentation": [
            "Perform fix-up of quad-word elements encoded in double-precision floating-point format in the first source operand (the second operand) using a 32-bit, two-level look-up table specified in the corresponding quadword element of the second source operand (the third operand) with exception reporting specifier imm8. The elements that are fixed-up are selected by mask bits of 1 specified in the opmask k1. Mask bits of 0 in the opmask k1 or table response action of 0000b preserves the corresponding element of the first operand. The fixed-up elements from the first source operand and the preserved element in the first operand are combined as the final results in the destination operand (the first operand).",
            "The destination and the first source operands are ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location.",
            "The two-level look-up table perform a fix-up of each DP FP input data in the first source operand by decoding the input data encoding into 8 token types. A response table is defined for each token type that converts the input encoding in the first source operand with one of 16 response actions.",
            "This instruction is specifically intended for use in fixing up the results of arithmetic calculations involving one source so that they match the spec, although it is generally useful for fixing up the results of multiple-instruction sequences to reflect special-number inputs. For example, consider rcp(0). Input 0 to rcp, and you should get INF according to the DX10 spec. However, evaluating rcp via Newton-Raphson, where x=approx(1/0), yields an incorrect result. To deal with this, VFIXUPIMMPD can be used after the N-R reciprocal sequence to set the result to the correct value (i.e. INF when the input is 0).",
            "If MXCSR.DAZ is not set, denormal input elements in the first source operand are considered as normal inputs and do not trigger any fixup nor fault reporting.",
            "Imm8 is used to set the required flags reporting. It supports #ZE and #IE fault reporting (see details below).",
            "MXCSR mask bits are ignored and are treated as if all mask bits are set to masked response). If any of the imm8 bits is set and the condition met for fault reporting, MXCSR.IE or MXCSR.ZE might be updated.",
            "This instruction is writemasked, so only those elements with the corresponding bit set in vector mask register k1 are computed and stored into zmm1. Elements in the destination with the corresponding bit clear in k1 retain their previous values or are set to 0."
        ],
        "operands": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFIXUPIMMPD.html"
        ]
    },
    "extractps": {
        "detail": [
            "Extract Packed Floating-Point Values"
        ],
        "documentation": [
            "Extracts a single-precision floating-point value from the source operand (second operand) at the 32-bit offset specified from imm8. Immediate bits higher than the most significant offset for the vector length are ignored.",
            "The extracted single-precision floating-point value is stored in the low 32-bits of the destination operand",
            "In 64-bit mode, destination register operand has default operand size of 64 bits. The upper 32-bits of the register are filled with zero. REX.W is ignored.",
            "VEX.128 and EVEX encoded version: When VEX.W1 or EVEX.W1 form is used in 64-bit mode with a general purpose register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits.",
            "VEX.vvvv/EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "128-bit Legacy SSE version: When a REX.W prefix is used in 64-bit mode with a general purpose register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits.",
            "The source register is an XMM register. Imm8[1:0] determine the starting DWORD offset from which to extract the 32-bit floating-point value.",
            "If VEXTRACTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.d, reg.x, imm.b",
            "mem.d, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/EXTRACTPS.html"
        ]
    },
    "aesdec128kl": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.xy"
        ],
        "url": [
            "https://"
        ]
    },
    "vcvtudq2ps": {
        "detail": [
            "Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Converts packed unsigned doubleword integers in the source operand (second operand) to single-precision floating-point values in the destination operand (first operand).",
            "The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTUDQ2PS.html"
        ]
    },
    "vpmovusqb": {
        "detail": [
            "Down Convert QWord to Byte"
        ],
        "documentation": [
            "VPMOVQB down converts 64-bit integer elements in the source operand (the second operand) into packed byte elements using truncation. VPMOVSQB converts signed 64-bit integers into packed signed bytes using signed saturation. VPMOVUSQB convert unsigned quad-word values into unsigned byte values using unsigned saturation. The source operand is a vector register. The destination operand is an XMM register or a memory location.",
            "Down-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:64) of the destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.z",
            "mem.q, reg.q, reg.z",
            "mem.q, reg.z",
            "reg.x, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVQB:VPMOVSQB:VPMOVUSQB.html"
        ]
    },
    "vpmovusqd": {
        "detail": [
            "Down Convert QWord to DWord"
        ],
        "documentation": [
            "VPMOVQW down converts 64-bit integer elements in the source operand (the second operand) into packed double-words using truncation. VPMOVSQW converts signed 64-bit integers into packed signed doublewords using signed saturation. VPMOVUSQW convert unsigned quad-word values into unsigned double-word values using unsigned saturation.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.",
            "Down-converted doubleword elements are written to the destination operand (the first operand) from the least-significant doubleword. Doubleword elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.y, reg.z",
            "mem.y, reg.q, reg.z",
            "mem.y, reg.z",
            "reg.y, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVQD:VPMOVSQD:VPMOVUSQD.html"
        ]
    },
    "vfmsub231ss": {
        "detail": [
            "Fused Multiply-Subtract of Scalar Single- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD multiply-subtract computation on the low packed single-precision floating-point values using three source operands and writes the multiply-subtract result in the destination operand. The destination operand is also the first source operand. The second operand must be a XMM register. The third source operand can be a XMM register or a 32-bit memory location.",
            "VFMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand. From the infinite precision intermediate result, subtracts the low packed single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low packed single-precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUB132SS:VFMSUB213SS:VFMSUB231SS.html"
        ]
    },
    "lea": {
        "detail": [
            "Load Effective Address"
        ],
        "documentation": [
            "Computes the effective address of the second operand (the source operand) and stores it in the first operand (destination operand). The source operand is a memory address (offset part) specified with one of the processors addressing modes; the destination operand is a general-purpose register. The address-size and operand-size attributes affect the action performed by this instruction, as shown in the following table. The operand-size attribute of the instruction is determined by the chosen register; the address-size attribute is determined by the attribute of the code segment.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.w, agen"
        ],
        "url": [
            "https://felixcloutier.com/x86/LEA.html"
        ]
    },
    "vmaskmovpd": {
        "detail": [
            "Conditional SIMD Packed Loads and Stores"
        ],
        "documentation": [
            "Conditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are specified in the first source operand.",
            "The mask bit for each data element is the most significant bit of that element in the first source operand. If a mask is 1, the corresponding data element is copied from the second source operand to the destination operand. If the mask is 0, the corresponding data element is set to zero in the load form of these instructions, and unmodified in the store form.",
            "The second source operand is a memory address for the load form of these instruction. The destination operand is a memory address for the store form of these instructions. The other operands are both XMM registers (for VEX.128 version) or YMM registers (for VEX.256 version).",
            "Faults occur only due to mask-bit required memory accesses that caused the faults. Faults will not occur due to referencing any memory location if the corresponding mask bit for that memory location is 0. For example, no faults will be detected if the mask bits are all zero.",
            "Unlike previous MASKMOV instructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to these instructions.",
            "Instruction behavior on alignment check reporting with mask bits of less than all 1s are the same as with mask bits of all 1s.",
            "VMASKMOV should not be used to access memory mapped I/O and un-cached memory as the access and the ordering of the individual loads or stores it does is implementation specific.",
            "In cases where mask bits indicate data should not be loaded or stored paging A and D bits will be set in an implementation dependent way. However, A and D bits are always set for pages where data is actually loaded/stored.",
            "Note: for load forms, the first source (the mask) is encoded in VEX.vvvv; the second source is encoded in rm_field, and the destination register is encoded in reg_field.",
            "Note: for store forms, the first source (the mask) is encoded in VEX.vvvv; the second source register is encoded in reg_field, and the destination memory location is encoded in rm_field."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "mem.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VMASKMOV.html"
        ]
    },
    "vfixupimmps": {
        "detail": [
            "Fix Up Special Packed Float32 Values"
        ],
        "documentation": [
            "Perform fix-up of doubleword elements encoded in single-precision floating-point format in the first source operand (the second operand) using a 32-bit, two-level look-up table specified in the corresponding doubleword element of the second source operand (the third operand) with exception reporting specifier imm8. The elements that are fixed-up are selected by mask bits of 1 specified in the opmask k1. Mask bits of 0 in the opmask k1 or table response action of 0000b preserves the corresponding element of the first operand. The fixed-up elements from the first source operand and the preserved element in the first operand are combined as the final results in the destination operand (the first operand).",
            "The destination and the first source operands are ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location.",
            "The two-level look-up table perform a fix-up of each SP FP input data in the first source operand by decoding the input data encoding into 8 token types. A response table is defined for each token type that converts the input encoding in the first source operand with one of 16 response actions.",
            "This instruction is specifically intended for use in fixing up the results of arithmetic calculations involving one source so that they match the spec, although it is generally useful for fixing up the results of multiple-instruction sequences to reflect special-number inputs. For example, consider rcp(0). Input 0 to rcp, and you should get INF according to the DX10 spec. However, evaluating rcp via Newton-Raphson, where x=approx(1/0), yields an incorrect result. To deal with this, VFIXUPIMMPS can be used after the N-R reciprocal sequence to set the result to the correct value (i.e. INF when the input is 0).",
            "If MXCSR.DAZ is not set, denormal input elements in the first source operand are considered as normal inputs and do not trigger any fixup nor fault reporting.",
            "Imm8 is used to set the required flags reporting. It supports #ZE and #IE fault reporting (see details below).",
            "MXCSR.DAZ is used and refer to zmm2 only (i.e. zmm1 is not considered as zero in case MXCSR.DAZ is set).",
            "MXCSR mask bits are ignored and are treated as if all mask bits are set to masked response). If any of the imm8 bits is set and the condition met for fault reporting, MXCSR.IE or MXCSR.ZE might be updated."
        ],
        "operands": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFIXUPIMMPS.html"
        ]
    },
    "vpdpbusd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vmwrite": {
        "detail": [
            "Write Field to Virtual-Machine Control Structure"
        ],
        "documentation": [
            "Writes the contents of a primary source operand (register or memory) to a specified field in a VMCS. In VMX root operation, the instruction writes to the current VMCS. If executed in VMX non-root operation, the instruction writes to the VMCS referenced by the VMCS link pointer field in the current VMCS.",
            "The VMCS field is specified by the VMCS-field encoding contained in the register secondary source operand. Outside IA-32e mode, the secondary source operand is always 32 bits, regardless of the value of CS.D. In 64-bit mode, the secondary source operand has 64 bits.",
            "The effective size of the primary source operand, which may be a register or in memory, is always 32 bits outside IA-32e mode (the setting of CS.D is ignored with respect to operand size) and 64 bits in 64-bit mode. If the VMCS field specified by the secondary source operand is shorter than this effective operand size, the high bits of the primary source operand are ignored. If the VMCS field is longer, then the high bits of the field are cleared to 0.",
            "Note that any faults resulting from accessing a memory source operand occur after determining, in the operation section below, that the relevant VMCS pointer is valid but before determining if the destination VMCS field is supported.",
            "Flags Affected:",
            "See the operation section and Section 30.2."
        ],
        "operands": [
            "reg.q, reg.q",
            "reg.q, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VMWRITE.html"
        ]
    },
    "vpmovusqw": {
        "detail": [
            "Down Convert QWord to Word"
        ],
        "documentation": [
            "VPMOVQW down converts 64-bit integer elements in the source operand (the second operand) into packed words using truncation. VPMOVSQW converts signed 64-bit integers into packed signed words using signed saturation. VPMOVUSQW convert unsigned quad-word values into unsigned word values using unsigned saturation.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit memory location.",
            "Down-converted word elements are written to the destination operand (the first operand) from the least-significant word. Word elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:128/64/32) of the register destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.z",
            "mem.x, reg.q, reg.z",
            "mem.x, reg.z",
            "reg.x, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVQW:VPMOVSQW:VPMOVUSQW.html"
        ]
    },
    "vmaskmovps": {
        "detail": [
            "Conditional SIMD Packed Loads and Stores"
        ],
        "documentation": [
            "Conditionally moves packed data elements from the second source operand into the corresponding data element of the destination operand, depending on the mask bits associated with each data element. The mask bits are specified in the first source operand.",
            "The mask bit for each data element is the most significant bit of that element in the first source operand. If a mask is 1, the corresponding data element is copied from the second source operand to the destination operand. If the mask is 0, the corresponding data element is set to zero in the load form of these instructions, and unmodified in the store form.",
            "The second source operand is a memory address for the load form of these instruction. The destination operand is a memory address for the store form of these instructions. The other operands are both XMM registers (for VEX.128 version) or YMM registers (for VEX.256 version).",
            "Faults occur only due to mask-bit required memory accesses that caused the faults. Faults will not occur due to referencing any memory location if the corresponding mask bit for that memory location is 0. For example, no faults will be detected if the mask bits are all zero.",
            "Unlike previous MASKMOV instructions (MASKMOVQ and MASKMOVDQU), a nontemporal hint is not applied to these instructions.",
            "Instruction behavior on alignment check reporting with mask bits of less than all 1s are the same as with mask bits of all 1s.",
            "VMASKMOV should not be used to access memory mapped I/O and un-cached memory as the access and the ordering of the individual loads or stores it does is implementation specific.",
            "In cases where mask bits indicate data should not be loaded or stored paging A and D bits will be set in an implementation dependent way. However, A and D bits are always set for pages where data is actually loaded/stored.",
            "Note: for load forms, the first source (the mask) is encoded in VEX.vvvv; the second source is encoded in rm_field, and the destination register is encoded in reg_field.",
            "Note: for store forms, the first source (the mask) is encoded in VEX.vvvv; the second source register is encoded in reg_field, and the destination memory location is encoded in rm_field."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "mem.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VMASKMOV.html"
        ]
    },
    "vpcmpestriq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, imm.b, reg, reg, reg",
            "reg.x, mem.x, imm.b, reg, reg, reg"
        ],
        "url": [
            "https://"
        ]
    },
    "vfnmsub213pd": {
        "detail": [
            "Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMSUB132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source operand to the two, four or eight packed double-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFNMSUB213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source operand to the two, four or eight packed double-precision floating-point values in the first source operand. From negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFNMSUB231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source to the two, four or eight packed double-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMSUB132PD:VFNMSUB213PD:VFNMSUB231PD.html"
        ]
    },
    "vmulsd": {
        "detail": [
            "Multiply Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Multiplies the low double-precision floating-point value in the second source operand by the low double-precision floating-point value in the first source operand, and stores the double-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source operand and the destination operands are XMM registers.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded version: The quadword at bits 127:64 of the destination operand is copied from the same bits of the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination operand is updated according to the writemask.",
            "Software should ensure VMULSD is encoded with VEX.L=0. Encoding VMULSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MULSD.html"
        ]
    },
    "punpckhqdq": {
        "detail": [
            "Unpack High Data"
        ],
        "documentation": [
            "Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. Figure 4-20 shows the unpack operation for bytes in 64-bit operands. The low-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html"
        ]
    },
    "vfnmsub213ps": {
        "detail": [
            "Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFNMSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the first source operand. From negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFNMSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMSUB132PS:VFNMSUB213PS:VFNMSUB231PS.html"
        ]
    },
    "vmulss": {
        "detail": [
            "Multiply Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Multiplies the low single-precision floating-point value from the second source operand by the low single-precision floating-point value in the first source operand, and stores the single-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 32-bit memory location. The first source operand and the destination operands are XMM registers.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 and EVEX encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The three high-order doublewords of the destination operand are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination operand is updated according to the writemask.",
            "Software should ensure VMULSS is encoded with VEX.L=0. Encoding VMULSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/MULSS.html"
        ]
    },
    "vgetmantpd": {
        "detail": [
            "Extract Float64 Vector of Normalized Mantissas from Float64 Vector"
        ],
        "documentation": [
            "Convert double-precision floating values in the source operand (the second operand) to DP FP values with the mantissa normalization and sign control specified by the imm8 byte, see Figure 5-15. The converted results are written to the destination operand (the first operand) using writemask k1. The normalized mantissa is specified by interv (imm8[1:0]) and the sign control (sc) is specified by bits 3:2 of the immediate byte.",
            "The destination operand is a ZMM/YMM/XMM register updated under the writemask. The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location."
        ],
        "operands": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGETMANTPD.html"
        ]
    },
    "vmovdqu8": {
        "detail": [
            "Move Unaligned Packed Integer Values"
        ],
        "documentation": [
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX encoded versions:",
            "Moves 128, 256 or 512 bits of packed byte/word/doubleword/quadword integer values from the source operand (the second operand) to the destination operand (first operand). This instruction can be used to load a vector register from a memory location, to store the contents of a vector register into a memory location, or to move data between two vector registers.",
            "The destination operand is updated at 8-bit (VMOVDQU8), 16-bit (VMOVDQU16), 32-bit (VMOVDQU32), or 64-bit (VMOVDQU64) granularity according to the writemask.",
            "VEX.256 encoded version:",
            "Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.",
            "Bits (MAXVL-1:256) of the destination register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "mem.x, reg.q, reg.x",
            "mem.x, reg.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html"
        ]
    },
    "vpand": {
        "detail": [
            "Logical AND"
        ],
        "documentation": [
            "Performs a bitwise logical AND operation on the first source operand and second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bits of the first and second operands are 1, otherwise it is set to 0.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 32/64-bit granularity.",
            "VEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PAND.html"
        ]
    },
    "lahf": {
        "detail": [
            "Load Status Flags into AH Register"
        ],
        "documentation": [
            "This instruction executes as described above in compatibility mode and legacy mode. It is valid in 64-bit mode only if CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1.",
            "Flags Affected:",
            "None. The state of the flags in the EFLAGS register is not affected."
        ],
        "operands": [
            "reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/LAHF.html"
        ]
    },
    "stc": {
        "detail": [
            "Set Carry Flag"
        ],
        "documentation": [
            "Sets the CF flag in the EFLAGS register. Operation is the same in all modes.",
            "Flags Affected:",
            "The CF flag is set. The OF, ZF, SF, AF, and PF flags are unaffected."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/STC.html"
        ]
    },
    "std": {
        "detail": [
            "Set Direction Flag"
        ],
        "documentation": [
            "Sets the DF flag in the EFLAGS register. When the DF flag is set to 1, string operations decrement the index registers (ESI and/or EDI). Operation is the same in all modes.",
            "Flags Affected:",
            "The DF flag is set. The CF, OF, ZF, SF, AF, and PF flags are unaffected."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/STD.html"
        ]
    },
    "pshufhw": {
        "detail": [
            "Shuffle Packed High Words"
        ],
        "documentation": [
            "Copies words from the high quadword of a 128-bit lane of the source operand and inserts them in the high quadword of the destination operand at word locations (of the respective lane) selected with the immediate operand. This 256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illustrated in Figure 4-16. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the immediate operand selects the contents of one word location in the high quadword of the destination operand. The binary encodings of the immediate operand fields select words (0, 1, 2 or 3, 4) from the high quadword of the source operand to be copied to the destination operand. The low quadword of the source operand is copied to the low quadword of the destination operand, for each 128-bit lane.",
            "Note that this instruction permits a word in the high quadword of the source operand to be copied to more than one word location in the high quadword of the destination operand.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.",
            "VEX.256 encoded version: The destination operand is an YMM register. The source operand can be an YMM register or a 256-bit memory location.",
            "EVEX encoded version: The destination operand is a ZMM/YMM/XMM registers. The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the writemask.",
            "Note: In VEX encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSHUFHW.html"
        ]
    },
    "vgetmantps": {
        "detail": [
            "Extract Float32 Vector of Normalized Mantissas from Float32 Vector"
        ],
        "documentation": [
            "Convert single-precision floating values in the source operand (the second operand) to SP FP values with the mantissa normalization and sign control specified by the imm8 byte, see Figure 5-15. The converted results are written to the destination operand (the first operand) using writemask k1. The normalized mantissa is specified by interv (imm8[1:0]) and the sign control (sc) is specified by bits 3:2 of the immediate byte.",
            "The destination operand is a ZMM/YMM/XMM register updated under the writemask. The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location.",
            "For each input SP FP value x, The conversion operation is:",
            "GetMant(x) = ±2k|x.significand|",
            "where:",
            "1 <= |x.significand| < 2",
            "Unbiased exponent k depends on the interval range defined by interv and whether the exponent of the source is even or odd. The sign of the final result is determined by sc and the source sign.",
            "if interv != 0 then k = -1, otherwise K = 0. The encoded value of imm8[1:0] and sign control are shown",
            "in Figure 5-15.",
            "Each converted SP FP result is encoded according to the sign control, the unbiased exponent k (adding bias) and a mantissa normalized to the range specified by interv.",
            "The GetMant() function follows Table 5-16 when dealing with floating-point special numbers.",
            "This instruction is writemasked, so only those elements with the corresponding bit set in vector mask register k1 are computed and stored into the destination. Elements in zmm1 with the corresponding bit clear in k1 retain their previous values.",
            "Note: EVEX.vvvv is reserved and must be 1111b, VEX.L must be 0; otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGETMANTPS.html"
        ]
    },
    "sti": {
        "detail": [
            "Set Interrupt Flag"
        ],
        "documentation": [
            "In most cases, STI sets the interrupt flag (IF) in the EFLAGS register. This allows the processor to respond to maskable hardware interrupts.",
            "If IF = 0, maskable hardware interrupts remain inhibited on the instruction boundary following an execution of STI. (The delayed effect of this instruction is provided to allow interrupts to be enabled just before returning from a procedure or subroutine. For instance, if an STI instruction is followed by an RET instruction, the RET instruction is allowed to execute before external interrupts are recognized. No interrupts can be recognized if an execution of CLI immediately follow such an execution of STI.) The inhibition ends after delivery of another event (e.g., exception) or the execution of the next instruction.",
            "The IF flag and the STI and CLI instructions do not prohibit the generation of exceptions and nonmaskable interrupts (NMIs). However, NMIs (and system-management interrupts) may be inhibited on the instruction boundary following an execution of STI that begins with IF = 0.",
            "Operation is different in two modes defined as follows:",
            "Flags Affected:",
            "Either the IF flag or the VIF flag is set to 1. Other flags are unaffected."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/STI.html"
        ]
    },
    "punpckldq": {
        "detail": [
            "Unpack Low Data"
        ],
        "documentation": [
            "Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-22 shows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.d",
            "reg.q, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html"
        ]
    },
    "llwpcb": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d"
        ],
        "url": [
            "https://"
        ]
    },
    "jbe": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "rorx": {
        "detail": [
            "Rotate Right Logical Without Affecting Flags"
        ],
        "documentation": [
            "Rotates the bits of second operand right by the count value specified in imm8 without affecting arithmetic flags. The RORX instruction does not read or write the arithmetic flags.",
            "This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.d, reg.d, imm.b",
            "reg.d, mem.d, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/RORX.html"
        ]
    },
    "str": {
        "detail": [
            "Store Task Register"
        ],
        "documentation": [
            "Stores the segment selector from the task register (TR) in the destination operand. The destination operand can be a general-purpose register or a memory location. The segment selector stored with this instruction points to the task state segment (TSS) for the currently running task.",
            "When the destination operand is a 32-bit register, the 16-bit segment selector is copied into the lower 16 bits of the register and the upper 16 bits of the register are cleared. When the destination operand is a memory location, the segment selector is written to memory as a 16-bit quantity, regardless of operand size.",
            "In 64-bit mode, operation is the same. The size of the memory operand is fixed at 16 bits. In register stores, the 2-byte TR is zero extended if stored to a 64-bit register.",
            "The STR instruction is useful only in operating-system software. It can only be executed in protected mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg",
            "mem.w, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/STR.html"
        ]
    },
    "pconfig": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "psubusb": {
        "detail": [
            "Subtract Packed Unsigned Integers with Unsigned Saturation"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed unsigned integers of the source operand (second operand) from the packed unsigned integers of the destination operand (first operand), and stores the packed unsigned integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs.",
            "These instructions can operate on either 64-bit or 128-bit operands.",
            "The (V)PSUBUSB instruction subtracts packed unsigned byte integers. When an individual byte result is less than zero, the saturated value of 00H is written to the destination operand.",
            "The (V)PSUBUSW instruction subtracts packed unsigned word integers. When an individual word result is less than zero, the saturated value of 0000H is written to the destination operand.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBUSB:PSUBUSW.html"
        ]
    },
    "vdppd": {
        "detail": [
            "Dot Product of Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Conditionally multiplies the packed double-precision floating-point values in the destination operand (first operand) with the packed double-precision floating-point values in the source (second operand) depending on a mask extracted from bits [5:4] of the immediate operand (third operand). If a condition mask bit is zero, the corresponding multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "The two resulting double-precision values are summed into an intermediate result. The intermediate result is conditionally broadcasted to the destination using a broadcast mask specified by bits [1:0] of the immediate byte.",
            "If a broadcast mask bit is “1”, the intermediate result is copied to the corresponding qword element in the destination operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.",
            "DPPD follows the NaN forwarding rules stated in the Software Developer’s Manual, vol. 1, table 4-7. These rules do not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally generated NaNs will have at least one NaN propagated to the destination.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "If VDPPD is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/DPPD.html"
        ]
    },
    "vfnmadd132sd": {
        "detail": [
            "Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMADD132SD: Multiplies the low packed double-precision floating-point value from the first source operand to the low packed double-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFNMADD213SD: Multiplies the low packed double-precision floating-point value from the second source operand to the low packed double-precision floating-point value in the first source operand, adds the negated infinite precision intermediate result to the low packed double-precision floating-point value in the third source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFNMADD231SD: Multiplies the low packed double-precision floating-point value from the second source to the low packed double-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed double-precision floating-point value in the first source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMADD132SD:VFNMADD213SD:VFNMADD231SD.html"
        ]
    },
    "vinsertf64x2": {
        "detail": [
            "Insert Packed Floating-Point Values"
        ],
        "documentation": [
            "VINSERTF128/VINSERTF32x4 and VINSERTF64x2 insert 128-bits of packed floating-point values from the second source operand (the third operand) into the destination operand (the first operand) at an 128-bit granularity offset multiplied by imm8[0] (256-bit) or imm8[1:0]. The remaining portions of the destination operand are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit memory location. The destination and first source operands are vector registers.",
            "VINSERTF32x4: The destination operand is a ZMM/YMM register and updated at 32-bit granularity according to the writemask. The high 6/7 bits of the immediate are ignored.",
            "VINSERTF64x2: The destination operand is a ZMM/YMM register and updated at 64-bit granularity according to the writemask. The high 6/7 bits of the immediate are ignored.",
            "VINSERTF32x8 and VINSERTF64x4 inserts 256-bits of packed floating-point values from the second source operand (the third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an YMM register or a 256-bit memory location. The high 7 bits of the immediate are ignored. The destination operand is a ZMM register and updated at 32/64-bit granularity according to the writemask."
        ],
        "operands": [
            "reg.y, reg.y, mem.x, imm.b",
            "reg.y, reg.q, reg.y, reg.x, imm.b",
            "reg.y, reg.q, reg.y, mem.x, imm.b",
            "reg.y, reg.y, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html"
        ]
    },
    "vinsertf64x4": {
        "detail": [
            "Insert Packed Floating-Point Values"
        ],
        "documentation": [
            "VINSERTF128/VINSERTF32x4 and VINSERTF64x2 insert 128-bits of packed floating-point values from the second source operand (the third operand) into the destination operand (the first operand) at an 128-bit granularity offset multiplied by imm8[0] (256-bit) or imm8[1:0]. The remaining portions of the destination operand are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit memory location. The destination and first source operands are vector registers.",
            "VINSERTF32x4: The destination operand is a ZMM/YMM register and updated at 32-bit granularity according to the writemask. The high 6/7 bits of the immediate are ignored.",
            "VINSERTF64x2: The destination operand is a ZMM/YMM register and updated at 64-bit granularity according to the writemask. The high 6/7 bits of the immediate are ignored.",
            "VINSERTF32x8 and VINSERTF64x4 inserts 256-bits of packed floating-point values from the second source operand (the third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an YMM register or a 256-bit memory location. The high 7 bits of the immediate are ignored. The destination operand is a ZMM register and updated at 32/64-bit granularity according to the writemask."
        ],
        "operands": [
            "reg.z, reg.z, mem.y, imm.b",
            "reg.z, reg.q, reg.z, reg.y, imm.b",
            "reg.z, reg.q, reg.z, mem.y, imm.b",
            "reg.z, reg.z, reg.y, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html"
        ]
    },
    "lfs": {
        "detail": [
            "Load Far Pointer"
        ],
        "documentation": [
            "Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16-bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS, SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand.",
            "If one of these instructions is executed in protected mode, additional information from the segment descriptor pointed to by the segment selector in the source operand is loaded in the hidden part of the selected segment register.",
            "Also in protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers without causing a protection exception. (Any subsequent reference to a segment whose corresponding segment register is loaded with a NULL selector, causes a general-protection exception (#GP) and no memory reference to the segment occurs.)",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.W promotes operation to specify a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.w, mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/LDS:LES:LFS:LGS:LSS.html"
        ]
    },
    "ldtilecfg": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.z"
        ],
        "url": [
            "https://"
        ]
    },
    "vdpps": {
        "detail": [
            "Dot Product of Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Conditionally multiplies the packed single precision floating-point values in the destination operand (first operand) with the packed single-precision floats in the source (second operand) depending on a mask extracted from the high 4 bits of the immediate byte (third operand). If a condition mask bit in Imm8[7:4] is zero, the corresponding multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "The four resulting single-precision values are summed into an intermediate result. The intermediate result is conditionally broadcasted to the destination using a broadcast mask specified by bits [3:0] of the immediate byte.",
            "If a broadcast mask bit is “1”, the intermediate result is copied to the corresponding dword element in the destination operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.",
            "DPPS follows the NaN forwarding rules stated in the Software Developer’s Manual, vol. 1, table 4-7. These rules do not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally generated NaNs will have at least one NaN propagated to the destination.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/DPPS.html"
        ]
    },
    "vfnmadd132ss": {
        "detail": [
            "Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMADD132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFNMADD213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFNMADD231SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the third source operand, adds the negated infinite precision intermediate result to the low packed single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMADD132SS:VFNMADD213SS:VFNMADD231SS.html"
        ]
    },
    "psubusw": {
        "detail": [
            "Subtract Packed Unsigned Integers with Unsigned Saturation"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed unsigned integers of the source operand (second operand) from the packed unsigned integers of the destination operand (first operand), and stores the packed unsigned integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with unsigned saturation, as described in the following paragraphs.",
            "These instructions can operate on either 64-bit or 128-bit operands.",
            "The (V)PSUBUSB instruction subtracts packed unsigned byte integers. When an individual byte result is less than zero, the saturated value of 00H is written to the destination operand.",
            "The (V)PSUBUSW instruction subtracts packed unsigned word integers. When an individual word result is less than zero, the saturated value of 0000H is written to the destination operand.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBUSB:PSUBUSW.html"
        ]
    },
    "cmpxchg8b": {
        "detail": [
            "Compare and Exchange Bytes"
        ],
        "documentation": [
            "Compares the 64-bit value in EDX:EAX (or 128-bit value in RDX:RAX if operand size is 128 bits) with the operand (destination operand). If the values are equal, the 64-bit value in ECX:EBX (or 128-bit value in RCX:RBX) is stored in the destination operand. Otherwise, the value in the destination operand is loaded into EDX:EAX (or RDX:RAX). The destination operand is an 8-byte memory location (or 16-byte memory location if operand size is 128 bits). For the EDX:EAX and ECX:EBX register pairs, EDX and ECX contain the high-order 32 bits and EAX and EBX contain the low-order 32 bits of a 64-bit value. For the RDX:RAX and RCX:RBX register pairs, RDX and RCX contain the high-order 64 bits and RAX and RBX contain the low-order 64bits of a 128-bit value.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically. To simplify the interface to the processor’s bus, the destination operand receives a write cycle without regard to the result of the comparison. The destination operand is written back if the comparison fails; otherwise, the source operand is written into the destination. (The processor never produces a locked read without also producing a locked write.)",
            "In 64-bit mode, default operation size is 64 bits. Use of the REX.W prefix promotes operation to 128 bits. Note that CMPXCHG16B requires that the destination (memory) operand be 16-byte aligned. See the summary chart at the beginning of this section for encoding data and limits. For information on the CPUID flag that indicates CMPXCHG16B, see page 3-213.",
            "Flags Affected:",
            "The ZF flag is set if the destination operand and EDX:EAX are equal; otherwise it is cleared. The CF, PF, AF, SF, and OF flags are unaffected."
        ],
        "operands": [
            "mem.q, reg, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPXCHG8B:CMPXCHG16B.html"
        ]
    },
    "clzero": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "stosb": {
        "detail": [
            "Store String"
        ],
        "documentation": [
            "In non-64-bit and default 64-bit mode; stores a byte, word, or doubleword from the AL, AX, or EAX register (respectively) into the destination operand. The destination operand is a memory location, the address of which is read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the mode of operation). The ES segment cannot be overridden with a segment override prefix.",
            "At the assembly-code level, two forms of the instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the STOS mnemonic) allows the destination operand to be specified explicitly. Here, the destination operand should be a symbol that indicates the size and location of the destination value. The source operand is then automatically selected to match the size of the destination operand (the AL register for byte operands, AX for word operands, EAX for doubleword operands). The explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI register. These must be loaded correctly before the store string instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, doubleword, and quadword versions of the STOS instructions. Here also ES:(E)DI is assumed to be the destination operand and AL, AX, or EAX is assumed to be the source operand. The size of the destination and source operands is selected by the mnemonic: STOSB (byte read from register AL), STOSW (word from AX), STOSD (doubleword from EAX).",
            "After the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the register is incremented; if the DF flag is 1, the register is decremented (the register is incremented or decremented by 1 for byte operations, by 2 for word operations, by 4 for doubleword operations).",
            "NOTE: To improve performance, more recent processors support modifications to the processor’s operation during the string store operations initiated with STOS and STOSB. See Section 7.3.9.3 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 for additional information on fast-string operation.",
            "In 64-bit mode, the default address size is 64 bits, 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits. The promoted no-operand mnemonic is STOSQ. STOSQ (and its explicit operands variant) store a quadword from the RAX register into the destination addressed by RDI or EDI. See the summary chart at the beginning of this section for encoding data and limits.",
            "The STOS, STOSB, STOSW, STOSD, STOSQ instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because data needs to be moved into the AL, AX, or EAX register before it can be stored. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.b, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/STOS:STOSB:STOSW:STOSD:STOSQ.html"
        ]
    },
    "vfmsub132sd": {
        "detail": [
            "Fused Multiply-Subtract of Scalar Double- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD multiply-subtract computation on the low packed double-precision floating-point values using three source operands and writes the multiply-subtract result in the destination operand. The destination operand is also the first source operand. The second operand must be a XMM register. The third source operand can be a XMM register or a 64-bit memory location.",
            "VFMSUB132SD: Multiplies the low packed double-precision floating-point value from the first source operand to the low packed double-precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFMSUB213SD: Multiplies the low packed double-precision floating-point value from the second source operand to the low packed double-precision floating-point value in the first source operand. From the infinite precision intermediate result, subtracts the low packed double-precision floating-point value in the third source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFMSUB231SD: Multiplies the low packed double-precision floating-point value from the second source to the low packed double-precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed double-precision floating-point value in the first source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUB132SD:VFMSUB213SD:VFMSUB231SD.html"
        ]
    },
    "stosd": {
        "detail": [
            "Store String"
        ],
        "documentation": [
            "In non-64-bit and default 64-bit mode; stores a byte, word, or doubleword from the AL, AX, or EAX register (respectively) into the destination operand. The destination operand is a memory location, the address of which is read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the mode of operation). The ES segment cannot be overridden with a segment override prefix.",
            "At the assembly-code level, two forms of the instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the STOS mnemonic) allows the destination operand to be specified explicitly. Here, the destination operand should be a symbol that indicates the size and location of the destination value. The source operand is then automatically selected to match the size of the destination operand (the AL register for byte operands, AX for word operands, EAX for doubleword operands). The explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI register. These must be loaded correctly before the store string instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, doubleword, and quadword versions of the STOS instructions. Here also ES:(E)DI is assumed to be the destination operand and AL, AX, or EAX is assumed to be the source operand. The size of the destination and source operands is selected by the mnemonic: STOSB (byte read from register AL), STOSW (word from AX), STOSD (doubleword from EAX).",
            "After the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the register is incremented; if the DF flag is 1, the register is decremented (the register is incremented or decremented by 1 for byte operations, by 2 for word operations, by 4 for doubleword operations).",
            "NOTE: To improve performance, more recent processors support modifications to the processor’s operation during the string store operations initiated with STOS and STOSB. See Section 7.3.9.3 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 for additional information on fast-string operation.",
            "In 64-bit mode, the default address size is 64 bits, 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits. The promoted no-operand mnemonic is STOSQ. STOSQ (and its explicit operands variant) store a quadword from the RAX register into the destination addressed by RDI or EDI. See the summary chart at the beginning of this section for encoding data and limits.",
            "The STOS, STOSB, STOSW, STOSD, STOSQ instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because data needs to be moved into the AL, AX, or EAX register before it can be stored. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/STOS:STOSB:STOSW:STOSD:STOSQ.html"
        ]
    },
    "cmovnbe": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "sub": {
        "detail": [
            "Subtract"
        ],
        "documentation": [
            "Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, register, or memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.",
            "The SUB instruction performs integer subtraction. It evaluates the result for both signed and unsigned integer operands and sets the OF and CF flags to indicate an overflow in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "Flags Affected:",
            "The OF, SF, ZF, AF, PF, and CF flags are set according to the result."
        ],
        "operands": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SUB.html"
        ]
    },
    "jmp far": {
        "detail": [
            "Jump"
        ],
        "documentation": [
            "Transfers program control to a different point in the instruction stream without recording return information. The destination (target) operand specifies the address of the instruction being jumped to. This operand can be an immediate value, a general-purpose register, or a memory location.",
            "This instruction can be used to execute four different types of jumps:",
            "Flags Affected:",
            "All flags are affected if a task switch occurs; no flags are affected if a task switch does not occur."
        ],
        "operands": [
            "mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/JMP.html"
        ]
    },
    "fcompp": {
        "detail": [
            "Compare Floating Point Values"
        ],
        "documentation": [
            "Compares the contents of register ST(0) and source value and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below). The source operand can be a data register or a memory location. If no source operand is given, the value in ST(0) is compared with the value in ST(1). The sign of zero is ignored, so that –0.0 is equal to +0.0."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCOM:FCOMP:FCOMPP.html"
        ]
    },
    "kxnorb": {
        "detail": [
            "Bitwise Logical XNOR Masks"
        ],
        "documentation": [
            "Performs a bitwise XNOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KXNORW:KXNORB:KXNORQ:KXNORD.html"
        ]
    },
    "kxnord": {
        "detail": [
            "Bitwise Logical XNOR Masks"
        ],
        "documentation": [
            "Performs a bitwise XNOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KXNORW:KXNORB:KXNORQ:KXNORD.html"
        ]
    },
    "vpsignb": {
        "detail": [
            "Packed SIGN"
        ],
        "documentation": [
            "(V)PSIGNB/(V)PSIGNW/(V)PSIGND negates each data element of the destination operand (the first operand) if the signed integer value of the corresponding data element in the source operand (the second operand) is less than zero. If the signed integer value of a data element in the source operand is positive, the corresponding data element in the destination operand is unchanged. If a data element in the source operand is zero, the corresponding data element in the destination operand is set to zero.",
            "(V)PSIGNB operates on signed bytes. (V)PSIGNW operates on 16-bit signed words. (V)PSIGND operates on signed 32-bit integers. When the source operand is a 128bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Legacy SSE instructions: Both operands can be MMX registers. In 64-bit mode, use the REX prefix to access additional registers.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise instructions will #UD.",
            "VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand is an YMM register or a 256-bit memory location."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSIGNB:PSIGNW:PSIGND.html"
        ]
    },
    "rsm": {
        "detail": [
            "Resume from System Management Mode"
        ],
        "documentation": [
            "Returns program control from system management mode (SMM) to the application program or operating-system procedure that was interrupted when the processor received an SMM interrupt. The processor’s state is restored from the dump created upon entering SMM. If the processor detects invalid state information during state restoration, it enters the shutdown state. The following invalid information can cause a shutdown:",
            "Flags Affected:",
            "All."
        ],
        "operands": [
            "reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/RSM.html"
        ]
    },
    "vpsignd": {
        "detail": [
            "Packed SIGN"
        ],
        "documentation": [
            "(V)PSIGNB/(V)PSIGNW/(V)PSIGND negates each data element of the destination operand (the first operand) if the signed integer value of the corresponding data element in the source operand (the second operand) is less than zero. If the signed integer value of a data element in the source operand is positive, the corresponding data element in the destination operand is unchanged. If a data element in the source operand is zero, the corresponding data element in the destination operand is set to zero.",
            "(V)PSIGNB operates on signed bytes. (V)PSIGNW operates on 16-bit signed words. (V)PSIGND operates on signed 32-bit integers. When the source operand is a 128bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Legacy SSE instructions: Both operands can be MMX registers. In 64-bit mode, use the REX prefix to access additional registers.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise instructions will #UD.",
            "VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand is an YMM register or a 256-bit memory location."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSIGNB:PSIGNW:PSIGND.html"
        ]
    },
    "vfmsub132ss": {
        "detail": [
            "Fused Multiply-Subtract of Scalar Single- Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD multiply-subtract computation on the low packed single-precision floating-point values using three source operands and writes the multiply-subtract result in the destination operand. The destination operand is also the first source operand. The second operand must be a XMM register. The third source operand can be a XMM register or a 32-bit memory location.",
            "VFMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand. From the infinite precision intermediate result, subtracts the low packed single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low packed single-precision floating-point value in the third source operand. From the infinite precision intermediate result, subtracts the low packed single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMSUB132SS:VFMSUB213SS:VFMSUB231SS.html"
        ]
    },
    "stosq": {
        "detail": [
            "Store String"
        ],
        "documentation": [
            "In non-64-bit and default 64-bit mode; stores a byte, word, or doubleword from the AL, AX, or EAX register (respectively) into the destination operand. The destination operand is a memory location, the address of which is read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the mode of operation). The ES segment cannot be overridden with a segment override prefix.",
            "At the assembly-code level, two forms of the instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the STOS mnemonic) allows the destination operand to be specified explicitly. Here, the destination operand should be a symbol that indicates the size and location of the destination value. The source operand is then automatically selected to match the size of the destination operand (the AL register for byte operands, AX for word operands, EAX for doubleword operands). The explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI register. These must be loaded correctly before the store string instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, doubleword, and quadword versions of the STOS instructions. Here also ES:(E)DI is assumed to be the destination operand and AL, AX, or EAX is assumed to be the source operand. The size of the destination and source operands is selected by the mnemonic: STOSB (byte read from register AL), STOSW (word from AX), STOSD (doubleword from EAX).",
            "After the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the register is incremented; if the DF flag is 1, the register is decremented (the register is incremented or decremented by 1 for byte operations, by 2 for word operations, by 4 for doubleword operations).",
            "NOTE: To improve performance, more recent processors support modifications to the processor’s operation during the string store operations initiated with STOS and STOSB. See Section 7.3.9.3 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 for additional information on fast-string operation.",
            "In 64-bit mode, the default address size is 64 bits, 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits. The promoted no-operand mnemonic is STOSQ. STOSQ (and its explicit operands variant) store a quadword from the RAX register into the destination addressed by RDI or EDI. See the summary chart at the beginning of this section for encoding data and limits.",
            "The STOS, STOSB, STOSW, STOSD, STOSQ instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because data needs to be moved into the AL, AX, or EAX register before it can be stored. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.q, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/STOS:STOSB:STOSW:STOSD:STOSQ.html"
        ]
    },
    "sidt": {
        "detail": [
            "Store Interrupt Descriptor Table Register"
        ],
        "documentation": [
            "Stores the content the interrupt descriptor table register (IDTR) in the destination operand. The destination operand specifies a 6-byte memory location.",
            "In non-64-bit modes, the 16-bit limit field of the register is stored in the low 2 bytes of the memory location and the 32-bit base address is stored in the high 4 bytes.",
            "In 64-bit mode, the operand size fixed at 8+2 bytes. The instruction stores 8-byte base and 2-byte limit values.",
            "SIDT is only useful in operating-system software; however, it can be used in application programs without causing an exception to be generated if CR4.UMIP = 0. See “LGDT/LIDT—Load Global/Interrupt Descriptor Table Register” in Chapter 3, Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A, for information on loading the GDTR and IDTR.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/SIDT.html"
        ]
    },
    "pop": {
        "detail": [
            "Pop a Value from the Stack"
        ],
        "documentation": [
            "Loads the value from the top of the stack to the location specified with the destination operand (or explicit opcode) and then increments the stack pointer. The destination operand can be a general-purpose register, memory location, or segment register.",
            "Address and operand sizes are determined and used as follows:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.w, reg.q, mem.w",
            "reg.w, reg.q, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/POP.html"
        ]
    },
    "stosw": {
        "detail": [
            "Store String"
        ],
        "documentation": [
            "In non-64-bit and default 64-bit mode; stores a byte, word, or doubleword from the AL, AX, or EAX register (respectively) into the destination operand. The destination operand is a memory location, the address of which is read from either the ES:EDI or ES:DI register (depending on the address-size attribute of the instruction and the mode of operation). The ES segment cannot be overridden with a segment override prefix.",
            "At the assembly-code level, two forms of the instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the STOS mnemonic) allows the destination operand to be specified explicitly. Here, the destination operand should be a symbol that indicates the size and location of the destination value. The source operand is then automatically selected to match the size of the destination operand (the AL register for byte operands, AX for word operands, EAX for doubleword operands). The explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the destination operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the ES:(E)DI register. These must be loaded correctly before the store string instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, doubleword, and quadword versions of the STOS instructions. Here also ES:(E)DI is assumed to be the destination operand and AL, AX, or EAX is assumed to be the source operand. The size of the destination and source operands is selected by the mnemonic: STOSB (byte read from register AL), STOSW (word from AX), STOSD (doubleword from EAX).",
            "After the byte, word, or doubleword is transferred from the register to the memory location, the (E)DI register is incremented or decremented according to the setting of the DF flag in the EFLAGS register. If the DF flag is 0, the register is incremented; if the DF flag is 1, the register is decremented (the register is incremented or decremented by 1 for byte operations, by 2 for word operations, by 4 for doubleword operations).",
            "NOTE: To improve performance, more recent processors support modifications to the processor’s operation during the string store operations initiated with STOS and STOSB. See Section 7.3.9.3 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 for additional information on fast-string operation.",
            "In 64-bit mode, the default address size is 64 bits, 32-bit address size is supported using the prefix 67H. Using a REX prefix in the form of REX.W promotes operation on doubleword operand to 64 bits. The promoted no-operand mnemonic is STOSQ. STOSQ (and its explicit operands variant) store a quadword from the RAX register into the destination addressed by RDI or EDI. See the summary chart at the beginning of this section for encoding data and limits.",
            "The STOS, STOSB, STOSW, STOSD, STOSQ instructions can be preceded by the REP prefix for block loads of ECX bytes, words, or doublewords. More often, however, these instructions are used within a LOOP construct because data needs to be moved into the AL, AX, or EAX register before it can be stored. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.w, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/STOS:STOSB:STOSW:STOSD:STOSQ.html"
        ]
    },
    "por": {
        "detail": [
            "Bitwise Logical OR"
        ],
        "documentation": [
            "Performs a bitwise logical OR operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is set to 1 if either or both of the corresponding bits of the first and second operands are 1; otherwise, it is set to 0.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source and destination operands can be XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source and destination operands can be XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source and destination operands can be YMM registers.",
            "EVEX encoded version: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 32/64-bit granularity.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/POR.html"
        ]
    },
    "xtest": {
        "detail": [
            "Test If In Transactional Execution"
        ],
        "documentation": [
            "The XTEST instruction queries the transactional execution status. If the instruction executes inside a transactionally executing RTM region or a transactionally executing HLE region, then the ZF flag is cleared, else it is set.",
            "Flags Affected:",
            "The ZF flag is cleared if the instruction is executed transactionally; otherwise it is set to 1. The CF, OF, SF, PF, and AF, flags are cleared."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/XTEST.html"
        ]
    },
    "lddqu": {
        "detail": [
            "Load Unaligned Integer 128 Bits"
        ],
        "documentation": [
            "The instruction is functionally similar to (V)MOVDQU ymm/xmm, m256/m128 for loading from memory. That is: 32/16 bytes of data starting at an address specified by the source memory operand (second operand) are fetched from memory and placed in a destination register (first operand). The source operand need not be aligned on a 32/16-byte boundary. Up to 64/32 bytes may be loaded from memory; this is implementation dependent.",
            "This instruction may improve performance relative to (V)MOVDQU if the source operand crosses a cache line boundary. In situations that require the data loaded by (V)LDDQU be modified and stored to the same location, use (V)MOVDQU or (V)MOVDQA instead of (V)LDDQU. To move a double quadword to or from memory locations that are known to be aligned on 16-byte boundaries, use the (V)MOVDQA instruction."
        ],
        "operands": [
            "reg.x, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/LDDQU.html"
        ]
    },
    "kxnorq": {
        "detail": [
            "Bitwise Logical XNOR Masks"
        ],
        "documentation": [
            "Performs a bitwise XNOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KXNORW:KXNORB:KXNORQ:KXNORD.html"
        ]
    },
    "lgs": {
        "detail": [
            "Load Far Pointer"
        ],
        "documentation": [
            "Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16-bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS, SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand.",
            "If one of these instructions is executed in protected mode, additional information from the segment descriptor pointed to by the segment selector in the source operand is loaded in the hidden part of the selected segment register.",
            "Also in protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers without causing a protection exception. (Any subsequent reference to a segment whose corresponding segment register is loaded with a NULL selector, causes a general-protection exception (#GP) and no memory reference to the segment occurs.)",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.W promotes operation to specify a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.w, mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/LDS:LES:LFS:LGS:LSS.html"
        ]
    },
    "phaddsw": {
        "detail": [
            "Packed Horizontal Add and Saturate"
        ],
        "documentation": [
            "(V)PHADDSW adds two adjacent signed 16-bit integers horizontally from the source and destination operands and saturates the signed results; packs the signed, saturated 16-bit results to the destination operand (first operand) When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "In 64-bit mode, use the REX prefix to access additional registers.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.",
            "Note: VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PHADDSW.html"
        ]
    },
    "kxnorw": {
        "detail": [
            "Bitwise Logical XNOR Masks"
        ],
        "documentation": [
            "Performs a bitwise XNOR between the vector mask k2 and the vector mask k3, and writes the result into vector mask k1 (three-operand form).",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KXNORW:KXNORB:KXNORQ:KXNORD.html"
        ]
    },
    "vpsignw": {
        "detail": [
            "Packed SIGN"
        ],
        "documentation": [
            "(V)PSIGNB/(V)PSIGNW/(V)PSIGND negates each data element of the destination operand (the first operand) if the signed integer value of the corresponding data element in the source operand (the second operand) is less than zero. If the signed integer value of a data element in the source operand is positive, the corresponding data element in the destination operand is unchanged. If a data element in the source operand is zero, the corresponding data element in the destination operand is set to zero.",
            "(V)PSIGNB operates on signed bytes. (V)PSIGNW operates on 16-bit signed words. (V)PSIGND operates on signed 32-bit integers. When the source operand is a 128bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Legacy SSE instructions: Both operands can be MMX registers. In 64-bit mode, use the REX prefix to access additional registers.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise instructions will #UD.",
            "VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand is an YMM register or a 256-bit memory location."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSIGNB:PSIGNW:PSIGND.html"
        ]
    },
    "andn": {
        "detail": [
            "Logical AND NOT"
        ],
        "documentation": [
            "Performs a bitwise logical AND of inverted second operand (the first source operand) with the third operand (the",
            "second source operand). The result is stored in the first operand (destination operand).",
            "This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
            "Flags Affected:",
            "SF and ZF are updated based on result. OF and CF flags are cleared. AF and PF flags are undefined."
        ],
        "operands": [
            "reg.d, reg.d, reg.d",
            "reg.d, reg.d, mem.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/ANDN.html"
        ]
    },
    "mcommit": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "retfq": {
        "detail": [
            "Return from Procedure"
        ],
        "documentation": [
            "Transfers program control to a return address located on the top of the stack. The address is usually placed on the stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction.",
            "The optional source operand specifies the number of stack bytes to be released after the return address is popped; the default is none. This operand can be used to release parameters from the stack that were passed to the called procedure and are no longer needed. It must be used when the CALL instruction used to switch to a new procedure uses a call gate with a non-zero word count to access the new procedure. Here, the source operand for the RET instruction must specify the same number of bytes as is specified in the word count field of the call gate.",
            "The RET instruction can be used to execute three different types of returns:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.q, mem.x",
            "imm.w, reg.q, reg.q, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/RET.html"
        ]
    },
    "testui": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.1"
        ],
        "url": [
            "https://"
        ]
    },
    "retfw": {
        "detail": [
            "Return from Procedure"
        ],
        "documentation": [
            "Transfers program control to a return address located on the top of the stack. The address is usually placed on the stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction.",
            "The optional source operand specifies the number of stack bytes to be released after the return address is popped; the default is none. This operand can be used to release parameters from the stack that were passed to the called procedure and are no longer needed. It must be used when the CALL instruction used to switch to a new procedure uses a call gate with a non-zero word count to access the new procedure. Here, the source operand for the RET instruction must specify the same number of bytes as is specified in the word count field of the call gate.",
            "The RET instruction can be used to execute three different types of returns:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.q, mem.d",
            "imm.w, reg.q, reg.q, mem.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/RET.html"
        ]
    },
    "fucompp": {
        "detail": [
            "Unordered Compare Floating Point Values"
        ],
        "documentation": [
            "Performs an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below). If no operand is specified, the contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that –0.0 is equal to +0.0."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FUCOM:FUCOMP:FUCOMPP.html"
        ]
    },
    "lock adc": {
        "detail": [
            "Add with Carry"
        ],
        "documentation": [
            "Adds the destination operand (first operand), the source operand (second operand), and the carry (CF) flag and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a carry from a previous addition. When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.",
            "The ADC instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a carry in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.",
            "The ADC instruction is usually executed as part of a multibyte or multiword addition in which an ADD instruction is followed by an ADC instruction.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF, SF, ZF, AF, CF, and PF flags are set according to the result."
        ],
        "operands": [
            "mem.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADC.html"
        ]
    },
    "lock add": {
        "detail": [
            "Add"
        ],
        "documentation": [
            "Adds the destination operand (first operand) and the source operand (second operand) and then stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.",
            "The ADD instruction performs integer addition. It evaluates the result for both signed and unsigned integer operands and sets the CF and OF flags to indicate a carry (overflow) in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF, SF, ZF, AF, CF, and PF flags are set according to the result."
        ],
        "operands": [
            "mem.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADD.html"
        ]
    },
    "vpconflictd": {
        "detail": [
            "Detect Conflicts Within a Vector of Packed Dword/Qword Values into Dense Memory/ Register"
        ],
        "documentation": [
            "Test each dword/qword element of the source operand (the second operand) for equality with all other elements in the source operand closer to the least significant element. Each element’s comparison results form a bit vector, which is then zero extended and written to the destination according to the writemask.",
            "EVEX.512 encoded version: The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.",
            "EVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPCONFLICTD:VPCONFLICTQ.html"
        ]
    },
    "vpcmpub": {
        "detail": [
            "Compare Packed Byte Values Into Mask"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed byte values in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).",
            "VPCMPB performs a comparison between pairs of signed byte values.",
            "VPCMPUB performs a comparison between pairs of unsigned byte values.",
            "The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand (first operand) is a mask register k1. Up to 64/32/16 comparisons are performed with results written to the destination operand under the writemask k2.",
            "The comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table 5-17."
        ],
        "operands": [
            "reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.q, reg.x, reg.x, imm.b",
            "reg.q, reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPCMPB:VPCMPUB.html"
        ]
    },
    "rdpkru": {
        "detail": [
            "Read Protection Key Rights for User Pages"
        ],
        "documentation": [
            "Reads the value of PKRU into EAX and clears EDX. ECX must be 0 when RDPKRU is executed; otherwise, a general-protection exception (#GP) occurs.",
            "RDPKRU can be executed only if CR4.PKE = 1; otherwise, an invalid-opcode exception (#UD) occurs. Software can discover the value of CR4.PKE by examining CPUID.(EAX=07H,ECX=0H):ECX.OSPKE [bit 4].",
            "On processors that support the Intel 64 Architecture, the high-order 32-bits of RCX are ignored and the high-order 32-bits of RDX and RAX are cleared.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/RDPKRU.html"
        ]
    },
    "vpcmpud": {
        "detail": [
            "Compare Packed Integer Values into Mask"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed integer values in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).",
            "VPCMPD/VPCMPUD performs a comparison between pairs of signed/unsigned doubleword integer values.",
            "The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register k1. Up to 16/8/4 comparisons are performed with results written to the destination operand under the writemask k2.",
            "The comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table 5-17."
        ],
        "operands": [
            "reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.q, reg.z, reg.z, imm.b",
            "reg.q, reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.z, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPCMPD:VPCMPUD.html"
        ]
    },
    "lzcnt": {
        "detail": [
            "Count the Number of Leading Zero Bits"
        ],
        "documentation": [
            "Counts the number of leading most significant zero bits in a source operand (second operand) returning the result into a destination (first operand).",
            "LZCNT differs from BSR. For example, LZCNT will produce the operand size when the input operand is zero. It should be noted that on processors that do not support LZCNT, the instruction byte encoding is executed as BSR.",
            "In 64-bit mode 64-bit operand size requires REX.W=1.",
            "Flags Affected:",
            "ZF flag is set to 1 in case of zero output (most significant bit of the source is set), and to 0 otherwise, CF flag is set to 1 if input was zero and cleared otherwise. OF, SF, PF and AF flags are undefined."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/LZCNT.html"
        ]
    },
    "vpdpwssd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vfixupimmsd": {
        "detail": [
            "Fix Up Special Scalar Float64 Value"
        ],
        "documentation": [
            "Perform a fix-up of the low quadword element encoded in double-precision floating-point format in the first source operand (the second operand) using a 32-bit, two-level look-up table specified in the low quadword element of the second source operand (the third operand) with exception reporting specifier imm8. The element that is fixed-up is selected by mask bit of 1 specified in the opmask k1. Mask bit of 0 in the opmask k1 or table response action of 0000b preserves the corresponding element of the first operand. The fixed-up element from the first source operand or the preserved element in the first operand becomes the low quadword element of the destination operand (the first operand). Bits 127:64 of the destination operand is copied from the corresponding bits of the first source operand. The destination and first source operands are XMM registers. The second source operand can be a XMM register or a 64- bit memory location.",
            "The two-level look-up table perform a fix-up of each DP FP input data in the first source operand by decoding the input data encoding into 8 token types. A response table is defined for each token type that converts the input encoding in the first source operand with one of 16 response actions.",
            "This instruction is specifically intended for use in fixing up the results of arithmetic calculations involving one source so that they match the spec, although it is generally useful for fixing up the results of multiple-instruction sequences to reflect special-number inputs. For example, consider rcp(0). Input 0 to rcp, and you should get INF according to the DX10 spec. However, evaluating rcp via Newton-Raphson, where x=approx(1/0), yields an incorrect result. To deal with this, VFIXUPIMMPD can be used after the N-R reciprocal sequence to set the result to the correct value (i.e. INF when the input is 0).",
            "If MXCSR.DAZ is not set, denormal input elements in the first source operand are considered as normal inputs and do not trigger any fixup nor fault reporting.",
            "Imm8 is used to set the required flags reporting. It supports #ZE and #IE fault reporting (see details below).",
            "MXCSR.DAZ is used and refer to zmm2 only (i.e. zmm1 is not considered as zero in case MXCSR.DAZ is set).",
            "MXCSR mask bits are ignored and are treated as if all mask bits are set to masked response). If any of the imm8 bits is set and the condition met for fault reporting, MXCSR.IE or MXCSR.ZE might be updated."
        ],
        "operands": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFIXUPIMMSD.html"
        ]
    },
    "vpconflictq": {
        "detail": [
            "Detect Conflicts Within a Vector of Packed Dword/Qword Values into Dense Memory/ Register"
        ],
        "documentation": [
            "Test each dword/qword element of the source operand (the second operand) for equality with all other elements in the source operand closer to the least significant element. Each element’s comparison results form a bit vector, which is then zero extended and written to the destination according to the writemask.",
            "EVEX.512 encoded version: The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.",
            "EVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPCONFLICTD:VPCONFLICTQ.html"
        ]
    },
    "vpcmpuq": {
        "detail": [
            "Compare Packed Integer Values into Mask"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed integer values in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).",
            "VPCMPQ/VPCMPUQ performs a comparison between pairs of signed/unsigned quadword integer values.",
            "The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register k1. Up to 8/4/2 comparisons are performed with results written to the destination operand under the writemask k2.",
            "The comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table 5-17."
        ],
        "operands": [
            "reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.q, reg.z, reg.z, imm.b",
            "reg.q, reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.z, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPCMPQ:VPCMPUQ.html"
        ]
    },
    "vaddsubpd": {
        "detail": [
            "Packed Double-FP Add/Subtract"
        ],
        "documentation": [
            "Adds odd-numbered double-precision floating-point values of the first source operand (second operand) with the corresponding double-precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered double-precision floating-point values from the second source operand from the corresponding double-precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified. See Figure 3-3.",
            "VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADDSUBPD.html"
        ]
    },
    "vpcmpuw": {
        "detail": [
            "Compare Packed Word Values Into Mask"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed integer word in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).",
            "VPCMPW performs a comparison between pairs of signed word values.",
            "VPCMPUW performs a comparison between pairs of unsigned word values.",
            "The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand (first operand) is a mask register k1. Up to 32/16/8 comparisons are performed with results written to the destination operand under the writemask k2.",
            "The comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table 5-17."
        ],
        "operands": [
            "reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.q, reg.x, reg.x, imm.b",
            "reg.q, reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPCMPW:VPCMPUW.html"
        ]
    },
    "vfixupimmss": {
        "detail": [
            "Fix Up Special Scalar Float32 Value"
        ],
        "documentation": [
            "Perform a fix-up of the low doubleword element encoded in single-precision floating-point format in the first source operand (the second operand) using a 32-bit, two-level look-up table specified in the low doubleword element of the second source operand (the third operand) with exception reporting specifier imm8. The element that is fixed-up is selected by mask bit of 1 specified in the opmask k1. Mask bit of 0 in the opmask k1 or table response action of 0000b preserves the corresponding element of the first operand. The fixed-up element from the first source operand or the preserved element in the first operand becomes the low doubleword element of the destination operand (the first operand) Bits 127:32 of the destination operand is copied from the corresponding bits of the first source operand. The destination and first source operands are XMM registers. The second source operand can be a XMM register or a 32-bit memory location.",
            "The two-level look-up table perform a fix-up of each SP FP input data in the first source operand by decoding the input data encoding into 8 token types. A response table is defined for each token type that converts the input encoding in the first source operand with one of 16 response actions.",
            "This instruction is specifically intended for use in fixing up the results of arithmetic calculations involving one source so that they match the spec, although it is generally useful for fixing up the results of multiple-instruction sequences to reflect special-number inputs. For example, consider rcp(0). Input 0 to rcp, and you should get INF according to the DX10 spec. However, evaluating rcp via Newton-Raphson, where x=approx(1/0), yields an incorrect result. To deal with this, VFIXUPIMMPD can be used after the N-R reciprocal sequence to set the result to the correct value (i.e. INF when the input is 0).",
            "If MXCSR.DAZ is not set, denormal input elements in the first source operand are considered as normal inputs and do not trigger any fixup nor fault reporting.",
            "Imm8 is used to set the required flags reporting. It supports #ZE and #IE fault reporting (see details below).",
            "MXCSR.DAZ is used and refer to zmm2 only (i.e. zmm1 is not considered as zero in case MXCSR.DAZ is set).",
            "MXCSR mask bits are ignored and are treated as if all mask bits are set to masked response). If any of the imm8 bits is set and the condition met for fault reporting, MXCSR.IE or MXCSR.ZE might be updated."
        ],
        "operands": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFIXUPIMMSS.html"
        ]
    },
    "vmmcall": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "cvttps2pi": {
        "detail": [
            "Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers"
        ],
        "documentation": [
            "Converts two packed single-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is an MMX technology register. When the source operand is an XMM register, the two single-precision floating-point values are contained in the low quadword of the register.",
            "When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.",
            "This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTTPS2PI instruction is executed.",
            "In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15)."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTTPS2PI.html"
        ]
    },
    "vaddsubps": {
        "detail": [
            "Packed Single-FP Add/Subtract"
        ],
        "documentation": [
            "Adds odd-numbered single-precision floating-point values of the first source operand (second operand) with the corresponding single-precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered single-precision floating-point values from the second source operand from the corresponding single-precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified. See Figure 3-4.",
            "VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADDSUBPS.html"
        ]
    },
    "frstor": {
        "detail": [
            "Restore x87 FPU State"
        ],
        "documentation": [
            "Loads the FPU state (operating environment and register stack) from the memory area specified with the source operand. This state data is typically written to the specified memory location by a previous FSAVE/FNSAVE instruction.",
            "The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, show the layout in memory of the stored environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used. The contents of the FPU register stack are stored in the 80 bytes immediately following the operating environment image.",
            "The FRSTOR instruction should be executed in the same operating mode as the corresponding FSAVE/FNSAVE instruction.",
            "If one or more unmasked exception bits are set in the new FPU status word, a floating-point exception will be generated. To avoid raising exceptions when loading a new operating environment, clear all the exception flags in the FPU status word that is being loaded.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "mem.wdqxz, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FRSTOR.html"
        ]
    },
    "vfnmsub213sd": {
        "detail": [
            "Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMSUB132SD: Multiplies the low packed double-precision floating-point value from the first source operand to the low packed double-precision floating-point value in the third source operand. From negated infinite precision intermediate result, subtracts the low double-precision floating-point value in the second source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFNMSUB213SD: Multiplies the low packed double-precision floating-point value from the second source operand to the low packed double-precision floating-point value in the first source operand. From negated infinite precision intermediate result, subtracts the low double-precision floating-point value in the third source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFNMSUB231SD: Multiplies the low packed double-precision floating-point value from the second source to the low packed double-precision floating-point value in the third source operand. From negated infinite precision intermediate result, subtracts the low double-precision floating-point value in the first source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMSUB132SD:VFNMSUB213SD:VFNMSUB231SD.html"
        ]
    },
    "vbroadcastf128": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "documentation": [
            "VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).",
            "VEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4 load floating-point values as tuples from the source operand (the second operand) in memory or register and broadcast to all elements of the destination operand (the first operand). The destination operand is a YMM/ZMM register updated according to the writemask k1. The source operand is either a register or 64-bit/128-bit/256-bit memory location.",
            "VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as 256-bit and 512-bit wide versions and up. VBROADCASTSS is supported in 128-bit, 256-bit and 512-bit wide versions. F32x8 and F64x4 are only supported as 512-bit wide versions.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32-bit granularity. VBROADCASTF64X2 and VBROADCASTF64X4 have 64-bit granularity.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.y, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBROADCAST.html"
        ]
    },
    "vfnmsub213ss": {
        "detail": [
            "Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand. From negated infinite precision intermediate result, the low single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFNMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand. From negated infinite precision intermediate result, the low single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFNMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low packed single-precision floating-point value in the third source operand. From negated infinite precision intermediate result, the low single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMSUB132SS:VFNMSUB213SS:VFNMSUB231SS.html"
        ]
    },
    "setnle": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "vgetmantsd": {
        "detail": [
            "Extract Float64 of Normalized Mantissas from Float64 Scalar"
        ],
        "documentation": [
            "Convert the double-precision floating values in the low quadword element of the second source operand (the third operand) to DP FP value with the mantissa normalization and sign control specified by the imm8 byte, see Figure 5-15. The converted result is written to the low quadword element of the destination operand (the first operand) using writemask k1. Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. The normalized mantissa is specified by interv (imm8[1:0]) and the sign control (sc) is specified by bits 3:2 of the immediate byte.",
            "The conversion operation is:",
            "GetMant(x) = ±2k|x.significand|",
            "where:",
            "1 <= |x.significand| < 2",
            "Unbiased exponent k depends on the interval range defined by interv and whether the exponent of the source is even or odd. The sign of the final result is determined by sc and the source sign.",
            "If interv != 0 then k = -1, otherwise K = 0. The encoded value of imm8[1:0] and sign control are shown in",
            "Figure 5-15.",
            "The converted DP FP result is encoded according to the sign control, the unbiased exponent k (adding bias) and a mantissa normalized to the range specified by interv.",
            "The GetMant() function follows Table 5-16 when dealing with floating-point special numbers.",
            "This instruction is writemasked, so only those elements with the corresponding bit set in vector mask register k1 are computed and stored into zmm1. Elements in zmm1 with the corresponding bit clear in k1 retain their previous values."
        ],
        "operands": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGETMANTSD.html"
        ]
    },
    "vmovdqa32": {
        "detail": [
            "Move Aligned Packed Integer Values"
        ],
        "documentation": [
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX encoded versions:",
            "Moves 128, 256 or 512 bits of packed doubleword/quadword integer values from the source operand (the second operand) to the destination operand (the first operand). This instruction can be used to load a vector register from an int32/int64 memory location, to store the contents of a vector register into an int32/int64 memory location, or to move data between two ZMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16 (EVEX.128)/32(EVEX.256)/64(EVEX.512)-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction.",
            "The destination operand is updated at 32-bit (VMOVDQA32) or 64-bit (VMOVDQA64) granularity according to the writemask.",
            "VEX.256 encoded version:",
            "Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.",
            "When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "128-bit versions:",
            "Moves 128 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.",
            "When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVDQA:VMOVDQA32:VMOVDQA64.html"
        ]
    },
    "bndmk": {
        "detail": [
            "Make Bounds"
        ],
        "documentation": [
            "Makes bounds from the second operand and stores the lower and upper bounds in the bound register bnd. The second operand must be a memory operand. The content of the base register from the memory operand is stored in the lower bound bnd.LB. The 1's complement of the effective address of m32/m64 is stored in the upper bound b.UB. Computation of m32/m64 has identical behavior to LEA.",
            "This instruction does not cause any memory access, and does not read or write any flags.",
            "If the instruction did not specify base register, the lower bound will be zero. The reg-reg form of this instruction retains legacy behavior (NOP).",
            "The instruction causes an invalid-opcode exception (#UD) if executed in 64-bit mode with RIP-relative addressing.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, agen"
        ],
        "url": [
            "https://felixcloutier.com/x86/BNDMK.html"
        ]
    },
    "vgetmantss": {
        "detail": [
            "Extract Float32 Vector of Normalized Mantissa from Float32 Vector"
        ],
        "documentation": [
            "Convert the single-precision floating values in the low doubleword element of the second source operand (the third operand) to SP FP value with the mantissa normalization and sign control specified by the imm8 byte, see Figure 5-15. The converted result is written to the low doubleword element of the destination operand (the first operand) using writemask k1. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. The normalized mantissa is specified by interv (imm8[1:0]) and the sign control (sc) is specified by bits 3:2 of the immediate byte.",
            "The conversion operation is:",
            "GetMant(x) = ±2k|x.significand|",
            "where:",
            "1 <= |x.significand| < 2",
            "Unbiased exponent k depends on the interval range defined by interv and whether the exponent of the source is even or odd. The sign of the final result is determined by sc and the source sign.",
            "if interv != 0 then k = -1, otherwise K = 0. The encoded value of imm8[1:0] and sign control are shown",
            "in Figure 5-15.",
            "The converted SP FP result is encoded according to the sign control, the unbiased exponent k (adding bias) and a mantissa normalized to the range specified by interv.",
            "The GetMant() function follows Table 5-16 when dealing with floating-point special numbers.",
            "This instruction is writemasked, so only those elements with the corresponding bit set in vector mask register k1 are computed and stored into zmm1. Elements in zmm1 with the corresponding bit clear in k1 retain their previous values."
        ],
        "operands": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGETMANTSS.html"
        ]
    },
    "pdep": {
        "detail": [
            "Parallel Bits Deposit"
        ],
        "documentation": [
            "PDEP uses a mask in the second source operand (the third operand) to transfer/scatter contiguous low order bits in the first source operand (the second operand) into the destination (the first operand). PDEP takes the low bits from the first source operand and deposit them in the destination operand at the corresponding bit locations that are set in the second source operand (mask). All other bits (bits not set in mask) in destination are set to zero.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.d, reg.d, mem.d",
            "reg.d, reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/PDEP.html"
        ]
    },
    "movzx": {
        "detail": [
            "Move with Zero-Extend"
        ],
        "documentation": [
            "Copies the contents of the source operand (register or memory location) to the destination operand (register) and zero extends the value. The size of the converted value depends on the operand-size attribute.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bit operands. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, mem.b",
            "reg.w, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVZX.html"
        ]
    },
    "sysenter": {
        "detail": [
            "Fast System Call"
        ],
        "documentation": [
            "Executes a fast call to a level 0 system procedure or routine. SYSENTER is a companion instruction to SYSEXIT. The instruction is optimized to provide the maximum performance for system calls from user code running at privilege level 3 to operating system or executive procedures running at privilege level 0.",
            "When executed in IA-32e mode, the SYSENTER instruction transitions the logical processor to 64-bit mode; otherwise, the logical processor remains in protected mode.",
            "Prior to executing the SYSENTER instruction, software must specify the privilege level 0 code segment and code entry point, and the privilege level 0 stack segment and stack pointer by writing values to the following MSRs:",
            "Flags Affected:",
            "VM, IF (see Operation above)"
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/SYSENTER.html"
        ]
    },
    "faddp": {
        "detail": [
            "Add"
        ],
        "documentation": [
            "Adds the destination and source operands and stores the sum in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.",
            "The no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-operand version adds the contents of a memory location (either a floating-point or an integer value) to the contents of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice versa. The value in ST(0) can be doubled by coding:",
            "FADD ST(0), ST(0);",
            "The FADDP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. (The no-operand version of the floating-point add instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FADD rather than FADDP.)",
            "The FIADD instructions convert an integer source operand to double extended-precision floating-point format before performing the addition.",
            "The table on the following page shows the results obtained when adding various classes of numbers, assuming that neither overflow nor underflow occurs.",
            "When the sum of two operands with opposite signs is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. When the source operand is an integer 0, it is treated as a +0.",
            "When both operand are infinities of the same sign, the result is ∞ of the expected sign. If both operands are infinities of opposite signs, an invalid-operation exception is generated. See Table 3-18."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FADD:FADDP:FIADD.html"
        ]
    },
    "vpmovdb": {
        "detail": [
            "Down Convert DWord to Byte"
        ],
        "documentation": [
            "VPMOVDB down converts 32-bit integer elements in the source operand (the second operand) into packed bytes using truncation. VPMOVSDB converts signed 32-bit integers into packed signed bytes using signed saturation. VPMOVUSDB convert unsigned double-word values into unsigned byte values using unsigned saturation.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit memory location.",
            "Down-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:128/64/32) of the register destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.z",
            "mem.x, reg.q, reg.z",
            "mem.x, reg.z",
            "reg.x, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVDB:VPMOVSDB:VPMOVUSDB.html"
        ]
    },
    "setle": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "vpcmpestrmq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, imm.b, reg, reg, reg.x",
            "reg.x, mem.x, imm.b, reg, reg, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpblendvb": {
        "detail": [
            "Variable Blend Packed Bytes"
        ],
        "documentation": [
            "Conditionally copies byte elements from the source operand (second operand) to the destination operand (first operand) depending on mask bits defined in the implicit third register argument, XMM0. The mask bits are the most significant bit in each byte element of the XMM0 register.",
            "If a mask bit is “1\", then the corresponding byte element in the source operand is copied to the destination, else the byte element in the destination operand is left unchanged.",
            "The register assignment of the implicit third operand is defined to be the architectural register XMM0.",
            "128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0. An attempt to execute PBLENDVB with a VEX prefix will cause #UD.",
            "VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. The upper bits (MAXVL-1:128) of the corresponding YMM register (destination register) are zeroed. VEX.L must be 0, otherwise the instruction will #UD. VEX.W must be 0, otherwise, the instruction will #UD.",
            "VEX.256 encoded version: The first source operand and the destination operand are YMM registers. The second source operand is an YMM register or 256-bit memory location. The third source register is an YMM register and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored.",
            "VPBLENDVB permits the mask to be any XMM or YMM register. In contrast, PBLENDVB treats XMM0 implicitly as the mask and do not support non-destructive destination operation. An attempt to execute PBLENDVB encoded with a VEX prefix will cause a #UD exception.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PBLENDVB.html"
        ]
    },
    "vpmovdw": {
        "detail": [
            "Down Convert DWord to Word"
        ],
        "documentation": [
            "VPMOVDW down converts 32-bit integer elements in the source operand (the second operand) into packed words using truncation. VPMOVSDW converts signed 32-bit integers into packed signed words using signed saturation. VPMOVUSDW convert unsigned double-word values into unsigned word values using unsigned saturation.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.",
            "Down-converted word elements are written to the destination operand (the first operand) from the least-significant word. Word elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.y, reg.z",
            "mem.y, reg.q, reg.z",
            "mem.y, reg.z",
            "reg.y, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVDW:VPMOVSDW:VPMOVUSDW.html"
        ]
    },
    "vcvtdq2pd": {
        "detail": [
            "Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Converts two, four or eight packed signed doubleword integers in the source operand (the second operand) to two, four or eight packed double-precision floating-point values in the destination operand (the first operand).",
            "EVEX encoded versions: The source operand can be a YMM/XMM/XMM (low 64 bits) register, a 256/128/64-bit memory location or a 256/128/64-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1. Attempt to encode this instruction with EVEX embedded rounding is ignored.",
            "VEX.256 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a YMM register.",
            "VEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination operand is a XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination operand is an XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTDQ2PD.html"
        ]
    },
    "haddpd": {
        "detail": [
            "Packed Double-FP Horizontal Add"
        ],
        "documentation": [
            "Adds the double-precision floating-point values in the high and low quadwords of the destination operand and stores the result in the low quadword of the destination operand.",
            "Adds the double-precision floating-point values in the high and low quadwords of the source operand and stores the result in the high quadword of the destination operand.",
            "In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
            "See Figure 3-16 for HADDPD; see Figure 3-17 for VHADDPD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/HADDPD.html"
        ]
    },
    "vcvtdq2ps": {
        "detail": [
            "Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Converts four, eight or sixteen packed signed doubleword integers in the source operand to four, eight or sixteen packed single-precision floating-point values in the destination operand.",
            "EVEX encoded versions: The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding register destination are zeroed.",
            "VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper Bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTDQ2PS.html"
        ]
    },
    "addsubpd": {
        "detail": [
            "Packed Double-FP Add/Subtract"
        ],
        "documentation": [
            "Adds odd-numbered double-precision floating-point values of the first source operand (second operand) with the corresponding double-precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered double-precision floating-point values from the second source operand from the corresponding double-precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified. See Figure 3-3.",
            "VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADDSUBPD.html"
        ]
    },
    "pshuflw": {
        "detail": [
            "Shuffle Packed Low Words"
        ],
        "documentation": [
            "Copies words from the low quadword of a 128-bit lane of the source operand and inserts them in the low quadword of the destination operand at word locations (of the respective lane) selected with the immediate operand. The 256-bit operation is similar to the in-lane operation used by the 256-bit VPSHUFD instruction, which is illustrated in Figure 4-16. For 128-bit operation, only the low 128-bit lane is operative. Each 2-bit field in the immediate operand selects the contents of one word location in the low quadword of the destination operand. The binary encodings of the immediate operand fields select words (0, 1, 2 or 3) from the low quadword of the source operand to be copied to the destination operand. The high quadword of the source operand is copied to the high quadword of the destination operand, for each 128-bit lane.",
            "Note that this instruction permits a word in the low quadword of the source operand to be copied to more than one word location in the low quadword of the destination operand.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The destination operand is an YMM register. The source operand can be an YMM register or a 256-bit memory location.",
            "EVEX encoded version: The destination operand is a ZMM/YMM/XMM registers. The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is updated according to the writemask.",
            "Note: In VEX encoded versions, VEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSHUFLW.html"
        ]
    },
    "haddps": {
        "detail": [
            "Packed Single-FP Horizontal Add"
        ],
        "documentation": [
            "Adds the single-precision floating-point values in the first and second dwords of the destination operand and stores the result in the first dword of the destination operand.",
            "Adds single-precision floating-point values in the third and fourth dword of the destination operand and stores the result in the second dword of the destination operand.",
            "Adds single-precision floating-point values in the first and second dword of the source operand and stores the result in the third dword of the destination operand.",
            "Adds single-precision floating-point values in the third and fourth dword of the source operand and stores the result in the fourth dword of the destination operand.",
            "In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
            "See Figure 3-18 for HADDPS; see Figure 3-19 for VHADDPS."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/HADDPS.html"
        ]
    },
    "addsubps": {
        "detail": [
            "Packed Single-FP Add/Subtract"
        ],
        "documentation": [
            "Adds odd-numbered single-precision floating-point values of the first source operand (second operand) with the corresponding single-precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered single-precision floating-point values from the second source operand from the corresponding single-precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified. See Figure 3-4.",
            "VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADDSUBPS.html"
        ]
    },
    "repe movsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.b, mem.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "pshufb": {
        "detail": [
            "Packed Shuffle Bytes"
        ],
        "documentation": [
            "PSHUFB performs in-place shuffles of bytes in the destination operand (the first operand) according to the shuffle control mask in the source operand (the second operand). The instruction permutes the data in the destination operand, leaving the shuffle mask unaffected. If the most significant bit (bit[7]) of each byte of the shuffle control mask is set, then constant zero is written in the result byte. Each byte in the shuffle control mask forms an index to permute the corresponding byte in the destination operand. The value of each index is the least significant 4 bits (128-bit operation) or 3 bits (64-bit operation) of the shuffle control byte. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "In 64-bit mode and not encoded with VEX/EVEX, use the REX prefix to access XMM8-XMM15 registers.",
            "Legacy SSE version 64-bit operand: Both operands can be MMX registers.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The destination operand is the first operand, the first source operand is the second operand, the second source operand is the third operand. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: Bits (255:128) of the destination YMM register stores the 16-byte shuffle result of the upper 16 bytes of the first source operand, using the upper 16-bytes of the second source operand as control mask.",
            "The value of each index is for the high 128-bit lane is the least significant 4 bits of the respective shuffle control byte. The index value selects a source data element within each 128-bit lane.",
            "EVEX encoded version: The second source operand is an ZMM/YMM/XMM register or an 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "EVEX and VEX encoded version: Four/two in-lane 128-bit shuffles."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSHUFB.html"
        ]
    },
    "repe movsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.d, mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "pshufd": {
        "detail": [
            "Shuffle Packed Doublewords"
        ],
        "documentation": [
            "Copies doublewords from source operand (second operand) and inserts them in the destination operand (first operand) at the locations selected with the order operand (third operand). Figure 4-16 shows the operation of the 256-bit VPSHUFD instruction and the encoding of the order operand. Each 2-bit field in the order operand selects the contents of one doubleword location within a 128-bit lane and copy to the target element in the destination operand. For example, bits 0 and 1 of the order operand targets the first doubleword element in the low and high 128-bit lane of the destination operand for 256-bit VPSHUFD. The encoded value of bits 1:0 of the order operand (see the field encoding in Figure 4-16) determines which doubleword element (from the respective 128-bit lane) of the source operand will be copied to doubleword 0 of the destination operand.",
            "For 128-bit operation, only the low 128-bit lane are operative. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The order operand is an 8-bit immediate. Note that this instruction permits a doubleword in the source operand to be copied to more than one doubleword location in the destination operand.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSHUFD.html"
        ]
    },
    "vcvttps2dq": {
        "detail": [
            "Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values"
        ],
        "documentation": [
            "Converts four, eight or sixteen packed single-precision floating-point values in the source operand to four, eight or sixteen signed doubleword integers in the destination operand.",
            "When a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTTPS2DQ.html"
        ]
    },
    "repe movsq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.q, mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vpmadcsswd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "xsaves64": {
        "detail": [
            "Save Processor Extended States Supervisor"
        ],
        "documentation": [
            "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), the logicalAND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XSAVES may be executed only if CPL = 0.",
            "The format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Section 13.11, “Operation of XSAVES,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XSAVES instruction. The following items provide a highlevel outline:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.z[4096], reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XSAVES.html"
        ]
    },
    "v4fnmaddps": {
        "detail": [
            "Packed Single-Precision Floating-Point Fused Multiply-Add (4-iterations)"
        ],
        "documentation": [
            "This instruction computes 4 sequential packed fused single-precision floating-point multiply-add instructions with a sequentially selected memory operand in each of the four steps.",
            "In the above box, the notation of “+3” is used to denote that the instruction accesses 4 source registers based on that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.",
            "This instruction supports memory fault suppression. The entire memory operand is loaded if any of the 16 lowest significant mask bits is set to 1 or if a “no masking” encoding is used.",
            "The tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction.",
            "Rounding is performed at every FMA (fused multiply and add) boundary. Exceptions are also taken sequentially. Pre- and post-computational exceptions of the first FMA take priority over the pre- and post-computational exceptions of the second FMA, etc."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.z, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/V4FMADDPS:V4FNMADDPS.html"
        ]
    },
    "repe movsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.w, mem.w, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "pshufw": {
        "detail": [
            "Shuffle Packed Words"
        ],
        "documentation": [
            "Copies words from the source operand (second operand) and inserts them in the destination operand (first operand) at word locations selected with the order operand (third operand). This operation is similar to the operation used by the PSHUFD instruction, which is illustrated in Figure 4-16. For the PSHUFW instruction, each 2-bit field in the order operand selects the contents of one word location in the destination operand. The encodings of the order operand fields select words from the source operand to be copied to the destination operand.",
            "The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register. The order operand is an 8-bit immediate. Note that this instruction permits a word in the source operand to be copied to more than one word location in the destination operand.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.q, imm.b",
            "reg.q, mem.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSHUFW.html"
        ]
    },
    "uiret": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, reg.q, mem.w"
        ],
        "url": [
            "https://"
        ]
    },
    "vcmppd": {
        "detail": [
            "Compare Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed double-precision floating-point values in the second source operand and the first source operand and returns the results of the comparison to the destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source operands.",
            "EVEX encoded versions: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is an opmask register. Comparison results are written to the destination operand under the writemask k2. Each comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false).",
            "VEX.256 encoded version: The first source operand (second operand) is a YMM register. The second source operand (third operand) can be a YMM register or a 256-bit memory location. The destination operand (first operand) is a YMM register. Four comparisons are performed with results written to the destination operand. The result of each comparison is a quadword mask of all 1s (comparison true) or all 0s (comparison false).",
            "128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged. Two comparisons are performed with results written to bits 127:0 of the destination operand. The result of each comparison is a quadword mask of all 1s (comparison true) or all 0s (comparison false).",
            "VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. Two comparisons are performed with results written to bits 127:0 of the destination operand.",
            "The comparison predicate operand is an 8-bit immediate:"
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.q, reg.q, reg.z, reg.z, imm.b",
            "reg.q, reg.q, reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPPD.html"
        ]
    },
    "movsxd": {
        "detail": [
            "Move with Sign-Extension"
        ],
        "documentation": [
            "Copies the contents of the source operand (register or memory location) to the destination operand (register) and sign extends the value to 16 or 32 bits (see Figure 7-6 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). The size of the converted value depends on the operand-size attribute.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.d",
            "reg.q, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVSX:MOVSXD.html"
        ]
    },
    "vpaddsb": {
        "detail": [
            "Add Packed Signed Integers with Signed Saturation"
        ],
        "documentation": [
            "Performs a SIMD add of the packed signed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following paragraphs.",
            "(V)PADDSB performs a SIMD add of the packed signed integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.",
            "(V)PADDSW performs a SIMD add of the packed signed word integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.",
            "EVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an ZMM/YMM/XMM register or a memory location. The destination operand is an ZMM/YMM/XMM register.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDSB:PADDSW.html"
        ]
    },
    "clflush": {
        "detail": [
            "Flush Cache Line"
        ],
        "documentation": [
            "Invalidates from every level of the cache hierarchy in the cache coherence domain the cache line that contains the linear address specified with the memory operand. If that cache line contains modified data at any level of the cache hierarchy, that data is written back to memory. The source operand is a byte memory location.",
            "The availability of CLFLUSH is indicated by the presence of the CPUID feature flag CLFSH (CPUID.01H:EDX[bit 19]). The aligned cache line size affected is also indicated with the CPUID instruction (bits 8 through 15 of the EBX register when the initial value in the EAX register is 1).",
            "The memory attribute of the page containing the affected line has no effect on the behavior of this instruction. It should be noted that processors are free to speculatively fetch and cache data from system memory regions assigned a memory-type allowing for speculative reads (such as, the WB, WC, and WT memory types). PREFETCHh instructions can be used to provide the processor with hints for this speculative behavior. Because this speculative fetching can occur at any time and is not tied to instruction execution, the CLFLUSH instruction is not ordered with respect to PREFETCHh instructions or any of the speculative fetching mechanisms (that is, data can be speculatively loaded into a cache line just before, during, or after the execution of a CLFLUSH instruction that references the cache line).",
            "Executions of the CLFLUSH instruction are ordered with respect to each other and with respect to writes, locked read-modify-write instructions, fence instructions, and executions of CLFLUSHOPT to the same cache line.1 They are not ordered with respect to executions of CLFLUSHOPT to different cache lines."
        ],
        "operands": [
            "mem.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/CLFLUSH.html"
        ]
    },
    "vcmpps": {
        "detail": [
            "Compare Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed single-precision floating-point values in the second source operand and the first source operand and returns the results of the comparison to the destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each of the pairs of packed values.",
            "EVEX encoded versions: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is an opmask register. Comparison results are written to the destination operand under the writemask k2. Each comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false).",
            "VEX.256 encoded version: The first source operand (second operand) is a YMM register. The second source operand (third operand) can be a YMM register or a 256-bit memory location. The destination operand (first operand) is a YMM register. Eight comparisons are performed with results written to the destination operand. The result of each comparison is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).",
            "128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged. Four comparisons are performed with results written to bits 127:0 of the destination operand. The result of each comparison is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).",
            "VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. Four comparisons are performed with results written to bits 127:0 of the destination operand.",
            "The comparison predicate operand is an 8-bit immediate:"
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.q, reg.q, reg.z, reg.z, imm.b",
            "reg.q, reg.q, reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPPS.html"
        ]
    },
    "sqrtpd": {
        "detail": [
            "Square Root of Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD computation of the square roots of the two, four or eight packed double-precision floating-point values in the source operand (the second operand) stores the packed double-precision floating-point results in the destination operand (the first operand).",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/SQRTPD.html"
        ]
    },
    "fyl2xp1": {
        "detail": [
            "Compute y * log2(x +1)"
        ],
        "documentation": [
            "Computes (ST(1) ∗ log2(ST(0) + 1.0)), stores the result in register ST(1), and pops the FPU register stack. The source operand in ST(0) must be in the range:"
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FYL2XP1.html"
        ]
    },
    "vpmacsswd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpmovuswb": {
        "detail": [
            "Down Convert Word to Byte"
        ],
        "documentation": [
            "VPMOVWB down converts 16-bit integers into packed bytes using truncation. VPMOVSWB converts signed 16-bit integers into packed signed bytes using signed saturation. VPMOVUSWB convert unsigned word values into unsigned byte values using unsigned saturation.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.",
            "Down-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.",
            "Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.x",
            "mem.q, reg.q, reg.x",
            "mem.q, reg.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVWB:VPMOVSWB:VPMOVUSWB.html"
        ]
    },
    "vpaddsw": {
        "detail": [
            "Add Packed Signed Integers with Signed Saturation"
        ],
        "documentation": [
            "Performs a SIMD add of the packed signed integers from the source operand (second operand) and the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with signed saturation, as described in the following paragraphs.",
            "(V)PADDSB performs a SIMD add of the packed signed integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual byte result is beyond the range of a signed byte integer (that is, greater than 7FH or less than 80H), the saturated value of 7FH or 80H, respectively, is written to the destination operand.",
            "(V)PADDSW performs a SIMD add of the packed signed word integers with saturation from the first source operand and second source operand and stores the packed integer results in the destination operand. When an individual word result is beyond the range of a signed word integer (that is, greater than 7FFFH or less than 8000H), the saturated value of 7FFFH or 8000H, respectively, is written to the destination operand.",
            "EVEX encoded versions: The first source operand is an ZMM/YMM/XMM register. The second source operand is an ZMM/YMM/XMM register or a memory location. The destination operand is an ZMM/YMM/XMM register.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PADDSB:PADDSW.html"
        ]
    },
    "vcvtpd2uqq": {
        "detail": [
            "Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers"
        ],
        "documentation": [
            "Converts packed double-precision floating-point values in the source operand (second operand) to packed unsigned quadword integers in the destination operand (first operand).",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w – 1 is returned, where w represents the number of bits in the destination format.",
            "The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTPD2UQQ.html"
        ]
    },
    "sqrtps": {
        "detail": [
            "Square Root of Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD computation of the square roots of the four, eight or sixteen packed single-precision floating-point values in the source operand (second operand) stores the packed single-precision floating-point results in the destination operand.",
            "EVEX.512 encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded version: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: the source operand second source operand or a 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/SQRTPS.html"
        ]
    },
    "sgdt": {
        "detail": [
            "Store Global Descriptor Table Register"
        ],
        "documentation": [
            "Stores the content of the global descriptor table register (GDTR) in the destination operand. The destination operand specifies a memory location.",
            "In legacy or compatibility mode, the destination operand is a 6-byte memory location. If the operand-size attribute is 16 or 32 bits, the 16-bit limit field of the register is stored in the low 2 bytes of the memory location and the 32-bit base address is stored in the high 4 bytes.",
            "In 64-bit mode, the operand size is fixed at 8+2 bytes. The instruction stores an 8-byte base and a 2-byte limit.",
            "SGDT is useful only by operating-system software. However, it can be used in application programs without causing an exception to be generated if CR4.UMIP = 0. See “LGDT/LIDT—Load Global/Interrupt Descriptor Table Register” in Chapter 3, Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A, for information on loading the GDTR and IDTR.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/SGDT.html"
        ]
    },
    "nop": {
        "detail": [
            "No Operation"
        ],
        "documentation": [
            "This instruction performs no operation. It is a one-byte or multi-byte NOP that takes up space in the instruction stream but does not impact machine context, except for the EIP register.",
            "The multi-byte form of NOP is available on processors with model encoding:",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "",
            "mem.w",
            "reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/NOP.html"
        ]
    },
    "not": {
        "detail": [
            "One's Complement Negation"
        ],
        "documentation": [
            "Performs a bitwise NOT operation (each 1 is set to 0, and each 0 is set to 1) on the destination operand and stores the result in the destination operand location. The destination operand can be a register or a memory location.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "mem.b",
            "reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/NOT.html"
        ]
    },
    "vpmacssww": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "setnb": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "pblendvb": {
        "detail": [
            "Variable Blend Packed Bytes"
        ],
        "documentation": [
            "Conditionally copies byte elements from the source operand (second operand) to the destination operand (first operand) depending on mask bits defined in the implicit third register argument, XMM0. The mask bits are the most significant bit in each byte element of the XMM0 register.",
            "If a mask bit is “1\", then the corresponding byte element in the source operand is copied to the destination, else the byte element in the destination operand is left unchanged.",
            "The register assignment of the implicit third operand is defined to be the architectural register XMM0.",
            "128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0. An attempt to execute PBLENDVB with a VEX prefix will cause #UD.",
            "VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. The upper bits (MAXVL-1:128) of the corresponding YMM register (destination register) are zeroed. VEX.L must be 0, otherwise the instruction will #UD. VEX.W must be 0, otherwise, the instruction will #UD.",
            "VEX.256 encoded version: The first source operand and the destination operand are YMM registers. The second source operand is an YMM register or 256-bit memory location. The third source register is an YMM register and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored.",
            "VPBLENDVB permits the mask to be any XMM or YMM register. In contrast, PBLENDVB treats XMM0 implicitly as the mask and do not support non-destructive destination operation. An attempt to execute PBLENDVB encoded with a VEX prefix will cause a #UD exception.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PBLENDVB.html"
        ]
    },
    "pfrsqrt": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "setnl": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "cvtdq2pd": {
        "detail": [
            "Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Converts two, four or eight packed signed doubleword integers in the source operand (the second operand) to two, four or eight packed double-precision floating-point values in the destination operand (the first operand).",
            "EVEX encoded versions: The source operand can be a YMM/XMM/XMM (low 64 bits) register, a 256/128/64-bit memory location or a 256/128/64-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1. Attempt to encode this instruction with EVEX embedded rounding is ignored.",
            "VEX.256 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a YMM register.",
            "VEX.128 encoded version: The source operand is an XMM register or 64- bit memory location. The destination operand is a XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 64- bit memory location. The destination operand is an XMM register. The upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTDQ2PD.html"
        ]
    },
    "setno": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "setnp": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "setns": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "setnz": {
        "detail": [
            "Set Byte on Condition"
        ],
        "documentation": [
            "Sets the destination operand to 0 or 1 depending on the settings of the status flags (CF, SF, OF, ZF, and PF) in the EFLAGS register. The destination operand points to a byte register or a byte in memory. The condition code suffix (cc) indicates the condition being tested for.",
            "The terms “above” and “below” are associated with the CF flag and refer to the relationship between two unsigned integer values. The terms “greater” and “less” are associated with the SF and OF flags and refer to the relationship between two signed integer values.",
            "Many of the SETcc instruction opcodes have alternate mnemonics. For example, SETG (set byte if greater) and SETNLE (set if not less or equal) have the same opcode and test for the same condition: ZF equals 0 and SF equals OF. These alternate mnemonics are provided to make code more intelligible. Appendix B, “EFLAGS Condition Codes,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, shows the alternate mnemonics for various test conditions.",
            "Some languages represent a logical one as an integer with all bits set. This representation can be obtained by choosing the logically opposite condition for the SETcc instruction, then decrementing the result. For example, to test for overflow, use the SETNO instruction, then decrement the result.",
            "The reg field of the ModR/M byte is not used for the SETCC instruction and those opcode bits are ignored by the processor.",
            "In IA-64 mode, the operand size is fixed at 8 bits. Use of REX prefix enable uniform addressing to additional byte registers. Otherwise, this instruction’s operation is the same as in legacy mode and compatibility mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SETcc.html"
        ]
    },
    "repne outsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "cvtdq2ps": {
        "detail": [
            "Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Converts four, eight or sixteen packed signed doubleword integers in the source operand to four, eight or sixteen packed single-precision floating-point values in the destination operand.",
            "EVEX encoded versions: The source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is a YMM register. Bits (MAXVL-1:256) of the corresponding register destination are zeroed.",
            "VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper Bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTDQ2PS.html"
        ]
    },
    "repne outsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vmovdqa64": {
        "detail": [
            "Move Aligned Packed Integer Values"
        ],
        "documentation": [
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX encoded versions:",
            "Moves 128, 256 or 512 bits of packed doubleword/quadword integer values from the source operand (the second operand) to the destination operand (the first operand). This instruction can be used to load a vector register from an int32/int64 memory location, to store the contents of a vector register into an int32/int64 memory location, or to move data between two ZMM registers. When the source or destination operand is a memory operand, the operand must be aligned on a 16 (EVEX.128)/32(EVEX.256)/64(EVEX.512)-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction.",
            "The destination operand is updated at 32-bit (VMOVDQA32) or 64-bit (VMOVDQA64) granularity according to the writemask.",
            "VEX.256 encoded version:",
            "Moves 256 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers.",
            "When the source or destination operand is a memory operand, the operand must be aligned on a 32-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "128-bit versions:",
            "Moves 128 bits of packed integer values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load an XMM register from a 128-bit memory location, to store the contents of an XMM register into a 128-bit memory location, or to move data between two XMM registers.",
            "When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. To move integer data to and from unaligned memory locations, use the VMOVDQU instruction.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVDQA:VMOVDQA32:VMOVDQA64.html"
        ]
    },
    "ptwrite": {
        "detail": [
            "Write Data to a Processor Trace Packet"
        ],
        "documentation": [
            "This instruction reads data in the source operand and sends it to the Intel Processor Trace hardware to be encoded in a PTW packet if TriggerEn, ContextEn, FilterEn, and PTWEn are all set to 1. For more details on these values, see Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C, Section 35.2.2, “Software Trace Instrumentation with PTWRITE”. The size of data is 64-bit if using REX.W in 64-bit mode, otherwise 32-bits of data are copied from the source operand.",
            "Note: The instruction will #UD if prefix 66H is used.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.d",
            "reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/PTWRITE.html"
        ]
    },
    "xbegin": {
        "detail": [
            "Transactional Begin"
        ],
        "documentation": [
            "The XBEGIN instruction specifies the start of an RTM code region. If the logical processor was not already in transactional execution, then the XBEGIN instruction causes the logical processor to transition into transactional execution. The XBEGIN instruction that transitions the logical processor into transactional execution is referred to as the outermost XBEGIN instruction. The instruction also specifies a relative offset to compute the address of the fallback code path following a transactional abort.",
            "On an RTM abort, the logical processor discards all architectural register and memory updates performed during the RTM execution and restores architectural state to that corresponding to the outermost XBEGIN instruction. The fallback address following an abort is computed from the outermost XBEGIN instruction.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.w, reg.q, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XBEGIN.html"
        ]
    },
    "repne outsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.w, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "pcmpistri": {
        "detail": [
            "Packed Compare Implicit Length Strings, Return Index"
        ],
        "documentation": [
            "The instruction compares data from two strings based on the encoded value in the Imm8 Control Byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates an index stored to ECX.",
            "Each string is represented by a single value. The value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). Each input byte/word is augmented with a valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null byte/word. (The least significant null byte/word is also considered invalid.)",
            "The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see Section 4.1). The index of the first (or last, according to imm8[6]) set bit of IntRes2 is returned in ECX. If no bits are set in IntRes2, ECX is set to 16 (8).",
            "Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:",
            "CFlag – Reset if IntRes2 is equal to zero, set otherwise",
            "ZFlag – Set if any byte/word of xmm2/mem128 is null, reset otherwise",
            "SFlag – Set if any byte/word of xmm1 is null, reset otherwise",
            "OFlag –IntRes2[0]",
            "AFlag – Reset",
            "PFlag – Reset",
            "Note: In VEX.128 encoded version, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.x, reg.x, imm.b, reg",
            "reg.x, mem.x, imm.b, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPISTRI.html"
        ]
    },
    "punpckhbw": {
        "detail": [
            "Unpack High Data"
        ],
        "documentation": [
            "Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. Figure 4-20 shows the unpack operation for bytes in 64-bit operands. The low-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html"
        ]
    },
    "pcmpistrm": {
        "detail": [
            "Packed Compare Implicit Length Strings, Return Mask"
        ],
        "documentation": [
            "The instruction compares data from two strings based on the encoded value in the imm8 byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”) generating a mask stored to XMM0.",
            "Each string is represented by a single value. The value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). Each input byte/word is augmented with a valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null byte/word. (The least significant null byte/word is also considered invalid.)",
            "The comparison and aggregation operation are performed according to the encoded value of Imm8 bit fields (see Section 4.1). As defined by imm8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.",
            "Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:",
            "CFlag – Reset if IntRes2 is equal to zero, set otherwise",
            "ZFlag – Set if any byte/word of xmm2/mem128 is null, reset otherwise",
            "SFlag – Set if any byte/word of xmm1 is null, reset otherwise",
            "OFlag – IntRes2[0]",
            "AFlag – Reset",
            "PFlag – Reset",
            "Note: In VEX.128 encoded versions, bits (MAXVL-1:128) of XMM0 are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.x, reg.x, imm.b, reg.x",
            "reg.x, mem.x, imm.b, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPISTRM.html"
        ]
    },
    "femms": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "vfpclasspd": {
        "detail": [
            "Tests Types Of a Packed Float64 Values"
        ],
        "documentation": [
            "The FPCLASSPD instruction checks the packed double precision floating point values for special categories, specified by the set bits in the imm8 byte. Each set bit in imm8 specifies a category of floating-point values that the input data element is classified against. The classified results of all specified categories of an input value are ORed together to form the final boolean result for the input element. The result of each element is written to the corresponding bit in a mask register k2 according to the writemask k1. Bits [MAX_KL-1:8/4/2] of the destination are cleared.",
            "The classification categories specified by imm8 are shown in Figure 5-13. The classification test for each category is listed in Table 5-13."
        ],
        "operands": [
            "reg.q, reg.q, mem.x, imm.b",
            "reg.q, reg.x, imm.b",
            "reg.q, mem.x, imm.b",
            "reg.q, reg.q, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFPCLASSPD.html"
        ]
    },
    "vfpclassps": {
        "detail": [
            "Tests Types Of a Packed Float32 Values"
        ],
        "documentation": [
            "The FPCLASSPS instruction checks the packed single-precision floating point values for special categories, specified by the set bits in the imm8 byte. Each set bit in imm8 specifies a category of floating-point values that the input data element is classified against. The classified results of all specified categories of an input value are ORed together to form the final boolean result for the input element. The result of each element is written to the corresponding bit in a mask register k2 according to the writemask k1. Bits [MAX_KL-1:16/8/4] of the destination are cleared.",
            "The classification categories specified by imm8 are shown in Figure 5-13. The classification test for each category is listed in Table 5-13.",
            "The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.q, reg.q, mem.x, imm.b",
            "reg.q, reg.x, imm.b",
            "reg.q, mem.x, imm.b",
            "reg.q, reg.q, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFPCLASSPS.html"
        ]
    },
    "fnstcw": {
        "detail": [
            "Store x87 FPU Control Word"
        ],
        "documentation": [
            "Stores the current value of the FPU control word at the specified destination in memory. The FSTCW instruction checks for and handles pending unmasked floating-point exceptions before storing the control word; the FNSTCW instruction does not.",
            "The assembler issues two instructions for the FSTCW instruction (an FWAIT instruction followed by an FNSTCW instruction), and the processor executes each of these instructions in separately. If an exception is generated for either of these instructions, the save EIP points to the instruction that caused the exception.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "mem.w, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FSTCW:FNSTCW.html"
        ]
    },
    "fpatan": {
        "detail": [
            "Partial Arctangent"
        ],
        "documentation": [
            "Computes the arctangent of the source operand in register ST(1) divided by the source operand in register ST(0), stores the result in ST(1), and pops the FPU register stack. The result in register ST(0) has the same sign as the source operand ST(1) and a magnitude less than +π.",
            "The FPATAN instruction returns the angle between the X axis and the line from the origin to the point (X,Y), where Y (the ordinate) is ST(1) and X (the abscissa) is ST(0). The angle depends on the sign of X and Y independently, not just on the sign of the ratio Y/X. This is because a point (−X,Y) is in the second quadrant, resulting in an angle between π/2 and π, while a point (X,−Y) is in the fourth quadrant, resulting in an angle between 0 and −π/2. A point (−X,−Y) is in the third quadrant, giving an angle between −π/2 and −π.",
            "The following table shows the results obtained when computing the arctangent of various classes of numbers, assuming that underflow does not occur."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FPATAN.html"
        ]
    },
    "comisd": {
        "detail": [
            "Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS"
        ],
        "documentation": [
            "Compares the double-precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).",
            "Operand 1 is an XMM register; operand 2 can be an XMM register or a 64 bit memory",
            "location. The COMISD instruction differs from the UCOMISD instruction in that it signals a SIMD floating-point invalid operation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISD instruction signals an invalid numeric exception only if a source operand is an SNaN.",
            "The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCOMISD is encoded with VEX.L=0. Encoding VCOMISD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.q, reg.q",
            "reg.q, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/COMISD.html"
        ]
    },
    "fcmovnbe": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "documentation": [
            "Tests the status flags in the EFLAGS register and moves the source operand (second operand) to the destination operand (first operand) if the given test condition is true. The condition for each mnemonic os given in the Description column above and in Chapter 8 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. The source operand is always in the ST(i) register and the destination operand is always ST(0).",
            "The FCMOVcc instructions are useful for optimizing small IF constructions. They also help eliminate branching overhead for IF operations and the possibility of branch mispredictions by the processor.",
            "A processor may not support the FCMOVcc instructions. Software can check if the FCMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “COMISS—Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS” in this chapter). If both the CMOV and FPU feature bits are set, the FCMOVcc instructions are supported.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCMOVcc.html"
        ]
    },
    "vaesimc": {
        "detail": [
            "Perform the AES InvMixColumn Transformation"
        ],
        "documentation": [
            "Perform the InvMixColumns transformation on the source operand and store the result in the destination operand. The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.",
            "Note: the AESIMC instruction should be applied to the expanded AES round keys (except for the first and last round key) in order to prepare them for decryption using the “Equivalent Inverse Cipher” (defined in FIPS 197).",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/AESIMC.html"
        ]
    },
    "vpor": {
        "detail": [
            "Bitwise Logical OR"
        ],
        "documentation": [
            "Performs a bitwise logical OR operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is set to 1 if either or both of the corresponding bits of the first and second operands are 1; otherwise, it is set to 0.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source and destination operands can be XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source and destination operands can be XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The second source operand is an YMM register or a 256-bit memory location. The first source and destination operands can be YMM registers.",
            "EVEX encoded version: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 32/64-bit granularity.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/POR.html"
        ]
    },
    "vcvttss2si": {
        "detail": [
            "Convert with Truncation Scalar Single-Precision Floating-Point Value to Integer"
        ],
        "documentation": [
            "Converts a single-precision floating-point value in the source operand (the second operand) to a signed double-word integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand). The source operand can be an XMM register or a 32-bit memory location. The destination operand is a general purpose register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register.",
            "When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised. If this exception is masked, the indefinite integer value (80000000H or 80000000_00000000H if operand size is 64 bits) is returned.",
            "Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation. See the summary chart at the beginning of this section for encoding data and limits.",
            "VEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCVTTSS2SI is encoded with VEX.L=0. Encoding VCVTTSS2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTTSS2SI.html"
        ]
    },
    "vmptrld": {
        "detail": [
            "Load Pointer to Virtual-Machine Control Structure"
        ],
        "documentation": [
            "Marks the current-VMCS pointer valid and loads it with the physical address in the instruction operand. The instruction fails if its operand is not properly aligned, sets unsupported physical-address bits, or is equal to the VMXON pointer. In addition, the instruction fails if the 32 bits in memory referenced by the operand do not match the VMCS revision identifier supported by this processor.2",
            "The operand of this instruction is always 64 bits and is always in memory.",
            "Flags Affected:",
            "See the operation section and Section 30.2."
        ],
        "operands": [
            "mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VMPTRLD.html"
        ]
    },
    "xlat": {
        "detail": [
            "Table Look-up Translation"
        ],
        "documentation": [
            "Locates a byte entry in a table in memory, using the contents of the AL register as a table index, then copies the contents of the table entry back into the AL register. The index in the AL register is treated as an unsigned integer. The XLAT and XLATB instructions get the base address of the table in memory from either the DS:EBX or the DS:BX registers (depending on the address-size attribute of the instruction, 32 or 16, respectively). (The DS segment may be overridden with a segment override prefix.)",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operand” form and the “no-operand” form. The explicit-operand form (specified with the XLAT mnemonic) allows the base address of the table to be specified explicitly with a symbol. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the symbol does not have to specify the correct base address. The base address is always specified by the DS:(E)BX registers, which must be loaded correctly before the XLAT instruction is executed.",
            "The no-operands form (XLATB) provides a “short form” of the XLAT instructions. Here also the processor assumes that the DS:(E)BX registers contain the base address of the table.",
            "In 64-bit mode, operation is similar to that in legacy or compatibility mode. AL is used to specify the table index (the operand size is fixed at 8 bits). RBX, however, is used to specify the table’s base address. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.b, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XLAT:XLATB.html"
        ]
    },
    "comiss": {
        "detail": [
            "Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS"
        ],
        "documentation": [
            "Compares the single-precision floating-point values in the low quadwords of operand 1 (first operand) and operand 2 (second operand), and sets the ZF, PF, and CF flags in the EFLAGS register according to the result (unordered, greater than, less than, or equal). The OF, SF and AF flags in the EFLAGS register are set to 0. The unordered result is returned if either source operand is a NaN (QNaN or SNaN).",
            "Operand 1 is an XMM register; operand 2 can be an XMM register or a 32 bit memory location.",
            "The COMISS instruction differs from the UCOMISS instruction in that it signals a SIMD floating-point invalid operation exception (#I) when a source operand is either a QNaN or SNaN. The UCOMISS instruction signals an invalid numeric exception only if a source operand is an SNaN.",
            "The EFLAGS register is not updated if an unmasked SIMD floating-point exception is generated.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCOMISS is encoded with VEX.L=0. Encoding VCOMISS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/COMISS.html"
        ]
    },
    "bextr": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.d, imm.d",
            "reg.d, mem.d, reg.d",
            "reg.d, reg.d, reg.d",
            "reg.d, mem.d, imm.d"
        ],
        "url": [
            "https://"
        ]
    },
    "mov": {
        "detail": [
            "Move"
        ],
        "documentation": [
            "Copies the second operand (source operand) to the first operand (destination operand). The source operand can be an immediate value, general-purpose register, segment register, or memory location; the destination register can be a general-purpose register, segment register, or memory location. Both operands must be the same size, which can be a byte, a word, a doubleword, or a quadword.",
            "The MOV instruction cannot be used to load the CS register. Attempting to do so results in an invalid opcode exception (#UD). To load the CS register, use the far JMP, CALL, or RET instruction.",
            "If the destination operand is a segment register (DS, ES, FS, GS, or SS), the source operand must be a valid segment selector. In protected mode, moving a segment selector into a segment register automatically causes the segment descriptor information associated with that segment selector to be loaded into the hidden (shadow) part of the segment register. While loading this information, the segment selector and segment descriptor information is validated (see the “Operation” algorithm below). The segment descriptor data is obtained from the GDT or LDT entry for the specified segment selector.",
            "A NULL segment selector (values 0000-0003) can be loaded into the DS, ES, FS, and GS registers without causing a protection exception. However, any subsequent attempt to reference a segment whose corresponding segment register is loaded with a NULL value causes a general protection exception (#GP) and no memory reference occurs.",
            "Loading the SS register with a MOV instruction suppresses or inhibits some debug exceptions and inhibits interrupts on the following instruction boundary. (The inhibition ends after delivery of an exception or the execution of the next instruction.) This behavior allows a stack pointer to be loaded into the ESP register with the next instruction (MOV ESP, stack-pointer value) before an event can be delivered. See Section 6.8.3, “Masking Exceptions and Interrupts When Switching Stacks,” in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A. Intel recommends that software use the LSS instruction to load the SS register and ESP together.",
            "When executing MOV Reg, Sreg, the processor copies the content of Sreg to the 16 least significant bits of the general-purpose register. The upper bits of the destination register are zero for most IA-32 processors (Pentium Pro processors and later) and all Intel 64 processors, with the exception that bits 31:16 are undefined for Intel Quark X1000 processors, Pentium and earlier processors.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.b, mem.b",
            "mem.b, imm.b",
            "reg.b, reg.b",
            "mem.b, reg.b",
            "reg.q, imm.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOV.html"
        ]
    },
    "skinit": {
        "detail": [
            ""
        ],
        "operands": [
            "reg"
        ],
        "url": [
            "https://"
        ]
    },
    "blci": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://"
        ]
    },
    "vmovntdq": {
        "detail": [
            "Store Packed Integers Using Non-Temporal Hint"
        ],
        "documentation": [
            "Moves the packed integers in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register, YMM register or ZMM register, which is assumed to contain integer data (packed bytes, words, double-words, or quadwords). The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (512-bit version) boundary otherwise a general-protection exception (#GP) will be generated.",
            "The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the IA-32 Intel Architecture Software Developer’s Manual, Volume 1.",
            "Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with VMOVNTDQ instructions if multiple processors might use different memory types to read/write the destination memory locations.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, VEX.L must be 0; otherwise instructions will #UD."
        ],
        "operands": [
            "mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVNTDQ.html"
        ]
    },
    "vpmovw2m": {
        "detail": [
            "Convert a Vector Register to a Mask"
        ],
        "documentation": [
            "Converts a vector register to a mask register. Each element in the destination register is set to 1 or 0 depending on the value of most significant bit of the corresponding element in the source register.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a mask register.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVB2M:VPMOVW2M:VPMOVD2M:VPMOVQ2M.html"
        ]
    },
    "vextracti128": {
        "detail": [
            "Extract packed Integer Values"
        ],
        "documentation": [
            "VEXTRACTI128/VEXTRACTI32x4 and VEXTRACTI64x2 extract 128-bits of doubleword integer values from the source operand (the second operand) and store to the low 128-bit of the destination operand (the first operand). The 128-bit data extraction occurs at an 128-bit granular offset specified by imm8[0] (256-bit) or imm8[1:0] as the multiply factor. The destination may be either a vector register or an 128-bit memory location.",
            "VEXTRACTI32x4: The low 128-bit of the destination operand is updated at 32-bit granularity according to the writemask.",
            "VEXTRACTI64x2: The low 128-bit of the destination operand is updated at 64-bit granularity according to the writemask.",
            "VEXTRACTI32x8 and VEXTRACTI64x4 extract 256-bits of quadword integer values from the source operand (the second operand) and store to the low 256-bit of the destination operand (the first operand). The 256-bit data extraction occurs at an 256-bit granular offset specified by imm8[0] (256-bit) or imm8[0] as the multiply factor The destination may be either a vector register or a 256-bit memory location.",
            "VEXTRACTI32x8: The low 256-bit of the destination operand is updated at 32-bit granularity according to the writemask.",
            "VEXTRACTI64x4: The low 256-bit of the destination operand is updated at 64-bit granularity according to the writemask.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "The high 7 bits (6 bits in EVEX.512) of the immediate are ignored.",
            "If VEXTRACTI128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.x, reg.y, imm.b",
            "mem.x, reg.y, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html"
        ]
    },
    "v4fnmaddss": {
        "detail": [
            "Scalar Single-Precision Floating-Point Fused Multiply-Add (4-iterations)"
        ],
        "documentation": [
            "This instruction computes 4 sequential scalar fused single-precision floating-point multiply-add instructions with a sequentially selected memory operand in each of the four steps.",
            "In the above box, the notation of “+3” is used to denote that the instruction accesses 4 source registers based that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand.",
            "This instruction supports memory fault suppression. The entire memory operand is loaded if the least significant mask bit is set to 1 or if a “no masking” encoding is used.",
            "The tuple type Tuple1_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction.",
            "Rounding is performed at every FMA boundary. Exceptions are also taken sequentially. Pre- and post-computational exceptions of the first FMA take priority over the pre- and post-computational exceptions of the second FMA, etc."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.x, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/V4FMADDSS:V4FNMADDSS.html"
        ]
    },
    "prefetchnta": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.z"
        ],
        "url": [
            "https://"
        ]
    },
    "pandn": {
        "detail": [
            "Logical AND NOT"
        ],
        "documentation": [
            "Performs a bitwise logical NOT operation on the first source operand, then performs bitwise AND with second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bit in the first operand is 0 and the corresponding bit in the second operand is 1, otherwise it is set to 0.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 32/64-bit granularity.",
            "VEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PANDN.html"
        ]
    },
    "blcs": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://"
        ]
    },
    "vcmpsd": {
        "detail": [
            "Compare Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Compares the low double-precision floating-point values in the second source operand and the first source operand and returns the results in of the comparison to the destination operand. The comparison predicate operand (immediate operand) specifies the type of comparison performed.",
            "128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 64-bit memory location. Bits (MAXVL-1:64) of the corresponding YMM destination register remain unchanged. The comparison result is a quadword mask of all 1s (comparison true) or all 0s (comparison false).",
            "VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 64-bit memory location. The result is stored in the low quadword of the destination operand; the high quadword is filled with the contents of the high quadword of the first source operand. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. The comparison result is a quadword mask of all 1s (comparison true) or all 0s (comparison false).",
            "EVEX encoded version: The first source operand (second operand) is an XMM register. The second source operand can be a XMM register or a 64-bit memory location. The destination operand (first operand) is an opmask register. The comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false), written to the destination starting from the LSB according to the writemask k2. Bits (MAX_KL-1:128) of the destination register are cleared.",
            "The comparison predicate operand is an 8-bit immediate:"
        ],
        "operands": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.q, reg.q, reg.x, reg.x, imm.b",
            "reg.q, reg.q, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPSD.html"
        ]
    },
    "aesdeclast": {
        "detail": [
            "Perform Last Round of an AES Decryption Flow"
        ],
        "documentation": [
            "This instruction performs the last round of the AES decryption flow using the Equivalent Inverse Cipher, with the round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and store the result in the destination operand.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/AESDECLAST.html"
        ]
    },
    "psmash": {
        "detail": [
            ""
        ],
        "operands": [
            "reg"
        ],
        "url": [
            "https://"
        ]
    },
    "vcmpss": {
        "detail": [
            "Compare Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Compares the low single-precision floating-point values in the second source operand and the first source operand and returns the results of the comparison to the destination operand. The comparison predicate operand (immediate operand) specifies the type of comparison performed.",
            "128-bit Legacy SSE version: The first source and destination operand (first operand) is an XMM register. The second source operand (second operand) can be an XMM register or 32-bit memory location. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged. The comparison result is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).",
            "VEX.128 encoded version: The first source operand (second operand) is an XMM register. The second source operand (third operand) can be an XMM register or a 32-bit memory location. The result is stored in the low 32 bits of the destination operand; bits 128:32 of the destination operand are copied from the first source operand. Bits (MAXVL-1:128) of the destination ZMM register are zeroed. The comparison result is a doubleword mask of all 1s (comparison true) or all 0s (comparison false).",
            "EVEX encoded version: The first source operand (second operand) is an XMM register. The second source operand can be a XMM register or a 32-bit memory location. The destination operand (first operand) is an opmask register. The comparison result is a single mask bit of 1 (comparison true) or 0 (comparison false), written to the destination starting from the LSB according to the writemask k2. Bits (MAX_KL-1:128) of the destination register are cleared.",
            "The comparison predicate operand is an 8-bit immediate:"
        ],
        "operands": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.q, reg.q, reg.x, reg.x, imm.b",
            "reg.q, reg.q, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.d, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMPSS.html"
        ]
    },
    "sqrtsd": {
        "detail": [
            "Compute Square Root of Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Computes the square root of the low double-precision floating-point value in the second source operand and stores the double-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. The quadword at bits 127:64 of the destination operand remains unchanged. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded versions: Bits 127:64 of the destination operand are copied from the corresponding bits of the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination operand is updated according to the writemask.",
            "Software should ensure VSQRTSD is encoded with VEX.L=0. Encoding VSQRTSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/SQRTSD.html"
        ]
    },
    "vpopcntb": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpopcntd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://"
        ]
    },
    "aesdec256kl": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.z"
        ],
        "url": [
            "https://"
        ]
    },
    "punpckhdq": {
        "detail": [
            "Unpack High Data"
        ],
        "documentation": [
            "Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. Figure 4-20 shows the unpack operation for bytes in 64-bit operands. The low-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html"
        ]
    },
    "vpsllvd": {
        "detail": [
            "Variable Bit Shift Left Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords or quadword) in the first source operand to the left by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0).",
            "The count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for word), 31 (for doublewords), or 63 (for a quadword), then the destination data element are written with 0.",
            "VEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded VPSLLVD/Q: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.",
            "EVEX encoded VPSLLVW: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is conditionally updated with writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPSLLVW:VPSLLVD:VPSLLVQ.html"
        ]
    },
    "smsw": {
        "detail": [
            "Store Machine Status Word"
        ],
        "documentation": [
            "Stores the machine status word (bits 0 through 15 of control register CR0) into the destination operand. The destination operand can be a general-purpose register or a memory location.",
            "In non-64-bit modes, when the destination operand is a 32-bit register, the low-order 16 bits of register CR0 are copied into the low-order 16 bits of the register and the high-order 16 bits are undefined. When the destination operand is a memory location, the low-order 16 bits of register CR0 are written to memory as a 16-bit quantity, regardless of the operand size.",
            "In 64-bit mode, the behavior of the SMSW instruction is defined by the following examples:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg",
            "mem.w, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/SMSW.html"
        ]
    },
    "sqrtss": {
        "detail": [
            "Compute Square Root of Scalar Single-Precision Value"
        ],
        "documentation": [
            "Computes the square root of the low single-precision floating-point value in the second source operand and stores the single-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands is an XMM register.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 and EVEX encoded versions: Bits 127:32 of the destination operand are copied from the corresponding bits of the first source operand. Bits (MAXVL-1:128) of the destination ZMM register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination operand is updated according to the writemask.",
            "Software should ensure VSQRTSS is encoded with VEX.L=0. Encoding VSQRTSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/SQRTSS.html"
        ]
    },
    "vmovshdup": {
        "detail": [
            "Replicate Single FP Values"
        ],
        "documentation": [
            "Duplicates odd-indexed single-precision floating-point values from the source operand (the second operand) to adjacent element pair in the destination operand (the first operand). See Figure 4-3. The source operand is an XMM, YMM or ZMM register or 128, 256 or 512-bit memory location and the destination operand is an XMM, YMM or ZMM register.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX encoded version: The destination operand is updated at 32-bit granularity according to the writemask.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVSHDUP.html"
        ]
    },
    "vzeroall": {
        "detail": [
            "Zero All YMM Registers"
        ],
        "documentation": [
            "The instruction zeros contents of all XMM or YMM registers.",
            "Note: VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD. In Compatibility and legacy 32-bit mode only the lower 8 registers are modified."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/VZEROALL.html"
        ]
    },
    "vpopcntq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://"
        ]
    },
    "vpopcntw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vpsllvq": {
        "detail": [
            "Variable Bit Shift Left Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords or quadword) in the first source operand to the left by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0).",
            "The count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for word), 31 (for doublewords), or 63 (for a quadword), then the destination data element are written with 0.",
            "VEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded VPSLLVD/Q: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.",
            "EVEX encoded VPSLLVW: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is conditionally updated with writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPSLLVW:VPSLLVD:VPSLLVQ.html"
        ]
    },
    "clac": {
        "detail": [
            "Clear AC Flag in EFLAGS Register"
        ],
        "documentation": [
            "Clears the AC flag bit in EFLAGS register. This disables any alignment checking of user-mode data accesses. If the SMAP bit is set in the CR4 register, this disallows explicit supervisor-mode data accesses to user-mode pages.",
            "This instruction's operation is the same in non-64-bit modes and 64-bit mode. Attempts to execute CLAC when CPL > 0 cause #UD.",
            "Flags Affected:",
            "AC cleared. Other flags are unaffected."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/CLAC.html"
        ]
    },
    "vfmaddsub213pd": {
        "detail": [
            "Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFMADDSUB132PD: Multiplies the two, four, or eight packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the even double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMADDSUB213PD: Multiplies the two, four, or eight packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the first source operand. From the infinite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the even double-precision floating-point values in the third source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMADDSUB231PD: Multiplies the two, four, or eight packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the even double-precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADDSUB132PD:VFMADDSUB213PD:VFMADDSUB231PD.html"
        ]
    },
    "pause": {
        "detail": [
            "Spin Loop Hint"
        ],
        "documentation": [
            "Improves the performance of spin-wait loops. When executing a “spin-wait loop,” processors will suffer a severe performance penalty when exiting the loop because it detects a possible memory order violation. The PAUSE instruction provides a hint to the processor that the code sequence is a spin-wait loop. The processor uses this hint to avoid the memory order violation in most situations, which greatly improves processor performance. For this reason, it is recommended that a PAUSE instruction be placed in all spin-wait loops.",
            "An additional function of the PAUSE instruction is to reduce the power consumed by a processor while executing a spin loop. A processor can execute a spin-wait loop extremely quickly, causing the processor to consume a lot of power while it waits for the resource it is spinning on to become available. Inserting a pause instruction in a spin-wait loop greatly reduces the processor’s power consumption.",
            "This instruction was introduced in the Pentium 4 processors, but is backward compatible with all IA-32 processors. In earlier IA-32 processors, the PAUSE instruction operates like a NOP instruction. The Pentium 4 and Intel Xeon processors implement the PAUSE instruction as a delay. The delay is finite and can be zero for some processors. This instruction does not change the architectural state of the processor (that is, it performs essentially a delaying no-op operation).",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/PAUSE.html"
        ]
    },
    "vpsllvw": {
        "detail": [
            "Variable Bit Shift Left Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords or quadword) in the first source operand to the left by the count value of respective data elements in the second source operand. As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0).",
            "The count values are specified individually in each data element of the second source operand. If the unsigned integer value specified in the respective data element of the second source operand is greater than 15 (for word), 31 (for doublewords), or 63 (for a quadword), then the destination data element are written with 0.",
            "VEX.128 encoded version: The destination and first source operands are XMM registers. The count operand can be either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The destination and first source operands are YMM registers. The count operand can be either an YMM register or a 256-bit memory. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded VPSLLVD/Q: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination is conditionally updated with writemask k1.",
            "EVEX encoded VPSLLVW: The destination and first source operands are ZMM/YMM/XMM registers. The count operand can be either a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination is conditionally updated with writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPSLLVW:VPSLLVD:VPSLLVQ.html"
        ]
    },
    "vpmadd52luq": {
        "detail": [
            "Packed Multiply of Unsigned 52-bit Integers and Add the Low 52-bit Products to Qword Accumulators"
        ],
        "documentation": [
            "Multiplies packed unsigned 52-bit integers in each qword element of the first source operand (the second operand) with the packed unsigned 52-bit integers in the corresponding elements of the second source operand (the third operand) to form packed 104-bit intermediate results. The low 52-bit, unsigned integer of each 104-bit product is added to the corresponding qword unsigned integer of the destination operand (the first operand) under the writemask k1.",
            "The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 64-bit granularity.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMADD52LUQ.html"
        ]
    },
    "vpsrldq": {
        "detail": [
            "Shift Double Quadword Right Logical"
        ],
        "documentation": [
            "Shifts the destination operand (first operand) to the right by the number of bytes specified in the count operand (second operand). The empty high-order bytes are cleared (set to all 0s). If the value specified by the count operand is greater than 15, the destination operand is set to all 0s. The count operand is an 8-bit immediate.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The source and destination operands are the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The source and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The source operand is a YMM register. The destination operand is a YMM register. The count operand applies to both the low and high 128-bit lanes.",
            "VEX.256 encoded version: The source operand is YMM register. The destination operand is an YMM register. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed. The count operand applies to both the low and high 128-bit lanes.",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register. The count operand applies to each 128-bit lanes.",
            "Note: VEX.vvvv/EVEX.vvvv encodes the destination register.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSRLDQ.html"
        ]
    },
    "vfmaddpd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vfmaddsub213ps": {
        "detail": [
            "Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFMADDSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the corresponding packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and subtracts the even single-precision floating-point values in the second source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMADDSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the corresponding packed single-precision floating-point values in the first source operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and subtracts the even single-precision floating-point values in the third source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMADDSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the corresponding packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and subtracts the even single-precision floating-point values in the first source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADDSUB132PS:VFMADDSUB213PS:VFMADDSUB231PS.html"
        ]
    },
    "setssbsy": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "vfmaddps": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vldmxcsr": {
        "detail": [
            "Load MXCSR Register"
        ],
        "documentation": [
            "Loads the source operand into the MXCSR control/status register. The source operand is a 32-bit memory location. See “MXCSR Control and Status Register” in Chapter 10, of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a description of the MXCSR register and its contents.",
            "The LDMXCSR instruction is typically used in conjunction with the (V)STMXCSR instruction, which stores the contents of the MXCSR register in memory.",
            "The default MXCSR value at reset is 1F80H.",
            "If a (V)LDMXCSR instruction clears a SIMD floating-point exception mask bit and sets the corresponding exception flag bit, a SIMD floating-point exception will not be immediately generated. The exception will be generated only upon the execution of the next instruction that meets both conditions below:"
        ],
        "operands": [
            "mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/LDMXCSR.html"
        ]
    },
    "xsave": {
        "detail": [
            "Save Processor Extended States"
        ],
        "documentation": [
            "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.",
            "The format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Section 13.7, “Operation of XSAVE,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XSAVE instruction. The following items provide a high-level outline:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.z[4096], reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XSAVE.html"
        ]
    },
    "pslld": {
        "detail": [
            "Shift Packed Data Left Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-17 gives an example of shifting words in a 64-bit operand.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html"
        ]
    },
    "vhsubpd": {
        "detail": [
            "Packed Double-FP Horizontal Subtract"
        ],
        "documentation": [
            "The HSUBPD instruction subtracts horizontally the packed DP FP numbers of both operands.",
            "Subtracts the double-precision floating-point value in the high quadword of the destination operand from the low quadword of the destination operand and stores the result in the low quadword of the destination operand.",
            "Subtracts the double-precision floating-point value in the high quadword of the source operand from the low quadword of the source operand and stores the result in the high quadword of the destination operand.",
            "In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
            "See Figure 3-20 for HSUBPD; see Figure 3-21 for VHSUBPD."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/HSUBPD.html"
        ]
    },
    "invept": {
        "detail": [
            "Invalidate Translations Derived from EPT"
        ],
        "documentation": [
            "Invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches that were derived from extended page tables (EPT). (See Chapter 28, “VMX Support for Address Translation”.) Invalidation is based on the INVEPT type specified in the register operand and the INVEPT descriptor specified in the memory operand.",
            "Outside IA-32e mode, the register operand is always 32 bits, regardless of the value of CS.D; in 64-bit mode, the register operand has 64 bits (the instruction cannot be executed in compatibility mode).",
            "The INVEPT types supported by a logical processors are reported in the IA32_VMX_EPT_VPID_CAP MSR (see Appendix A, “VMX Capability Reporting Facility”). There are two INVEPT types currently defined:",
            "Flags Affected:",
            "See the operation section and Section 30.2."
        ],
        "operands": [
            "reg.q, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/INVEPT.html"
        ]
    },
    "invvpid": {
        "detail": [
            "Invalidate Translations Based on VPID"
        ],
        "documentation": [
            "Invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on virtualprocessor identifier (VPID). (See Chapter 28, “VMX Support for Address Translation”.) Invalidation is based on the INVVPID type specified in the register operand and the INVVPID descriptor specified in the memory operand.",
            "Outside IA-32e mode, the register operand is always 32 bits, regardless of the value of CS.D; in 64-bit mode, the register operand has 64 bits (the instruction cannot be executed in compatibility mode).",
            "The INVVPID types supported by a logical processors are reported in the IA32_VMX_EPT_VPID_CAP MSR (see Appendix A, “VMX Capability Reporting Facility”). There are four INVVPID types currently defined:",
            "Flags Affected:",
            "See the operation section and Section 30.2."
        ],
        "operands": [
            "reg.q, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/INVVPID.html"
        ]
    },
    "sfence": {
        "detail": [
            "Store Fence"
        ],
        "documentation": [
            "Orders processor execution relative to all memory stores prior to the SFENCE instruction. The processor ensures that every store prior to SFENCE is globally visible before any store after SFENCE becomes globally visible. The SFENCE instruction is ordered with respect to memory stores, other SFENCE instructions, MFENCE instructions, and any serializing instructions (such as the CPUID instruction). It is not ordered with respect to memory loads or the LFENCE instruction.",
            "Weakly ordered memory types can be used to achieve higher processor performance through such techniques as out-of-order issue, write-combining, and write-collapsing. The degree to which a consumer of data recognizes or knows that the data is weakly ordered varies among applications and may be unknown to the producer of this data. The SFENCE instruction provides a performance-efficient way of ensuring store ordering between routines that produce weakly-ordered results and routines that consume this data.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
            "Specification of the instruction's opcode above indicates a ModR/M byte of F8. For this instruction, the processor ignores the r/m field of the ModR/M byte. Thus, SFENCE is encoded by any opcode of the form 0F AE Fx, where x is in the range 8-F."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/SFENCE.html"
        ]
    },
    "vaesdec": {
        "detail": [
            "Perform One Round of an AES Decryption Flow"
        ],
        "documentation": [
            "This instruction performs a single round of the AES decryption flow using the Equivalent Inverse Cipher, with the round key from the second source operand, operating on a 128-bit data (state) from the first source operand, and store the result in the destination operand.",
            "Use the AESDEC instruction for all but the last decryption round. For the last decryption round, use the AESDECLAST instruction.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/AESDEC.html"
        ]
    },
    "vprorvd": {
        "detail": [
            "Bit Rotate Right"
        ],
        "documentation": [
            "Rotates the bits in the individual data elements (doublewords, or quadword) in the first source operand to the right by the number of bits specified in the count operand. If the value specified by the count operand is greater than 31 (for doublewords), or 63 (for a quadword), then the count operand modulo the data size (32 or 64) is used.",
            "EVEX.128 encoded version: The destination operand is a XMM register. The source operand is a XMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.",
            "EVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX.512 encoded version: The destination operand is a ZMM register updated according to the writemask. For the count operand in immediate form, the source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location, the count operand is an 8-bit immediate. For the count operand in variable form, the first source operand (the second operand) is a ZMM register and the counter operand (the third operand) is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPRORD:VPRORVD:VPRORQ:VPRORVQ.html"
        ]
    },
    "out": {
        "detail": [
            "Output to Port"
        ],
        "documentation": [
            "Copies the value from the second operand (source operand) to the I/O port specified with the destination operand (first operand). The source operand can be register AL, AX, or EAX, depending on the size of the port being accessed (8, 16, or 32 bits, respectively); the destination operand can be a byte-immediate or the DX register. Using a byte immediate allows I/O port addresses 0 to 255 to be accessed; using the DX register as a source operand allows I/O ports from 0 to 65,535 to be accessed.",
            "The size of the I/O port being accessed is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.",
            "At the machine code level, I/O instructions are shorter when accessing 8-bit I/O ports. Here, the upper eight bits of the port address will be 0.",
            "This instruction is only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 18, “Input/Output,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, reg",
            "imm.b, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/OUT.html"
        ]
    },
    "repe stosb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.b, reg, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vhsubps": {
        "detail": [
            "Packed Single-FP Horizontal Subtract"
        ],
        "documentation": [
            "Subtracts the single-precision floating-point value in the second dword of the destination operand from the first dword of the destination operand and stores the result in the first dword of the destination operand.",
            "Subtracts the single-precision floating-point value in the fourth dword of the destination operand from the third dword of the destination operand and stores the result in the second dword of the destination operand.",
            "Subtracts the single-precision floating-point value in the second dword of the source operand from the first dword of the source operand and stores the result in the third dword of the destination operand.",
            "Subtracts the single-precision floating-point value in the fourth dword of the source operand from the third dword of the source operand and stores the result in the fourth dword of the destination operand.",
            "In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15).",
            "See Figure 3-22 for HSUBPS; see Figure 3-23 for VHSUBPS."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/HSUBPS.html"
        ]
    },
    "repe stosd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.d, reg, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vfpclasssd": {
        "detail": [
            "Tests Types Of a Scalar Float64 Values"
        ],
        "documentation": [
            "The FPCLASSSD instruction checks the low double precision floating point value in the source operand for special categories, specified by the set bits in the imm8 byte. Each set bit in imm8 specifies a category of floating-point values that the input data element is classified against. The classified results of all specified categories of an input value are ORed together to form the final boolean result for the input element. The result is written to the low bit in a mask register k2 according to the writemask k1. Bits MAX_KL-1: 1 of the destination are cleared.",
            "The classification categories specified by imm8 are shown in Figure 5-13. The classification test for each category is listed in Table 5-13.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.q, reg.q, mem.q, imm.b",
            "reg.q, reg.x, imm.b",
            "reg.q, mem.q, imm.b",
            "reg.q, reg.q, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFPCLASSSD.html"
        ]
    },
    "psllq": {
        "detail": [
            "Shift Packed Data Left Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-17 gives an example of shifting words in a 64-bit operand.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html"
        ]
    },
    "psllw": {
        "detail": [
            "Shift Packed Data Left Logical"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords, or quadword) in the destination operand (first operand) to the left by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted left, the empty low-order bits are cleared (set to 0). If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for a quadword), then the destination operand is set to all 0s. Figure 4-17 gives an example of shifting words in a 64-bit operand.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html"
        ]
    },
    "vprorvq": {
        "detail": [
            "Bit Rotate Right"
        ],
        "documentation": [
            "Rotates the bits in the individual data elements (doublewords, or quadword) in the first source operand to the right by the number of bits specified in the count operand. If the value specified by the count operand is greater than 31 (for doublewords), or 63 (for a quadword), then the count operand modulo the data size (32 or 64) is used.",
            "EVEX.128 encoded version: The destination operand is a XMM register. The source operand is a XMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.",
            "EVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX.512 encoded version: The destination operand is a ZMM register updated according to the writemask. For the count operand in immediate form, the source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location, the count operand is an 8-bit immediate. For the count operand in variable form, the first source operand (the second operand) is a ZMM register and the counter operand (the third operand) is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPRORD:VPRORVD:VPRORQ:VPRORVQ.html"
        ]
    },
    "rdpid": {
        "detail": [
            "Read Processor ID"
        ],
        "documentation": [
            "Reads the value of the IA32_TSC_AUX MSR (address C0000103H) into the destination register. The value of CS.D and operand-size prefixes (66H and REX.W) do not affect the behavior of the RDPID instruction.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/RDPID.html"
        ]
    },
    "vcvtps2uqq": {
        "detail": [
            "Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values"
        ],
        "documentation": [
            "Converts up to eight packed single-precision floating-point values in the source operand to unsigned quadword integers in the destination operand.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w – 1 is returned, where w represents the number of bits in the destination format.",
            "The source operand is a YMM/XMM/XMM (low 64- bits) register or a 256/128/64-bit memory location. The destination operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.q",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTPS2UQQ.html"
        ]
    },
    "vfnmsub231pd": {
        "detail": [
            "Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMSUB132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source operand to the two, four or eight packed double-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFNMSUB213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source operand to the two, four or eight packed double-precision floating-point values in the first source operand. From negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFNMSUB231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source to the two, four or eight packed double-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMSUB132PD:VFNMSUB213PD:VFNMSUB231PD.html"
        ]
    },
    "repe stosq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.q, reg, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vfpclassss": {
        "detail": [
            "Tests Types Of a Scalar Float32 Values"
        ],
        "documentation": [
            "The FPCLASSSS instruction checks the low single-precision floating point value in the source operand for special categories, specified by the set bits in the imm8 byte. Each set bit in imm8 specifies a category of floating-point values that the input data element is classified against. The classified results of all specified categories of an input value are ORed together to form the final boolean result for the input element. The result is written to the low bit in a mask register k2 according to the writemask k1. Bits MAX_KL-1: 1 of the destination are cleared.",
            "The classification categories specified by imm8 are shown in Figure 5-13. The classification test for each category is listed in Table 5-13.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.q, reg.q, mem.d, imm.b",
            "reg.q, reg.x, imm.b",
            "reg.q, mem.d, imm.b",
            "reg.q, reg.q, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFPCLASSSS.html"
        ]
    },
    "repe stosw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.w, reg, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vaddpd": {
        "detail": [
            "Add Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Add two, four or eight packed double-precision floating-point values from the first source operand to the second source operand, and stores the packed double-precision floating-point results in the destination operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: the first source operand is a XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADDPD.html"
        ]
    },
    "andpd": {
        "detail": [
            "Bitwise Logical AND of Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical AND of the two, four or eight packed double-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ANDPD.html"
        ]
    },
    "vfnmsub231ps": {
        "detail": [
            "Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFNMSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the first source operand. From negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFNMSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMSUB132PS:VFNMSUB213PS:VFNMSUB231PS.html"
        ]
    },
    "rdseed": {
        "detail": [
            "Read Random SEED"
        ],
        "documentation": [
            "Loads a hardware generated random value and store it in the destination register. The random value is generated from an Enhanced NRBG (Non Deterministic Random Bit Generator) that is compliant to NIST SP800-90B and NIST SP800-90C in the XOR construction mode. The size of the random value is determined by the destination register size and operating mode. The Carry Flag indicates whether a random value is available at the time the instruction is executed. CF=1 indicates that the data in the destination is valid. Otherwise CF=0 and the data in the destination operand will be returned as zeros for the specified width. All other flags are forced to 0 in either situation. Software must check the state of CF=1 for determining if a valid random seed value has been returned, otherwise it is expected to loop and retry execution of RDSEED (see Section 1.2).",
            "The RDSEED instruction is available at all privilege levels. The RDSEED instruction executes normally either inside or outside a transaction region.",
            "In 64-bit mode, the instruction's default operation size is 32 bits. Using a REX prefix in the form of REX.B permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bit operands. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The CF flag is set according to the result (see the \"Operation\" section above). The OF, SF, ZF, AF, and PF flags are set to 0."
        ],
        "operands": [
            "reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/RDSEED.html"
        ]
    },
    "vaddps": {
        "detail": [
            "Add Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Add four, eight or sixteen packed single-precision floating-point values from the first source operand with the second source operand, and stores the packed single-precision floating-point results in the destination operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: the first source operand is a XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADDPS.html"
        ]
    },
    "cvttpd2dq": {
        "detail": [
            "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers"
        ],
        "documentation": [
            "Converts two, four or eight packed double-precision floating-point values in the source operand (second operand) to two, four or eight packed signed doubleword integers in the destination operand (first operand).",
            "When a conversion is inexact, a truncated (round toward zero) value is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM/XMM/XMM (low 64 bits) register conditionally updated with writemask k1. The upper bits (MAXVL-1:256) of the corresponding destination are zeroed.",
            "VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:64) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTTPD2DQ.html"
        ]
    },
    "vpermpd": {
        "detail": [
            "Permute Double-Precision Floating-Point Elements"
        ],
        "documentation": [
            "The imm8 version: Copies quadword elements of double-precision floating-point values from the source operand (the second operand) to the destination operand (the first operand) according to the indices specified by the immediate operand (the third operand). Each two-bit value in the immediate byte selects a qword element in the source operand.",
            "VEX version: The source operand can be a YMM register or a memory location. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "In EVEX.512 encoded version, The elements in the destination are updated using the writemask k1 and the imm8 bits are reused as control bits for the upper 256-bit half when the control bits are coming from immediate. The source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location.",
            "The imm8 versions: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "The vector control version: Copies quadword elements of double-precision floating-point values from the second source operand (the third operand) to the destination operand (the first operand) according to the indices in the first source operand (the second operand). The first 3 bits of each 64 bit element in the index operand selects which quadword in the second source operand to copy. The first and second operands are ZMM registers, the third operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The elements in the destination are updated using the writemask k1.",
            "Note that this instruction permits a qword in the source operand to be copied to multiple locations in the destination operand.",
            "If VPERMPD is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.y, reg.y, imm.b",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.y, mem.y, imm.b",
            "reg.z, reg.z, reg.z",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMPD.html"
        ]
    },
    "andps": {
        "detail": [
            "Bitwise Logical AND of Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical AND of the four, eight or sixteen packed single-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/ANDPS.html"
        ]
    },
    "outsb": {
        "detail": [
            "Output String to Port"
        ],
        "documentation": [
            "Copies data from the source operand (second operand) to the I/O port specified with the destination operand (first operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The DS segment may be overridden with a segment override prefix.) The destination operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the OUTS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand should be a symbol that indicates the size of the I/O port and the source address, and the destination operand must be DX. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI or RSI registers, which must be loaded correctly before the OUTS instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the OUTS instructions. Here also DS:(E)SI is assumed to be the source operand and DX is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic: OUTSB (byte), OUTSW (word), or OUTSD (doubleword).",
            "After the byte, word, or doubleword is transferred from the memory location to the I/O port, the SI/ESI/RSI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the SI/ESI/RSI register is decremented.) The SI/ESI/RSI register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by 4 for doubleword operations.",
            "The OUTS, OUTSB, OUTSW, and OUTSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix. This instruction is only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 18, “Input/Output,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.",
            "In 64-bit mode, the default operand size is 32 bits; operand size is not promoted by the use of REX.W. In 64-bit mode, the default address size is 64 bits, and 64-bit address is specified using RSI by default. 32-bit address using ESI is support using the prefix 67H, but 16-bit address is not supported in 64-bit mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/OUTS:OUTSB:OUTSW:OUTSD.html"
        ]
    },
    "outsd": {
        "detail": [
            "Output String to Port"
        ],
        "documentation": [
            "Copies data from the source operand (second operand) to the I/O port specified with the destination operand (first operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The DS segment may be overridden with a segment override prefix.) The destination operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the OUTS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand should be a symbol that indicates the size of the I/O port and the source address, and the destination operand must be DX. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI or RSI registers, which must be loaded correctly before the OUTS instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the OUTS instructions. Here also DS:(E)SI is assumed to be the source operand and DX is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic: OUTSB (byte), OUTSW (word), or OUTSD (doubleword).",
            "After the byte, word, or doubleword is transferred from the memory location to the I/O port, the SI/ESI/RSI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the SI/ESI/RSI register is decremented.) The SI/ESI/RSI register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by 4 for doubleword operations.",
            "The OUTS, OUTSB, OUTSW, and OUTSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix. This instruction is only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 18, “Input/Output,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.",
            "In 64-bit mode, the default operand size is 32 bits; operand size is not promoted by the use of REX.W. In 64-bit mode, the default address size is 64 bits, and 64-bit address is specified using RSI by default. 32-bit address using ESI is support using the prefix 67H, but 16-bit address is not supported in 64-bit mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, mem.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/OUTS:OUTSB:OUTSW:OUTSD.html"
        ]
    },
    "movshdup": {
        "detail": [
            "Replicate Single FP Values"
        ],
        "documentation": [
            "Duplicates odd-indexed single-precision floating-point values from the source operand (the second operand) to adjacent element pair in the destination operand (the first operand). See Figure 4-3. The source operand is an XMM, YMM or ZMM register or 128, 256 or 512-bit memory location and the destination operand is an XMM, YMM or ZMM register.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX encoded version: The destination operand is updated at 32-bit granularity according to the writemask.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVSHDUP.html"
        ]
    },
    "fxrstor64": {
        "detail": [
            "Restore x87 FPU, MMX, XMM, and MXCSR State"
        ],
        "documentation": [
            "Reloads the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte memory image specified in the source operand. This data should have been written to memory previously using the FXSAVE instruction, and in the same format as required by the operating modes. The first byte of the data should be located on a 16-byte boundary. There are three distinct layouts of the FXSAVE state map: one for legacy and compatibility mode, a second format for 64-bit mode FXSAVE/FXRSTOR with REX.W=0, and the third format is for 64-bit mode with FXSAVE64/FXRSTOR64. Table 3-43 shows the layout of the legacy/compatibility mode state information in memory and describes the fields in the memory image for the FXRSTOR and FXSAVE instructions. Table 3-46 shows the layout of the 64-bit mode state information when REX.W is set (FXSAVE64/FXRSTOR64). Table 3-47 shows the layout of the 64-bit mode state information when REX.W is clear (FXSAVE/FXRSTOR).",
            "The state image referenced with an FXRSTOR instruction must have been saved using an FXSAVE instruction or be in the same format as required by Table 3-43, Table 3-46, or Table 3-47. Referencing a state image saved with an FSAVE, FNSAVE instruction or incompatible field layout will result in an incorrect state restoration.",
            "The FXRSTOR instruction does not flush pending x87 FPU exceptions. To check and raise exceptions when loading x87 FPU state information with the FXRSTOR instruction, use an FWAIT instruction after the FXRSTOR instruction.",
            "If the OSFXSR bit in control register CR4 is not set, the FXRSTOR instruction may not restore the states of the XMM and MXCSR registers. This behavior is implementation dependent.",
            "If the MXCSR state contains an unmasked exception with a corresponding status flag also set, loading the register with the FXRSTOR instruction will not result in a SIMD floating-point error condition being generated. Only the next occurrence of this unmasked exception will result in the exception being generated.",
            "Bits 16 through 32 of the MXCSR register are defined as reserved and should be set to 0. Attempting to write a 1 in any of these bits from the saved state image will result in a general protection exception (#GP) being generated.",
            "Bytes 464:511 of an FXSAVE image are available for software use. FXRSTOR ignores the content of bytes 464:511 in an FXSAVE state image."
        ],
        "operands": [
            "mem.[4096], reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FXRSTOR.html"
        ]
    },
    "jle": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "vpmovzxwd": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "documentation": [
            "Legacy, VEX and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask.The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVZX.html"
        ]
    },
    "vpermps": {
        "detail": [
            "Permute Single-Precision Floating-Point Elements"
        ],
        "documentation": [
            "Copies doubleword elements of single-precision floating-point values from the second source operand (the third operand) to the destination operand (the first operand) according to the indices in the first source operand (the second operand). Note that this instruction permits a doubleword in the source operand to be copied to more than one location in the destination operand.",
            "VEX.256 versions: The first and second operands are YMM registers, the third operand can be a YMM register or memory location. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded version: The first and second operands are ZMM registers, the third operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The elements in the destination are updated using the writemask k1.",
            "If VPERMPS is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.y, reg.y, mem.y",
            "reg.y, reg.y, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMPS.html"
        ]
    },
    "vpmovzxwq": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "documentation": [
            "Legacy, VEX and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask.The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.d",
            "reg.x, reg.d",
            "reg.z, reg.q, mem.x",
            "reg.z, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVZX.html"
        ]
    },
    "outsw": {
        "detail": [
            "Output String to Port"
        ],
        "documentation": [
            "Copies data from the source operand (second operand) to the I/O port specified with the destination operand (first operand). The source operand is a memory location, the address of which is read from either the DS:SI, DS:ESI or the RSI registers (depending on the address-size attribute of the instruction, 16, 32 or 64, respectively). (The DS segment may be overridden with a segment override prefix.) The destination operand is an I/O port address (from 0 to 65,535) that is read from the DX register. The size of the I/O port being accessed (that is, the size of the source and destination operands) is determined by the opcode for an 8-bit I/O port or by the operand-size attribute of the instruction for a 16- or 32-bit I/O port.",
            "At the assembly-code level, two forms of this instruction are allowed: the “explicit-operands” form and the “no-operands” form. The explicit-operands form (specified with the OUTS mnemonic) allows the source and destination operands to be specified explicitly. Here, the source operand should be a symbol that indicates the size of the I/O port and the source address, and the destination operand must be DX. This explicit-operands form is provided to allow documentation; however, note that the documentation provided by this form can be misleading. That is, the source operand symbol must specify the correct type (size) of the operand (byte, word, or doubleword), but it does not have to specify the correct location. The location is always specified by the DS:(E)SI or RSI registers, which must be loaded correctly before the OUTS instruction is executed.",
            "The no-operands form provides “short forms” of the byte, word, and doubleword versions of the OUTS instructions. Here also DS:(E)SI is assumed to be the source operand and DX is assumed to be the destination operand. The size of the I/O port is specified with the choice of mnemonic: OUTSB (byte), OUTSW (word), or OUTSD (doubleword).",
            "After the byte, word, or doubleword is transferred from the memory location to the I/O port, the SI/ESI/RSI register is incremented or decremented automatically according to the setting of the DF flag in the EFLAGS register. (If the DF flag is 0, the (E)SI register is incremented; if the DF flag is 1, the SI/ESI/RSI register is decremented.) The SI/ESI/RSI register is incremented or decremented by 1 for byte operations, by 2 for word operations, and by 4 for doubleword operations.",
            "The OUTS, OUTSB, OUTSW, and OUTSD instructions can be preceded by the REP prefix for block input of ECX bytes, words, or doublewords. See “REP/REPE/REPZ /REPNE/REPNZ—Repeat String Operation Prefix” in this chapter for a description of the REP prefix. This instruction is only useful for accessing I/O ports located in the processor’s I/O address space. See Chapter 18, “Input/Output,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information on accessing I/O ports in the I/O address space.",
            "In 64-bit mode, the default operand size is 32 bits; operand size is not promoted by the use of REX.W. In 64-bit mode, the default address size is 64 bits, and 64-bit address is specified using RSI by default. 32-bit address using ESI is support using the prefix 67H, but 16-bit address is not supported in 64-bit mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/OUTS:OUTSB:OUTSW:OUTSD.html"
        ]
    },
    "vcvtneps2bf16": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "fldenv": {
        "detail": [
            "Load x87 FPU Environment"
        ],
        "documentation": [
            "Loads the complete x87 FPU operating environment from memory into the FPU registers. The source operand specifies the first byte of the operating-environment data in memory. This data is typically written to the specified memory location by a FSTENV or FNSTENV instruction.",
            "The FPU operating environment consists of the FPU control word, status word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, show the layout in memory of the loaded environment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute (16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.",
            "The FLDENV instruction should be executed in the same operating mode as the corresponding FSTENV/FNSTENV instruction.",
            "If one or more unmasked exception flags are set in the new FPU status word, a floating-point exception will be generated upon execution of the next floating-point instruction (except for the no-wait floating-point instructions, see the section titled “Software Exception Handling” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). To avoid generating exceptions when loading a new environment, clear all the exception flags in the FPU status word that is being loaded.",
            "If a page or limit fault occurs during the execution of this instruction, the state of the x87 FPU registers as seen by the fault handler may be different than the state being loaded from memory. In such situations, the fault handler should ignore the status of the x87 FPU registers, handle the fault, and return. The FLDENV instruction will then complete the loading of the x87 FPU registers with no resulting context inconsistency.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "mem.wdq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FLDENV.html"
        ]
    },
    "vmxon": {
        "detail": [
            "Enter VMX Operation"
        ],
        "documentation": [
            "Puts the logical processor in VMX operation with no current VMCS, blocks INIT signals, disables A20M, and clears any address-range monitoring established by the MONITOR instruction.10",
            "The operand of this instruction is a 4KB-aligned physical address (the VMXON pointer) that references the VMXON region, which the logical processor may use to support VMX operation. This operand is always 64 bits and is always in memory.",
            "Flags Affected:",
            "See the operation section and Section 30.2."
        ],
        "operands": [
            "mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VMXON.html"
        ]
    },
    "cmovnle": {
        "detail": [
            "Conditional Move"
        ],
        "documentation": [
            "The CMOVcc instructions check the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and perform a move operation if the flags are in a specified state (or condition). A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, a move is not performed and execution continues with the instruction following the CMOVcc instruction.",
            "These instructions can move 16-bit, 32-bit or 64-bit values from memory to a general-purpose register or from one general-purpose register to another. Conditional moves of 8-bit register operands are not supported.",
            "The condition for each CMOVcc mnemonic is given in the description column of the above table. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the CMOVA (conditional move if above) instruction and the CMOVNBE (conditional move if not below or equal) instruction are alternate mnemonics for the opcode 0F 47H.",
            "The CMOVcc instructions were introduced in P6 family processors; however, these instructions may not be supported by all IA-32 processors. Software can determine if the CMOVcc instructions are supported by checking the processor’s feature information with the CPUID instruction (see “CPUID—CPU Identification” in this chapter).",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/CMOVcc.html"
        ]
    },
    "shld": {
        "detail": [
            "Double Precision Shift Left"
        ],
        "documentation": [
            "The SHLD instruction is used for multi-precision shifts of 64 bits or more.",
            "The instruction shifts the first operand (destination operand) to the left the number of bits specified by the third operand (count operand). The second operand (source operand) provides bits to shift in from the right (starting with bit 0 of the destination operand).",
            "The destination operand can be a register or a memory location; the source operand is a register. The count operand is an unsigned integer that can be stored in an immediate byte or in the CL register. If the count operand is CL, the shift count is the logical AND of CL and a count mask. In non-64-bit modes and default 64-bit mode; only bits 0 through 4 of the count are used. This masks the count to a value between 0 and 31. If a count is greater than the operand size, the result is undefined.",
            "If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, flags are not affected.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits (upgrading the count mask to 6 bits). See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand and the SF, ZF, and PF flags are set according to the value of the result. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. For shifts greater than 1 bit, the OF flag is undefined. If a shift occurs, the AF flag is undefined. If the count operand is 0, the flags are not affected. If the count is greater than the operand size, the flags are undefined."
        ],
        "operands": [
            "reg.w, reg.w, imm.b",
            "reg.w, reg.w, imm.b",
            "mem.w, reg.w, imm.b",
            "reg.w, reg.w, reg",
            "mem.w, reg.w, reg",
            "mem.w, reg.w, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SHLD.html"
        ]
    },
    "movlpd": {
        "detail": [
            "Move Low Packed Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "This instruction cannot be used for register to register or memory to memory moves.",
            "128-bit Legacy SSE load:",
            "Moves a double-precision floating-point value from the source 64-bit memory operand and stores it in the low 64-bits of the destination XMM register. The upper 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.",
            "VEX.128 & EVEX encoded load:",
            "Loads a double-precision floating-point value from the source 64-bit memory operand (third operand), merges it with the upper 64-bits of the first source XMM register (second operand), and stores it in the low 128-bits of the destination XMM register (first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "128-bit store:",
            "Stores a double-precision floating-point value from the low 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).",
            "Note: VMOVLPD (store) (VEX.128.66.0F 13 /r) is legal and has the same behavior as the existing 66 0F 13 store. For VMOVLPD (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.",
            "If VMOVLPD is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.q, mem.q",
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVLPD.html"
        ]
    },
    "movnti": {
        "detail": [
            "Store Doubleword Using Non-Temporal Hint"
        ],
        "documentation": [
            "Moves the doubleword integer in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is a general-purpose register. The destination operand is a 32-bit memory location.",
            "The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTI instructions if multiple processors might use different memory types to read/write the destination memory locations.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits."
        ],
        "operands": [
            "mem.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVNTI.html"
        ]
    },
    "vpermilpd": {
        "detail": [
            "Permute In-Lane of Pairs of Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "(variable control version)",
            "Permute pairs of double-precision floating-point values in the first source operand (second operand), each using a 1-bit control field residing in the corresponding quadword element of the second source operand (third operand). Permuted results are stored in the destination operand (first operand).",
            "The control bits are located at bit 0 of each quadword element (see Figure 5-24). Each control determines which of the source element in an input pair is selected for the destination element. Each pair of source elements must lie in the same 128-bit region as the destination.",
            "EVEX version: The second source operand (third operand) is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. Permuted results are written to the destination under the writemask."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMILPD.html"
        ]
    },
    "loope": {
        "detail": [
            "Loop According to ECX Counter"
        ],
        "documentation": [
            "Performs a loop operation using the RCX, ECX or CX register as a counter (depending on whether address size is 64 bits, 32 bits, or 16 bits). Note that the LOOP instruction ignores REX.W; but 64-bit address size can be over-ridden using a 67H prefix.",
            "Each time the LOOP instruction is executed, the count register is decremented, then checked for 0. If the count is 0, the loop is terminated and program execution continues with the instruction following the LOOP instruction. If the count is not zero, a near jump is performed to the destination (target) operand, which is presumably the instruction at the beginning of the loop.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the IP/EIP/RIP register). This offset is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit immediate value, which is added to the instruction pointer. Offsets of –128 to +127 are allowed with this instruction.",
            "Some forms of the loop instruction (LOOPcc) also accept the ZF flag as a condition for terminating the loop before the count reaches zero. With these forms of the instruction, a condition code (cc) is associated with each instruction to indicate the condition being tested for. Here, the LOOPcc instruction itself does not affect the state of the ZF flag; the ZF flag is changed by other instructions in the loop.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/LOOP:LOOPcc.html"
        ]
    },
    "movntq": {
        "detail": [
            "Store of Quadword Using Non-Temporal Hint"
        ],
        "documentation": [
            "Moves the quadword in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to minimize cache pollution during the write to memory. The source operand is an MMX technology register, which is assumed to contain packed integer data (packed bytes, words, or doublewords). The destination operand is a 64-bit memory location.",
            "The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTQ instructions if multiple processors might use different memory types to read/write the destination memory locations.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVNTQ.html"
        ]
    },
    "movlps": {
        "detail": [
            "Move Low Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "This instruction cannot be used for register to register or memory to memory moves.",
            "128-bit Legacy SSE load:",
            "Moves two packed single-precision floating-point values from the source 64-bit memory operand and stores them in the low 64-bits of the destination XMM register. The upper 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.",
            "VEX.128 & EVEX encoded load:",
            "Loads two packed single-precision floating-point values from the source 64-bit memory operand (the third operand), merges them with the upper 64-bits of the first source operand (the second operand), and stores them in the low 128-bits of the destination register (the first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "128-bit store:",
            "Loads two packed single-precision floating-point values from the low 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).",
            "Note: VMOVLPS (store) (VEX.128.0F 13 /r) is legal and has the same behavior as the existing 0F 13 store. For VMOVLPS (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.",
            "If VMOVLPS is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.q, mem.q",
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVLPS.html"
        ]
    },
    "vpsubb": {
        "detail": [
            "Subtract Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.",
            "The (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.",
            "The (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.",
            "The (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.",
            "Note that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded VPSUBD: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "EVEX encoded VPSUBB/W: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html"
        ]
    },
    "vcvtuqq2pd": {
        "detail": [
            "Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Converts packed unsigned quadword integers in the source operand (second operand) to packed double-precision floating-point values in the destination operand (first operand).",
            "The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTUQQ2PD.html"
        ]
    },
    "vpsubd": {
        "detail": [
            "Subtract Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.",
            "The (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.",
            "The (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.",
            "The (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.",
            "Note that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded VPSUBD: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "EVEX encoded VPSUBB/W: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html"
        ]
    },
    "shlx": {
        "detail": [
            "Shift Without Affecting Flags"
        ],
        "documentation": [
            "Shifts the bits of the first source operand (the second operand) to the left or right by a COUNT value specified in the second source operand (the third operand). The result is written to the destination operand (the first operand).",
            "The shift arithmetic right (SARX) and shift logical right (SHRX) instructions shift the bits of the destination operand to the right (toward less significant bit locations), SARX keeps and propagates the most significant bit (sign bit) while shifting.",
            "The logical shift left (SHLX) shifts the bits of the destination operand to the left (toward more significant bit locations).",
            "This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
            "If the value specified in the first source operand exceeds OperandSize -1, the COUNT value is masked.",
            "SARX,SHRX, and SHLX instructions do not update flags.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.d, reg.d, reg.d",
            "reg.d, mem.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/SARX:SHLX:SHRX.html"
        ]
    },
    "vpermilps": {
        "detail": [
            "Permute In-Lane of Quadruples of Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "(variable control version)",
            "Permute quadruples of single-precision floating-point values in the first source operand (second operand), each quadruplet using a 2-bit control field in the corresponding dword element of the second source operand. Permuted results are stored in the destination operand (first operand).",
            "The 2-bit control fields are located at the low two bits of each dword element (see Figure 5-26). Each control determines which of the source element in an input quadruple is selected for the destination element. Each quadruple of source elements must lie in the same 128-bit region as the destination.",
            "EVEX version: The second source operand (third operand) is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. Permuted results are written to the destination under the writemask."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMILPS.html"
        ]
    },
    "jmp": {
        "detail": [
            "Jump"
        ],
        "documentation": [
            "Transfers program control to a different point in the instruction stream without recording return information. The destination (target) operand specifies the address of the instruction being jumped to. This operand can be an immediate value, a general-purpose register, or a memory location.",
            "This instruction can be used to execute four different types of jumps:",
            "Flags Affected:",
            "All flags are affected if a task switch occurs; no flags are affected if a task switch does not occur."
        ],
        "operands": [
            "reg.q, reg.q",
            "mem.q, reg.q",
            "relbr.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/JMP.html"
        ]
    },
    "divpd": {
        "detail": [
            "Divide Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD divide of the double-precision floating-point values in the first source operand by the floating-point values in the second source operand (the third operand). Results are written to the destination operand (the first operand).",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand (the second operand) is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding destination are zeroed.",
            "VEX.128 encoded version: The first source operand (the second operand) is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding destination are zeroed.",
            "128-bit Legacy SSE version: The second source operand (the second operand) can be an XMM register or an 128-bit memory location. The destination is the same as the first source operand. The upper bits (MAXVL-1:128) of the corresponding destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/DIVPD.html"
        ]
    },
    "rdtsc": {
        "detail": [
            "Read Time-Stamp Counter"
        ],
        "documentation": [
            "Reads the current value of the processor’s time-stamp counter (a 64-bit MSR) into the EDX:EAX registers. The EDX register is loaded with the high-order 32 bits of the MSR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.)",
            "The processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever the processor is reset. See “Time Stamp Counter” in Chapter 17 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B, for specific details of the time stamp counter behavior.",
            "The time stamp disable (TSD) flag in register CR4 restricts the use of the RDTSC instruction as follows. When the flag is clear, the RDTSC instruction can be executed at any privilege level; when the flag is set, the instruction can only be executed at privilege level 0.",
            "The time-stamp counter can also be read with the RDMSR instruction, when executing at privilege level 0.",
            "The RDTSC instruction is not a serializing instruction. It does not necessarily wait until all previous instructions have been executed before reading the counter. Similarly, subsequent instructions may begin execution before the read operation is performed. The following items may guide software seeking to order executions of RDTSC:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/RDTSC.html"
        ]
    },
    "divps": {
        "detail": [
            "Divide Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD divide of the four, eight or sixteen packed single-precision floating-point values in the first source operand (the second operand) by the four, eight or sixteen packed single-precision floating-point values in the second source operand (the third operand). Results are written to the destination operand (the first operand).",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/DIVPS.html"
        ]
    },
    "vpsubq": {
        "detail": [
            "Subtract Packed Quadword Integers"
        ],
        "documentation": [
            "Subtracts the second operand (source operand) from the first operand (destination operand) and stores the result in the destination operand. When packed quadword operands are used, a SIMD subtract is performed. When a quadword result is too large to be represented in 64 bits (overflow), the result is wrapped around and the low 64 bits are written to the destination element (that is, the carry is ignored).",
            "Note that the (V)PSUBQ instruction can operate on either unsigned or signed (two’s complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values upon which it operates.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The source operand can be a quadword integer stored in an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded VPSUBQ: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBQ.html"
        ]
    },
    "vcvtuqq2ps": {
        "detail": [
            "Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Converts packed unsigned quadword integers in the source operand (second operand) to single-precision floating-point values in the destination operand (first operand).",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is a YMM/XMM/XMM (low 64 bits) register conditionally updated with writemask k1.",
            "Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTUQQ2PS.html"
        ]
    },
    "maxpd": {
        "detail": [
            "Maximum of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed double-precision floating-point values in the first source operand and the second source operand and returns the maximum value for each pair of values to the destination operand.",
            "If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MAXPD can be emulated using a sequence of instructions, such as a comparison followed by AND, ANDN and OR.",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MAXPD.html"
        ]
    },
    "vpsubw": {
        "detail": [
            "Subtract Packed Integers"
        ],
        "documentation": [
            "Performs a SIMD subtract of the packed integers of the source operand (second operand) from the packed integers of the destination operand (first operand), and stores the packed integer results in the destination operand. See Figure 9-4 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD operation. Overflow is handled with wraparound, as described in the following paragraphs.",
            "The (V)PSUBB instruction subtracts packed byte integers. When an individual result is too large or too small to be represented in a byte, the result is wrapped around and the low 8 bits are written to the destination element.",
            "The (V)PSUBW instruction subtracts packed word integers. When an individual result is too large or too small to be represented in a word, the result is wrapped around and the low 16 bits are written to the destination element.",
            "The (V)PSUBD instruction subtracts packed doubleword integers. When an individual result is too large or too small to be represented in a doubleword, the result is wrapped around and the low 32 bits are written to the destination element.",
            "Note that the (V)PSUBB, (V)PSUBW, and (V)PSUBD instructions can operate on either unsigned or signed (two's complement notation) packed integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of values upon which it operates.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The destination operand must be an MMX technology register and the source operand can be either an MMX technology register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded versions: The second source operand is an YMM register or an 256-bit memory location. The first source operand and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX encoded VPSUBD: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "EVEX encoded VPSUBB/W: The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The first source operand and destination operands are ZMM/YMM/XMM registers. The destination is conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html"
        ]
    },
    "fsin": {
        "detail": [
            "Sine"
        ],
        "documentation": [
            "Computes an approximation of the sine of the source operand in register ST(0) and stores the result in ST(0). The source operand must be given in radians and must be within the range −263 to +263. The following table shows the results obtained when taking the sine of various classes of numbers, assuming that underflow does not occur."
        ],
        "operands": [
            "reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FSIN.html"
        ]
    },
    "vfnmsub132pd": {
        "detail": [
            "Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMSUB132PD: Multiplies the two, four or eight packed double-precision floating-point values from the first source operand to the two, four or eight packed double-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision floating-point values in the second source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFNMSUB213PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source operand to the two, four or eight packed double-precision floating-point values in the first source operand. From negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision floating-point values in the third source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "VFNMSUB231PD: Multiplies the two, four or eight packed double-precision floating-point values from the second source to the two, four or eight packed double-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the two, four or eight packed double-precision floating-point values in the first source operand, performs rounding and stores the resulting two, four or eight packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMSUB132PD:VFNMSUB213PD:VFNMSUB231PD.html"
        ]
    },
    "vfmaddsd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.q, reg.q, mem.q",
            "reg.x, reg.q, reg.q, reg.q",
            "reg.x, reg.q, mem.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "repe xcryptecb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.b, reg, reg.d, reg, mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vbroadcasti128": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "documentation": [
            "VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).",
            "VEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4 load floating-point values as tuples from the source operand (the second operand) in memory or register and broadcast to all elements of the destination operand (the first operand). The destination operand is a YMM/ZMM register updated according to the writemask k1. The source operand is either a register or 64-bit/128-bit/256-bit memory location.",
            "VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as 256-bit and 512-bit wide versions and up. VBROADCASTSS is supported in 128-bit, 256-bit and 512-bit wide versions. F32x8 and F64x4 are only supported as 512-bit wide versions.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32-bit granularity. VBROADCASTF64X2 and VBROADCASTF64X4 have 64-bit granularity.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.y, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBROADCAST.html"
        ]
    },
    "maxps": {
        "detail": [
            "Maximum of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed single-precision floating-point values in the first source operand and the second source operand and returns the maximum value for each pair of values to the destination operand.",
            "If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MAXPS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MAXPS.html"
        ]
    },
    "wbinvd": {
        "detail": [
            "Write Back and Invalidate Cache"
        ],
        "documentation": [
            "Writes back all modified cache lines in the processor’s internal cache to main memory and invalidates (flushes) the internal caches. The instruction then issues a special-function bus cycle that directs external caches to also write back modified data and another bus cycle to indicate that the external caches should be invalidated.",
            "After executing this instruction, the processor does not wait for the external caches to complete their write-back and flushing operations before proceeding with instruction execution. It is the responsibility of hardware to respond to the cache write-back and flush signals. The amount of time or cycles for WBINVD to complete will vary due to size and other factors of different cache hierarchies. As a consequence, the use of the WBINVD instruction can have an impact on logical processor interrupt/event response time. Additional information of WBINVD behavior in a cache hierarchy with hierarchical sharing topology can be found in Chapter 2 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.",
            "The WBINVD instruction is a privileged instruction. When the processor is running in protected mode, the CPL of a program or procedure must be 0 to execute this instruction. This instruction is also a serializing instruction (see “Serializing Instructions” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A).",
            "In situations where cache coherency with main memory is not a concern, software can use the INVD instruction.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/WBINVD.html"
        ]
    },
    "punpcklqdq": {
        "detail": [
            "Unpack Low Data"
        ],
        "documentation": [
            "Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-22 shows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html"
        ]
    },
    "vfnmsub132ps": {
        "detail": [
            "Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-precision floating-point values in the second source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFNMSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the four, eight or sixteen packed single-precision floating-point values in the first source operand. From negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-precision floating-point values in the third source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "VFNMSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source to the four, eight or sixteen packed single-precision floating-point values in the third source operand. From negated infinite precision intermediate results, subtracts the four, eight or sixteen packed single-precision floating-point values in the first source operand, performs rounding and stores the resulting four, eight or sixteen packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMSUB132PS:VFNMSUB213PS:VFNMSUB231PS.html"
        ]
    },
    "lock and": {
        "detail": [
            "Logical AND"
        ],
        "documentation": [
            "Performs a bitwise AND operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is set to 1 if both corresponding bits of the first and second operands are 1; otherwise, it is set to 0.",
            "This instruction can be used with a LOCK prefix to allow the it to be executed atomically.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined."
        ],
        "operands": [
            "mem.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/AND.html"
        ]
    },
    "vfmaddss": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.d, reg.d, mem.d",
            "reg.x, reg.d, reg.d, reg.d",
            "reg.x, reg.d, mem.d, reg.d"
        ],
        "url": [
            "https://"
        ]
    },
    "fucom": {
        "detail": [
            "Unordered Compare Floating Point Values"
        ],
        "documentation": [
            "Performs an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below). If no operand is specified, the contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that –0.0 is equal to +0.0."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FUCOM:FUCOMP:FUCOMPP.html"
        ]
    },
    "vpabsb": {
        "detail": [
            "Packed Absolute Value"
        ],
        "documentation": [
            "PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and stores the UNSIGNED results in the destination operand (the first operand). PABSB operates on signed bytes, PABSW operates on signed 16-bit words, and PABSD operates on signed 32-bit integers.",
            "EVEX encoded VPABSD/Q: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "EVEX encoded VPABSB/W: The source operand is a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded versions: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding register destination are zeroed.",
            "VEX.128 encoded versions: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand can be an XMM register or an 128-bit memory location. The destination is an XMM register. The upper bits (VL_MAX-1:128) of the corresponding register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PABSB:PABSW:PABSD:PABSQ.html"
        ]
    },
    "vpabsd": {
        "detail": [
            "Packed Absolute Value"
        ],
        "documentation": [
            "PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and stores the UNSIGNED results in the destination operand (the first operand). PABSB operates on signed bytes, PABSW operates on signed 16-bit words, and PABSD operates on signed 32-bit integers.",
            "EVEX encoded VPABSD/Q: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "EVEX encoded VPABSB/W: The source operand is a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded versions: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding register destination are zeroed.",
            "VEX.128 encoded versions: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand can be an XMM register or an 128-bit memory location. The destination is an XMM register. The upper bits (VL_MAX-1:128) of the corresponding register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/PABSB:PABSW:PABSD:PABSQ.html"
        ]
    },
    "pmovzxwd": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "documentation": [
            "Legacy, VEX and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask.The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVZX.html"
        ]
    },
    "jnb": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "vpabsq": {
        "detail": [
            "Packed Absolute Value"
        ],
        "documentation": [
            "PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and stores the UNSIGNED results in the destination operand (the first operand). PABSB operates on signed bytes, PABSW operates on signed 16-bit words, and PABSD operates on signed 32-bit integers.",
            "EVEX encoded VPABSD/Q: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "EVEX encoded VPABSB/W: The source operand is a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded versions: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding register destination are zeroed.",
            "VEX.128 encoded versions: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand can be an XMM register or an 128-bit memory location. The destination is an XMM register. The upper bits (VL_MAX-1:128) of the corresponding register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/PABSB:PABSW:PABSD:PABSQ.html"
        ]
    },
    "vpunpcklbw": {
        "detail": [
            "Unpack Low Data"
        ],
        "documentation": [
            "Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-22 shows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html"
        ]
    },
    "pmovzxwq": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "documentation": [
            "Legacy, VEX and EVEX encoded versions: Packed byte, word, or dword integers starting from the low bytes of the source operand (second operand) are zero extended to word, dword, or quadword integers and stored in packed signed bytes the destination operand.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: Packed dword integers starting from the low bytes of the source operand (second operand) are zero extended to quadword integers and stored to the destination operand under the writemask.The destination register is XMM, YMM or ZMM Register.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.d",
            "reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMOVZX.html"
        ]
    },
    "jnl": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "vpabsw": {
        "detail": [
            "Packed Absolute Value"
        ],
        "documentation": [
            "PABSB/W/D computes the absolute value of each data element of the source operand (the second operand) and stores the UNSIGNED results in the destination operand (the first operand). PABSB operates on signed bytes, PABSW operates on signed 16-bit words, and PABSD operates on signed 32-bit integers.",
            "EVEX encoded VPABSD/Q: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "EVEX encoded VPABSB/W: The source operand is a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask.",
            "VEX.256 encoded versions: The source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding register destination are zeroed.",
            "VEX.128 encoded versions: The source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand can be an XMM register or an 128-bit memory location. The destination is an XMM register. The upper bits (VL_MAX-1:128) of the corresponding register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PABSB:PABSW:PABSD:PABSQ.html"
        ]
    },
    "jno": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "jnp": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "jns": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "xrstor64": {
        "detail": [
            "Restore Processor Extended States"
        ],
        "documentation": [
            "Performs a full or partial restore of processor state components from the XSAVE area located at the memory address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.",
            "The format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Section 13.8, “Operation of XRSTOR,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XRSTOR instruction. The following items provide a highlevel outline:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.z[4096], reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XRSTOR.html"
        ]
    },
    "jnz": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "documentation": [
            "Checks the state of one or more of the status flags in the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the specified state (condition), performs a jump to the target instruction specified by the destination operand. A condition code (cc) is associated with each instruction to indicate the condition being tested for. If the condition is not satisfied, the jump is not performed and execution continues with the instruction following the Jcc instruction.",
            "The target instruction is specified with a relative offset (a signed offset relative to the current value of the instruction pointer in the EIP register). A relative offset (rel8, rel16, or rel32) is generally specified as a label in assembly code, but at the machine code level, it is encoded as a signed, 8-bit or 32-bit immediate value, which is added to the instruction pointer. Instruction coding is most efficient for offsets of –128 to +127. If the operand-size attribute is 16, the upper two bytes of the EIP register are cleared, resulting in a maximum instruction pointer size of 16 bits.",
            "The conditions for each Jcc mnemonic are given in the “Description” column of the table on the preceding page. The terms “less” and “greater” are used for comparisons of signed integers and the terms “above” and “below” are used for unsigned integers.",
            "Because a particular state of the status flags can sometimes be interpreted in two ways, two mnemonics are defined for some opcodes. For example, the JA (jump if above) instruction and the JNBE (jump if not below or equal) instruction are alternate mnemonics for the opcode 77H.",
            "The Jcc instruction does not support far jumps (jumps to other code segments). When the target for the conditional jump is in a different segment, use the opposite condition from the condition being tested for the Jcc instruction, and then access the target with an unconditional far jump (JMP instruction) to the other segment. For example, the following conditional far jump is illegal:",
            "JZ FARLABEL;",
            "To accomplish this far jump, use the following two instructions:",
            "JNZ BEYOND;",
            "JMP FARLABEL;",
            "BEYOND:",
            "The JRCXZ, JECXZ and JCXZ instructions differ from other Jcc instructions because they do not check status flags. Instead, they check RCX, ECX or CX for 0. The register checked is determined by the address-size attribute. These instructions are useful when used at the beginning of a loop that terminates with a conditional loop instruction (such as LOOPNE). They can be used to prevent an instruction sequence from entering a loop when RCX, ECX or CX is 0. This would cause the loop to execute 264, 232 or 64K times (not zero times).",
            "All conditional jumps are converted to code fetches of one or two cache lines, regardless of jump address or cache-ability.",
            "In 64-bit mode, operand size is fixed at 64 bits. JMP Short is RIP = RIP + 8-bit offset sign extended to 64 bits. JMP Near is RIP = RIP + 32-bit offset sign extended to 64 bits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/Jcc.html"
        ]
    },
    "lock or": {
        "detail": [
            "Logical Inclusive OR"
        ],
        "documentation": [
            "Performs a bitwise inclusive OR operation between the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result of the OR instruction is set to 0 if both corresponding bits of the first and second operands are 0; otherwise, each bit is set to 1.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined."
        ],
        "operands": [
            "mem.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/OR.html"
        ]
    },
    "vfnmsub231sd": {
        "detail": [
            "Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMSUB132SD: Multiplies the low packed double-precision floating-point value from the first source operand to the low packed double-precision floating-point value in the third source operand. From negated infinite precision intermediate result, subtracts the low double-precision floating-point value in the second source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFNMSUB213SD: Multiplies the low packed double-precision floating-point value from the second source operand to the low packed double-precision floating-point value in the first source operand. From negated infinite precision intermediate result, subtracts the low double-precision floating-point value in the third source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFNMSUB231SD: Multiplies the low packed double-precision floating-point value from the second source to the low packed double-precision floating-point value in the third source operand. From negated infinite precision intermediate result, subtracts the low double-precision floating-point value in the first source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMSUB132SD:VFNMSUB213SD:VFNMSUB231SD.html"
        ]
    },
    "cvttsd2si": {
        "detail": [
            "Convert with Truncation Scalar Double-Precision Floating-Point Value to Signed Integer"
        ],
        "documentation": [
            "Converts a double-precision floating-point value in the source operand (the second operand) to a signed double-word integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.",
            "If a converted result exceeds the range limits of signed doubleword integer (in non-64-bit modes or 64-bit mode with REX.W/VEX.W/EVEX.W=0), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.",
            "If a converted result exceeds the range limits of signed quadword integer (in 64-bit mode and REX.W/VEX.W/EVEX.W = 1), the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000_00000000H) is returned.",
            "Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to 64-bit operation. See the summary chart at the beginning of this section for encoding data and limits.",
            "VEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCVTTSD2SI is encoded with VEX.L=0. Encoding VCVTTSD2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.q",
            "reg.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTTSD2SI.html"
        ]
    },
    "vaddsd": {
        "detail": [
            "Add Scalar Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Adds the low double-precision floating-point values from the second source operand and the first source operand and stores the double-precision floating-point result in the destination operand.",
            "The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.",
            "EVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX version: The low quadword element of the destination is updated according to the writemask.",
            "Software should ensure VADDSD is encoded with VEX.L=0. Encoding VADDSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADDSD.html"
        ]
    },
    "vfnmsub231ss": {
        "detail": [
            "Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand. From negated infinite precision intermediate result, the low single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFNMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand. From negated infinite precision intermediate result, the low single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFNMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low packed single-precision floating-point value in the third source operand. From negated infinite precision intermediate result, the low single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMSUB132SS:VFNMSUB213SS:VFNMSUB231SS.html"
        ]
    },
    "incsspd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vpcmpgtb": {
        "detail": [
            "Compare Packed Signed Integers for Greater Than"
        ],
        "documentation": [
            "Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding date element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.",
            "The PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPGTD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "EVEX encoded VPCMPGTB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPGTB:PCMPGTW:PCMPGTD.html"
        ]
    },
    "kunpckbw": {
        "detail": [
            "Unpack for Mask Registers"
        ],
        "documentation": [
            "Unpacks the lower 8/16/32 bits of the second and third operands (source operands) into the low part of the first operand (destination operand), starting from the low bytes. The result is zero-extended in the destination.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KUNPCKBW:KUNPCKWD:KUNPCKDQ.html"
        ]
    },
    "vaddss": {
        "detail": [
            "Add Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Adds the low single-precision floating-point values from the second source operand and the first source operand, and stores the double-precision floating-point result in the destination operand.",
            "The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAXVL-1:32) of the corresponding the destination register remain unchanged.",
            "EVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX version: The low doubleword element of the destination is updated according to the writemask.",
            "Software should ensure VADDSS is encoded with VEX.L=0. Encoding VADDSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADDSS.html"
        ]
    },
    "vpcmpgtd": {
        "detail": [
            "Compare Packed Signed Integers for Greater Than"
        ],
        "documentation": [
            "Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding date element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.",
            "The PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPGTD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "EVEX encoded VPCMPGTB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPGTB:PCMPGTW:PCMPGTD.html"
        ]
    },
    "umwait": {
        "detail": [
            "User Level Monitor Wait"
        ],
        "documentation": [
            "UMWAIT instructs the processor to enter an implementation-dependent optimized state while monitoring a range of addresses. The optimized state may be either a light-weight power/performance optimized state or an improved power/performance optimized state. The selection between the two states is governed by the explicit input register bit[0] source operand.",
            "UMWAIT is available when CPUID.7.0:ECX.WAITPKG[bit 5] is enumerated as 1. UMWAIT may be executed at any privilege level. This instruction’s operation is the same in non-64-bit modes and in 64-bit mode.",
            "The input register contains information such as the preferred optimized state the processor should enter as described in the following table. Bits other than bit 0 are reserved and will result in #GP if nonzero."
        ],
        "operands": [
            "reg.d, reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/UMWAIT.html"
        ]
    },
    "vextractps": {
        "detail": [
            "Extract Packed Floating-Point Values"
        ],
        "documentation": [
            "Extracts a single-precision floating-point value from the source operand (second operand) at the 32-bit offset specified from imm8. Immediate bits higher than the most significant offset for the vector length are ignored.",
            "The extracted single-precision floating-point value is stored in the low 32-bits of the destination operand",
            "In 64-bit mode, destination register operand has default operand size of 64 bits. The upper 32-bits of the register are filled with zero. REX.W is ignored.",
            "VEX.128 and EVEX encoded version: When VEX.W1 or EVEX.W1 form is used in 64-bit mode with a general purpose register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits.",
            "VEX.vvvv/EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "128-bit Legacy SSE version: When a REX.W prefix is used in 64-bit mode with a general purpose register (GPR) as a destination operand, the packed single quantity is zero extended to 64 bits.",
            "The source register is an XMM register. Imm8[1:0] determine the starting DWORD offset from which to extract the 32-bit floating-point value.",
            "If VEXTRACTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.d, reg.x, imm.b",
            "mem.d, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/EXTRACTPS.html"
        ]
    },
    "gf2p8affineinvqb": {
        "detail": [
            "Galois Field Affine Transformation Inverse"
        ],
        "documentation": [
            "The AFFINEINVB instruction computes an affine transformation in the Galois Field 28. For this instruction, an affine transformation is defined by A * inv(x) + b where “A” is an 8 by 8 bit matrix, and “x” and “b” are 8-bit vectors. The inverse of the bytes in x is defined with respect to the reduction polynomial x8 + x4 + x3 + x + 1.",
            "One SIMD register (operand 1) holds “x” as either 16, 32 or 64 8-bit vectors. A second SIMD (operand 2) register or memory operand contains 2, 4, or 8 “A” values, which are operated upon by the correspondingly aligned 8 “x” values in the first register. The “b” vector is constant for all calculations and contained in the immediate byte.",
            "The SSE encoded forms of the instruction require 16B alignment on their memory operations.",
            "The inverse of each byte is given by the following table. The upper nibble is on the vertical axis and the lower nibble is on the horizontal axis. For example, the inverse of 0x95 is 0x8A."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/GF2P8AFFINEINVQB.html"
        ]
    },
    "prefetcht0": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.z"
        ],
        "url": [
            "https://"
        ]
    },
    "vgatherqpd": {
        "detail": [
            "Gather Packed Single, Packed Double with Signed Qword Indices"
        ],
        "documentation": [
            "A set of 8 single-precision/double-precision faulting-point memory locations pointed by base address BASE_ADDR and index vector V_INDEX with scale SCALE are gathered. The result is written into vector a register. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be loaded if their corresponding mask bit is one. If an element’s mask bit is not set, the corresponding element of the destination register is left unchanged. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register (k1) are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "If the data element size is less than the index element size, the higher part of the destination register and the mask register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may update these unused elements to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.",
            "Note that:"
        ],
        "operands": [
            "reg.z, reg.q, mem.q",
            "reg.y, mem.q, reg.y"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGATHERQPS:VGATHERQPD.html"
        ]
    },
    "incsspq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vrsqrt28pd": {
        "detail": [
            "Approximation to the Reciprocal Square Root of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error"
        ],
        "documentation": [
            "Computes the reciprocal square root of the float64 values in the source operand (the second operand) and store the results to the destination operand (the first operand). The approximate reciprocal is evaluated with less than 2^-28 of maximum relative error.",
            "If any source element is NaN, the quietized NaN source value is returned for that element. Negative (non-zero) source numbers, as well as -∞, return the canonical NaN and set the Invalid Flag (#I).",
            "A value of -0 must return -∞ and set the DivByZero flags (#Z). Negative numbers should return NaN and set the Invalid flag (#I). Note however that the instruction flush input denormals to zero of the same sign, so negative denormals return -∞ and set the DivByZero flag.",
            "The source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRSQRT28PD.html"
        ]
    },
    "prefetcht1": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.z"
        ],
        "url": [
            "https://"
        ]
    },
    "vpcmpgtq": {
        "detail": [
            "Compare Packed Data for Greater Than"
        ],
        "documentation": [
            "Performs an SIMD signed compare for the packed quadwords in the destination operand (first operand) and the source operand (second operand). If the data element in the first (destination) operand is greater than the corresponding element in the second (source) operand, the corresponding data element in the destination is set to all 1s; otherwise, it is set to 0s.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPGTD/Q: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPGTQ.html"
        ]
    },
    "mul": {
        "detail": [
            "Unsigned Multiply"
        ],
        "documentation": [
            "Performs an unsigned multiplication of the first operand (destination operand) and the second operand (source operand) and stores the result in the destination operand. The destination operand is an implied operand located in register AL, AX or EAX (depending on the size of the operand); the source operand is located in a general-purpose register or a memory location. The action of this instruction and the location of the result depends on the opcode and the operand size as shown in Table 4-9.",
            "The result is stored in register AX, register pair DX:AX, or register pair EDX:EAX (depending on the operand size), with the high-order bits of the product contained in register AH, DX, or EDX, respectively. If the high-order bits of the product are 0, the CF and OF flags are cleared; otherwise, the flags are set.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.",
            "See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF and CF flags are set to 0 if the upper half of the result is 0; otherwise, they are set to 1. The SF, ZF, AF, and PF flags are undefined."
        ],
        "operands": [
            "reg.b, reg, reg",
            "mem.b, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/MUL.html"
        ]
    },
    "lsl": {
        "detail": [
            "Load Segment Limit"
        ],
        "documentation": [
            "Loads the unscrambled segment limit from the segment descriptor specified with the second operand (source operand) into the first operand (destination operand) and sets the ZF flag in the EFLAGS register. The source operand (which can be a register or a memory location) contains the segment selector for the segment descriptor being accessed. The destination operand is a general-purpose register.",
            "The processor performs access checks as part of the loading process. Once loaded in the destination register, software can compare the segment limit with the offset of a pointer.",
            "The segment limit is a 20-bit value contained in bytes 0 and 1 and in the first 4 bits of byte 6 of the segment descriptor. If the descriptor has a byte granular segment limit (the granularity flag is set to 0), the destination operand is loaded with a byte granular value (byte limit). If the descriptor has a page granular segment limit (the granularity flag is set to 1), the LSL instruction will translate the page granular limit (page limit) into a byte limit before loading it into the destination operand. The translation is performed by shifting the 20-bit “raw” limit left 12 bits and filling the low-order 12 bits with 1s.",
            "When the operand size is 32 bits, the 32-bit byte limit is stored in the destination operand. When the operand size is 16 bits, a valid 32-bit limit is computed; however, the upper 16 bits are truncated and only the low-order 16 bits are loaded into the destination operand.",
            "This instruction performs the following checks before it loads the segment limit into the destination register:",
            "Flags Affected:",
            "The ZF flag is set to 1 if the segment limit is loaded successfully; otherwise, it is set to 0."
        ],
        "operands": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/LSL.html"
        ]
    },
    "phsubd": {
        "detail": [
            "Packed Horizontal Subtract"
        ],
        "documentation": [
            "(V)PHSUBW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands, and packs the signed 16-bit results to the destination operand (first operand). (V)PHSUBD performs horizontal subtraction on each adjacent pair of 32-bit signed integers by subtracting the most significant doubleword from the least significant doubleword of each pair, and packs the signed 32-bit result to the destination operand. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "In 64-bit mode, use the REX prefix to access additional registers.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.",
            "Note: VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PHSUBW:PHSUBD.html"
        ]
    },
    "pfrcpit1": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "pfrcpit2": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vpcmpgtw": {
        "detail": [
            "Compare Packed Signed Integers for Greater Than"
        ],
        "documentation": [
            "Performs an SIMD signed compare for the greater value of the packed byte, word, or doubleword integers in the destination operand (first operand) and the source operand (second operand). If a data element in the destination operand is greater than the corresponding date element in the source operand, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.",
            "The PCMPGTB instruction compares the corresponding signed byte integers in the destination and source operands; the PCMPGTW instruction compares the corresponding signed word integers in the destination and source operands; and the PCMPGTD instruction compares the corresponding signed doubleword integers in the destination and source operands.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source operand and destination operand are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPGTD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "EVEX encoded VPCMPGTB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPGTB:PCMPGTW:PCMPGTD.html"
        ]
    },
    "vmload": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "lss": {
        "detail": [
            "Load Far Pointer"
        ],
        "documentation": [
            "Loads a far pointer (segment selector and offset) from the second operand (source operand) into a segment register and the first operand (destination operand). The source operand specifies a 48-bit or a 32-bit pointer in memory depending on the current setting of the operand-size attribute (32 bits or 16 bits, respectively). The instruction opcode and the destination operand specify a segment register/general-purpose register pair. The 16-bit segment selector from the source operand is loaded into the segment register specified with the opcode (DS, SS, ES, FS, or GS). The 32-bit or 16-bit offset is loaded into the register specified with the destination operand.",
            "If one of these instructions is executed in protected mode, additional information from the segment descriptor pointed to by the segment selector in the source operand is loaded in the hidden part of the selected segment register.",
            "Also in protected mode, a NULL selector (values 0000 through 0003) can be loaded into DS, ES, FS, or GS registers without causing a protection exception. (Any subsequent reference to a segment whose corresponding segment register is loaded with a NULL selector, causes a general-protection exception (#GP) and no memory reference to the segment occurs.)",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.W promotes operation to specify a source operand referencing an 80-bit pointer (16-bit selector, 64-bit offset) in memory. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.w, mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/LDS:LES:LFS:LGS:LSS.html"
        ]
    },
    "vgatherqps": {
        "detail": [
            "Gather Packed Single, Packed Double with Signed Qword Indices"
        ],
        "documentation": [
            "A set of 8 single-precision/double-precision faulting-point memory locations pointed by base address BASE_ADDR and index vector V_INDEX with scale SCALE are gathered. The result is written into vector a register. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be loaded if their corresponding mask bit is one. If an element’s mask bit is not set, the corresponding element of the destination register is left unchanged. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already gathered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register (k1) are partially updated; those elements that have been gathered are placed into the destination register and have their mask bits set to zero. If any traps or interrupts are pending from already gathered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "If the data element size is less than the index element size, the higher part of the destination register and the mask register do not correspond to any elements being gathered. This instruction sets those higher parts to zero. It may update these unused elements to one or both of those registers even if the instruction triggers an exception, and even if the instruction triggers the exception before gathering any elements.",
            "Note that:"
        ],
        "operands": [
            "reg.y, reg.q, mem.d",
            "reg.x, mem.d, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VGATHERQPS:VGATHERQPD.html"
        ]
    },
    "prefetcht2": {
        "detail": [
            ""
        ],
        "operands": [
            "mem.z"
        ],
        "url": [
            "https://"
        ]
    },
    "vrsqrt28ps": {
        "detail": [
            "Approximation to the Reciprocal Square Root of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error"
        ],
        "documentation": [
            "Computes the reciprocal square root of the float32 values in the source operand (the second operand) and store the results to the destination operand (the first operand). The approximate reciprocal is evaluated with less than 2^-28 of maximum relative error prior to final rounding. The final results is rounded to < 2^-23 relative error before written to the destination.",
            "If any source element is NaN, the quietized NaN source value is returned for that element. Negative (non-zero) source numbers, as well as -∞, return the canonical NaN and set the Invalid Flag (#I).",
            "A value of -0 must return -∞ and set the DivByZero flags (#Z). Negative numbers should return NaN and set the Invalid flag (#I). Note however that the instruction flush input denormals to zero of the same sign, so negative denormals return -∞ and set the DivByZero flag.",
            "The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRSQRT28PS.html"
        ]
    },
    "seamcall": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "repe xsha256": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg.q, reg, mem.b, mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vfmsubaddpd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "fmulp": {
        "detail": [
            "Multiply"
        ],
        "documentation": [
            "Multiplies the destination and source operands and stores the product in the destination location. The destination operand is always an FPU data register; the source operand can be an FPU data register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.",
            "The no-operand version of the instruction multiplies the contents of the ST(1) register by the contents of the ST(0) register and stores the product in the ST(1) register. The one-operand version multiplies the contents of the ST(0) register by the contents of a memory location (either a floating point or an integer value) and stores the product in the ST(0) register. The two-operand version, multiplies the contents of the ST(0) register by the contents of the ST(i) register, or vice versa, with the result being stored in the register specified with the first operand (the destination operand).",
            "The FMULP instructions perform the additional operation of popping the FPU register stack after storing the product. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point multiply instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FMUL rather than FMULP.",
            "The FIMUL instructions convert an integer source operand to double extended-precision floating-point format before performing the multiplication.",
            "The sign of the result is always the exclusive-OR of the source signs, even if one or more of the values being multiplied is 0 or ∞. When the source operand is an integer 0, it is treated as a +0.",
            "The following table shows the results obtained when multiplying various classes of numbers, assuming that neither overflow nor underflow occurs."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FMUL:FMULP:FIMUL.html"
        ]
    },
    "rdpmc": {
        "detail": [
            "Read Performance-Monitoring Counters"
        ],
        "documentation": [
            "The EAX register is loaded with the low-order 32 bits. The EDX register is loaded with the supported high-order bits of the counter. The number of high-order bits loaded into EDX is implementation specific on processors that do no support architectural performance monitoring. The width of fixed-function and general-purpose performance counters on processors supporting architectural performance monitoring are reported by CPUID 0AH leaf. See below for the treatment of the EDX register for “fast” reads.",
            "The ECX register specifies the counter type (if the processor supports architectural performance monitoring) and counter index. Counter type is specified in ECX[30] to select one of two type of performance counters. If the processor does not support architectural performance monitoring, ECX[30:0] specifies the counter index; otherwise ECX[29:0] specifies the index relative to the base of each counter type. ECX[31] selects “fast” read mode if supported. The two counter types are:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/RDPMC.html"
        ]
    },
    "fistp": {
        "detail": [
            "Store Integer"
        ],
        "documentation": [
            "The FIST instruction converts the value in the ST(0) register to a signed integer and stores the result in the destination operand. Values can be stored in word or doubleword integer format. The destination operand specifies the address where the first byte of the destination value is to be stored.",
            "The FISTP instruction performs the same operation as the FIST instruction and then pops the register stack. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The FISTP instruction also stores values in quadword integer format.",
            "The following table shows the results obtained when storing various classes of numbers in integer format."
        ],
        "operands": [
            "mem.d, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FIST:FISTP.html"
        ]
    },
    "vpblendd": {
        "detail": [
            "Blend Packed Dwords"
        ],
        "documentation": [
            "Dword elements from the source operand (second operand) are conditionally written to the destination operand (first operand) depending on bits in the immediate operand (third operand). The immediate bits (bits 7:0) form a mask that determines whether the corresponding word in the destination is copied from the source. If a bit in the mask, corresponding to a word, is “1\", then the word is copied, else the word is unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register."
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPBLENDD.html"
        ]
    },
    "fptan": {
        "detail": [
            "Partial Tangent"
        ],
        "documentation": [
            "Computes the approximate tangent of the source operand in register ST(0), stores the result in ST(0), and pushes a 1.0 onto the FPU register stack. The source operand must be given in radians and must be less than ±263. The following table shows the unmasked results obtained when computing the partial tangent of various classes of numbers, assuming that underflow does not occur."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FPTAN.html"
        ]
    },
    "phsubw": {
        "detail": [
            "Packed Horizontal Subtract"
        ],
        "documentation": [
            "(V)PHSUBW performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and destination operands, and packs the signed 16-bit results to the destination operand (first operand). (V)PHSUBD performs horizontal subtraction on each adjacent pair of 32-bit signed integers by subtracting the most significant doubleword from the least significant doubleword of each pair, and packs the signed 32-bit result to the destination operand. When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Legacy SSE version: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "In 64-bit mode, use the REX prefix to access additional registers.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.",
            "Note: VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PHSUBW:PHSUBD.html"
        ]
    },
    "saveprevssp": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vfmsubaddps": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "rcpps": {
        "detail": [
            "Compute Reciprocals of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD computation of the approximate reciprocals of the four packed single-precision floating-point values in the source operand (second operand) stores the packed single-precision floating-point results in the destination operand. The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. See Figure 10-5 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a SIMD single-precision floating-point operation.",
            "The relative error for this approximation is:",
            "|Relative Error| ≤ 1.5 ∗ 2−12",
            "The RCPPS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). Tiny results (see Section 4.9.1.5, “Numeric Underflow Exception (#U)” in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1) are always flushed to 0.0, with the sign of the operand. (Input values greater than or equal to |1.11111111110100000000000B∗2125| are guaranteed to not produce tiny results; input values less than or equal to |1.00000000000110000000001B*2126| are guaranteed to produce tiny results, which are in turn flushed to 0.0; and input values in between this range may or may not produce tiny results, depending on the implementation.) When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/RCPPS.html"
        ]
    },
    "shufpd": {
        "detail": [
            "Packed Interleave Shuffle of Pairs of Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Selects a double-precision floating-point value of an input pair using a bit control and move to a designated element of the destination operand. The low-to-high order of double-precision element of the destination operand is interleaved between the first source operand and the second source operand at the granularity of input pair of 128 bits. Each bit in the imm8 byte, starting from bit 0, is the select control of the corresponding element of the destination to received the shuffled result of an input pair.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location The destination operand is a ZMM/YMM/XMM register updated according to the writemask. The select controls are the lower 8/4/2 bits of the imm8 byte.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The select controls are the bit 3:0 of the imm8 byte, imm8[7:4) are ignored.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed. The select controls are the bit 1:0 of the imm8 byte, imm8[7:2) are ignored.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination operand and the first source operand is the same and is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. The select controls are the bit 1:0 of the imm8 byte, imm8[7:2) are ignored."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SHUFPD.html"
        ]
    },
    "psadbw": {
        "detail": [
            "Compute Sum of Absolute Differences"
        ],
        "documentation": [
            "Computes the absolute value of the difference of 8 unsigned byte integers from the source operand (second operand) and from the destination operand (first operand). These 8 differences are then summed to produce an unsigned word integer result that is stored in the destination operand. Figure 4-14 shows the operation of the PSADBW instruction when using 64-bit operands.",
            "When operating on 64-bit operands, the word integer result is stored in the low word of the destination operand, and the remaining bytes in the destination operand are cleared to all 0s.",
            "When operating on 128-bit operands, two packed results are computed. Here, the 8 low-order bytes of the source and destination operands are operated on to produce a word result that is stored in the low word of the destination operand, and the 8 high-order bytes are operated on to produce a word result that is stored in bits 64 through 79 of the destination operand. The remaining bytes of the destination operand are cleared.",
            "For 256-bit version, the third group of 8 differences are summed to produce an unsigned word in bits[143:128] of the destination register and the fourth group of 8 differences are summed to produce an unsigned word in bits[207:192] of the destination register. The remaining words of the destination are set to 0.",
            "For 512-bit version, the fifth group result is stored in bits [271:256] of the destination. The result from the sixth group is stored in bits [335:320]. The results for the seventh and eighth group are stored respectively in bits [399:384] and bits [463:447], respectively. The remaining bits in the destination are set to 0.",
            "In 64-bit mode and not encoded by VEX/EVEX prefix, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The first source operand and destination register are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM destination register remain unchanged.",
            "VEX.128 and EVEX.128 encoded versions: The first source operand and destination register are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.",
            "VEX.256 and EVEX.256 encoded versions: The first source operand and destination register are YMM registers. The second source operand is an YMM register or a 256-bit memory location. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX.512 encoded version: The first source operand and destination register are ZMM registers. The second source operand is a ZMM register or a 512-bit memory location.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSADBW.html"
        ]
    },
    "pfrcp": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vpblendw": {
        "detail": [
            "Blend Packed Words"
        ],
        "documentation": [
            "Words from the source operand (second operand) are conditionally written to the destination operand (first operand) depending on bits in the immediate operand (third operand). The immediate bits (bits 7:0) form a mask that determines whether the corresponding word in the destination is copied from the source. If a bit in the mask, corresponding to a word, is “1\", then the word is copied, else the word element in the destination operand is unchanged.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PBLENDW.html"
        ]
    },
    "sysexit": {
        "detail": [
            "Fast Return from Fast System Call"
        ],
        "documentation": [
            "Executes a fast return to privilege level 3 user code. SYSEXIT is a companion instruction to the SYSENTER instruction. The instruction is optimized to provide the maximum performance for returns from system procedures executing at protections levels 0 to user procedures executing at protection level 3. It must be executed from code executing at privilege level 0.",
            "With a 64-bit operand size, SYSEXIT remains in 64-bit mode; otherwise, it either enters compatibility mode (if the logical processor is in IA-32e mode) or remains in protected mode (if it is not).",
            "Prior to executing SYSEXIT, software must specify the privilege level 3 code segment and code entry point, and the privilege level 3 stack segment and stack pointer by writing values into the following MSR and general-purpose registers:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.q, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/SYSEXIT.html"
        ]
    },
    "repe insb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.b, reg, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "repe insd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.d, reg, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vscatterdpd": {
        "detail": [
            "Scatter Packed Single, Packed Double with Signed Dword and Qword Indices"
        ],
        "documentation": [
            "Stores up to 16 elements (or 8 elements) in doubleword/quadword vector zmm1 to the memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register (k1) are partially updated. If any traps or interrupts are pending from already scattered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "Note that:"
        ],
        "operands": [
            "mem.q, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCATTERDPS:VSCATTERDPD:VSCATTERQPS:VSCATTERQPD.html"
        ]
    },
    "shufps": {
        "detail": [
            "Packed Interleave Shuffle of Quadruplets of Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Selects a single-precision floating-point value of an input quadruplet using a two-bit control and move to a designated element of the destination operand. Each 64-bit element-pair of a 128-bit lane of the destination operand is interleaved between the corresponding lane of the first source operand and the second source operand at the granularity 128 bits. Each two bits in the imm8 byte, starting from bit 0, is the select control of the corresponding element of a 128-bit lane of the destination to received the shuffled result of an input quadruplet. The two lower elements of a 128-bit lane in the destination receives shuffle results from the quadruple of the first source operand. The next two elements of the destination receives shuffle results from the quadruple of the second source operand.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register updated according to the writemask. Imm8[7:0] provides 4 select controls for each applicable 128-bit lane of the destination.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Imm8[7:0] provides 4 select controls for the high and low 128-bit of the destination.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed. Imm8[7:0] provides 4 select controls for each element of the destination.",
            "128-bit Legacy SSE version: The source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified. Imm8[7:0] provides 4 select controls for each element of the destination."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SHUFPS.html"
        ]
    },
    "vpcmpeqb": {
        "detail": [
            "Compare Packed Data for Equal"
        ],
        "documentation": [
            "Performs a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.",
            "The (V)PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the (V)PCMPEQW instruction compares the corresponding words in the destination and source operands; and the (V)PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPEQD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "EVEX encoded VPCMPEQB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html"
        ]
    },
    "vpcomub": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "vpcmpeqd": {
        "detail": [
            "Compare Packed Data for Equal"
        ],
        "documentation": [
            "Performs a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.",
            "The (V)PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the (V)PCMPEQW instruction compares the corresponding words in the destination and source operands; and the (V)PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPEQD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "EVEX encoded VPCMPEQB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html"
        ]
    },
    "vpcomud": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "pinsrb": {
        "detail": [
            "Insert Byte/Dword/Qword"
        ],
        "documentation": [
            "Copies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other elements in the destination register are left untouched.) The source operand can be a general-purpose register or a memory location. (When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destination operand is an XMM register. The count operand is an 8-bit immediate. When specifying a qword[dword, byte] location in an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose registers.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. VEX.L must be 0, otherwise the instruction will #UD. Attempt to execute VPINSRQ in non-64-bit mode will cause #UD.",
            "EVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. EVEX.L’L must be 0, otherwise the instruction will #UD.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.d, imm.b",
            "reg.x, mem.b, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PINSRB:PINSRD:PINSRQ.html"
        ]
    },
    "pinsrd": {
        "detail": [
            "Insert Byte/Dword/Qword"
        ],
        "documentation": [
            "Copies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other elements in the destination register are left untouched.) The source operand can be a general-purpose register or a memory location. (When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destination operand is an XMM register. The count operand is an 8-bit immediate. When specifying a qword[dword, byte] location in an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose registers.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. VEX.L must be 0, otherwise the instruction will #UD. Attempt to execute VPINSRQ in non-64-bit mode will cause #UD.",
            "EVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. EVEX.L’L must be 0, otherwise the instruction will #UD.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.d, imm.b",
            "reg.x, mem.d, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PINSRB:PINSRD:PINSRQ.html"
        ]
    },
    "fisub": {
        "detail": [
            "Subtract"
        ],
        "documentation": [
            "Subtracts the source operand from the destination operand and stores the difference in the destination location. The destination operand is always an FPU data register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.",
            "The no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floating-point or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.",
            "The FSUBP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUB rather than FSUBP.",
            "The FISUB instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.",
            "Table 3-38 shows the results obtained when subtracting various classes of numbers from one another, assuming that neither overflow nor underflow occurs. Here, the SRC value is subtracted from the DEST value (DEST − SRC = result).",
            "When the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.",
            "When one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalidoperation exception is generated."
        ],
        "operands": [
            "reg.wq, mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FSUB:FSUBP:FISUB.html"
        ]
    },
    "vpunpckldq": {
        "detail": [
            "Unpack Low Data"
        ],
        "documentation": [
            "Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-22 shows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html"
        ]
    },
    "inc": {
        "detail": [
            "Increment by 1"
        ],
        "documentation": [
            "Adds 1 to the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (Use a ADD instruction with an immediate operand of 1 to perform an increment operation that does updates the CF flag.)",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, INC r16 and INC r32 are not encodable (because opcodes 40H through 47H are REX prefixes). Otherwise, the instruction’s 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/INC.html"
        ]
    },
    "vscatterdps": {
        "detail": [
            "Scatter Packed Single, Packed Double with Signed Dword and Qword Indices"
        ],
        "documentation": [
            "Stores up to 16 elements (or 8 elements) in doubleword/quadword vector zmm1 to the memory locations pointed by base address BASE_ADDR and index vector VINDEX, with scale SCALE. The elements are specified via the VSIB (i.e., the index register is a vector register, holding packed indices). Elements will only be stored if their corresponding mask bit is one. The entire mask register will be set to zero by this instruction unless it triggers an exception.",
            "This instruction can be suspended by an exception if at least one element is already scattered (i.e., if the exception is triggered by an element other than the rightmost one with its mask bit set). When this happens, the destination register and the mask register (k1) are partially updated. If any traps or interrupts are pending from already scattered elements, they will be delivered in lieu of the exception; in this case, EFLAG.RF is set to one so an instruction breakpoint is not re-triggered when the instruction is continued.",
            "Note that:"
        ],
        "operands": [
            "mem.d, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCATTERDPS:VSCATTERDPD:VSCATTERQPS:VSCATTERQPD.html"
        ]
    },
    "repe insw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.w, reg, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "divsd": {
        "detail": [
            "Divide Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Divides the low double-precision floating-point value in the first source operand by the low double-precision floating-point value in the second source operand, and stores the double-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination are XMM registers.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:64) of the corresponding ZMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The quadword at bits 127:64 of the destination operand is copied from the corresponding quadword of the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX.128 encoded version: The first source operand is an xmm register encoded by EVEX.vvvv. The quadword element of the destination operand at bits 127:64 are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX version: The low quadword element of the destination is updated according to the writemask.",
            "Software should ensure VDIVSD is encoded with VEX.L=0. Encoding VDIVSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/DIVSD.html"
        ]
    },
    "vpcmpeqq": {
        "detail": [
            "Compare Packed Qword Data for Equal"
        ],
        "documentation": [
            "Performs an SIMD compare for equality of the packed quadwords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination is set to all 1s; otherwise, it is set to 0s.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPEQQ: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPEQQ.html"
        ]
    },
    "vpcomuq": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "pinsrq": {
        "detail": [
            "Insert Byte/Dword/Qword"
        ],
        "documentation": [
            "Copies a byte/dword/qword from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other elements in the destination register are left untouched.) The source operand can be a general-purpose register or a memory location. (When the source operand is a general-purpose register, PINSRB copies the low byte of the register.) The destination operand is an XMM register. The count operand is an 8-bit immediate. When specifying a qword[dword, byte] location in an XMM register, the [2, 4] least-significant bit(s) of the count operand specify the location.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). Use of REX.W permits the use of 64 bit general purpose registers.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. VEX.L must be 0, otherwise the instruction will #UD. Attempt to execute VPINSRQ in non-64-bit mode will cause #UD.",
            "EVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. EVEX.L’L must be 0, otherwise the instruction will #UD.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, imm.b",
            "reg.x, mem.q, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PINSRB:PINSRD:PINSRQ.html"
        ]
    },
    "vpcmpeqw": {
        "detail": [
            "Compare Packed Data for Equal"
        ],
        "documentation": [
            "Performs a SIMD compare for equality of the packed bytes, words, or doublewords in the destination operand (first operand) and the source operand (second operand). If a pair of data elements is equal, the corresponding data element in the destination operand is set to all 1s; otherwise, it is set to all 0s.",
            "The (V)PCMPEQB instruction compares the corresponding bytes in the destination and source operands; the (V)PCMPEQW instruction compares the corresponding words in the destination and source operands; and the (V)PCMPEQD instruction compares the corresponding doublewords in the destination and source operands.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand can be an XMM register or a 128-bit memory location. The first source and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "EVEX encoded VPCMPEQD: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "EVEX encoded VPCMPEQB/W: The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand (first operand) is a mask register updated according to the writemask k2.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html"
        ]
    },
    "ltr": {
        "detail": [
            "Load Task Register"
        ],
        "documentation": [
            "Loads the source operand into the segment selector field of the task register. The source operand (a general-purpose register or a memory location) contains a segment selector that points to a task state segment (TSS). After the segment selector is loaded in the task register, the processor uses the segment selector to locate the segment descriptor for the TSS in the global descriptor table (GDT). It then loads the segment limit and base address for the TSS from the segment descriptor into the task register. The task pointed to by the task register is marked busy, but a switch to the task does not occur.",
            "The LTR instruction is provided for use in operating-system software; it should not be used in application programs. It can only be executed in protected mode when the CPL is 0. It is commonly used in initialization code to establish the first task to be executed.",
            "The operand-size attribute has no effect on this instruction.",
            "In 64-bit mode, the operand size is still fixed at 16 bits. The instruction references a 16-byte descriptor to load the 64-bit base.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.w, reg",
            "mem.w, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/LTR.html"
        ]
    },
    "vpcomuw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://"
        ]
    },
    "vcvttpd2udq": {
        "detail": [
            "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers"
        ],
        "documentation": [
            "Converts with truncation packed double-precision floating-point values in the source operand (the second operand) to packed unsigned doubleword integers in the destination operand (the first operand).",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w – 1 is returned, where w represents the number of bits in the destination format.",
            "The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM/XMM/XMM (low 64 bits) register conditionally updated with writemask k1. The upper bits (MAXVL-1:256) of the corresponding destination are zeroed.",
            "Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.y, mem.z",
            "reg.y, reg.z",
            "reg.y, reg.q, mem.z",
            "reg.y, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTTPD2UDQ.html"
        ]
    },
    "pinsrw": {
        "detail": [
            "Insert Word"
        ],
        "documentation": [
            "Copies a word from the source operand (second operand) and inserts it in the destination operand (first operand) at the location specified with the count operand (third operand). (The other words in the destination register are left untouched.) The source operand can be a general-purpose register or a 16-bit memory location. (When the source operand is a general-purpose register, the low word of the register is copied.) The destination operand can be an MMX technology register or an XMM register. The count operand is an 8-bit immediate. When specifying a word location in an MMX technology register, the 2 least-significant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the location.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15).",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.",
            "EVEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed. EVEX.L’L must be 0, otherwise the instruction will #UD.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.d, imm.b",
            "reg.q, mem.w, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PINSRW.html"
        ]
    },
    "int": {
        "detail": [
            "Call to Interrupt Procedure"
        ],
        "documentation": [
            "The INT n instruction generates a call to the interrupt or exception handler specified with the destination operand (see the section titled “Interrupts and Exceptions” in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1). The destination operand specifies a vector from 0 to 255, encoded as an 8-bit unsigned intermediate value. Each vector provides an index to a gate descriptor in the IDT. The first 32 vectors are reserved by Intel for system use. Some of these vectors are used for internally generated exceptions.",
            "The INT n instruction is the general mnemonic for executing a software-generated call to an interrupt handler. The INTO instruction is a special mnemonic for calling overflow exception (#OF), exception 4. The overflow interrupt checks the OF flag in the EFLAGS register and calls the overflow interrupt handler if the OF flag is set to 1. (The INTO instruction cannot be used in 64-bit mode.)",
            "The INT3 instruction uses a one-byte opcode (CC) and is intended for calling the debug exception handler with a breakpoint exception (#BP). (This one-byte form is useful because it can replace the first byte of any instruction at which a breakpoint is desired, including other one-byte instructions, without overwriting other instructions.)",
            "The INT1 instruction also uses a one-byte opcode (F1) and generates a debug exception (#DB) without setting any bits in DR6.1 Hardware vendors may use the INT1 instruction for hardware debug. For that reason, Intel recommends software vendors instead use the INT3 instruction for software breakpoints.",
            "Flags Affected:",
            "The EFLAGS register is pushed onto the stack. The IF, TF, NT, AC, RF, and VM flags may be cleared, depending on the mode of operation of the processor when the INT instruction is executed (see the “Operation” section). If the interrupt uses a task gate, any flags may be set or cleared, controlled by the EFLAGS image in the new task’s TSS."
        ],
        "operands": [
            "imm.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/INTn:INTO:INT3:INT1.html"
        ]
    },
    "hlt": {
        "detail": [
            "Halt"
        ],
        "documentation": [
            "Stops instruction execution and places the processor in a HALT state. An enabled interrupt (including NMI and SMI), a debug exception, the BINIT# signal, the INIT# signal, or the RESET# signal will resume execution. If an interrupt (including NMI) is used to resume execution after a HLT instruction, the saved instruction pointer (CS:EIP) points to the instruction following the HLT instruction.",
            "When a HLT instruction is executed on an Intel 64 or IA-32 processor supporting Intel Hyper-Threading Technology, only the logical processor that executes the instruction is halted. The other logical processors in the physical processor remain active, unless they are each individually halted by executing a HLT instruction.",
            "The HLT instruction is a privileged instruction. When the processor is running in protected or virtual-8086 mode, the privilege level of a program or procedure must be 0 to execute the HLT instruction.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/HLT.html"
        ]
    },
    "vcvtps2dq": {
        "detail": [
            "Convert Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values"
        ],
        "documentation": [
            "Converts four, eight or sixteen packed single-precision floating-point values in the source operand to four, eight or sixteen signed doubleword integers in the destination operand.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.",
            "EVEX encoded versions: The source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTPS2DQ.html"
        ]
    },
    "divss": {
        "detail": [
            "Divide Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Divides the low single-precision floating-point value in the first source operand by the low single-precision floating-point value in the second source operand, and stores the single-precision floating-point result in the destination operand. The second source operand can be an XMM register or a 32-bit memory location.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source operand is an xmm register encoded by VEX.vvvv. The three high-order doublewords of the destination operand are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX.128 encoded version: The first source operand is an xmm register encoded by EVEX.vvvv. The doubleword elements of the destination operand at bits 127:32 are copied from the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX version: The low doubleword element of the destination is updated according to the writemask.",
            "Software should ensure VDIVSS is encoded with VEX.L=0. Encoding VDIVSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/DIVSS.html"
        ]
    },
    "pmaxsb": {
        "detail": [
            "Maximum of Packed Signed Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.",
            "EVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html"
        ]
    },
    "maxsd": {
        "detail": [
            "Return Maximum Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Compares the low double-precision floating-point values in the first source operand and the second source operand, and returns the maximum value to the low quadword of the destination operand. The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers. When the second source operand is a memory operand, only 64 bits are accessed.",
            "If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN of either source operand be returned, the action of MAXSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.",
            "128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded version: Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination operand is updated according to the writemask.",
            "Software should ensure VMAXSD is encoded with VEX.L=0. Encoding VMAXSD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MAXSD.html"
        ]
    },
    "clgi": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "cbw": {
        "detail": [
            "Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword"
        ],
        "documentation": [
            "Double the size of the source operand by means of sign extension. The CBW (convert byte to word) instruction copies the sign (bit 7) in the source operand into every bit in the AH register. The CWDE (convert word to double-word) instruction copies the sign (bit 15) of the word in the AX register into the high 16 bits of the EAX register.",
            "CBW and CWDE reference the same opcode. The CBW instruction is intended for use when the operand-size attribute is 16; CWDE is intended for use when the operand-size attribute is 32. Some assemblers may force the operand size. Others may treat these two mnemonics as synonyms (CBW/CWDE) and use the setting of the operand-size attribute to determine the size of values to be converted.",
            "In 64-bit mode, the default operation size is the size of the destination register. Use of the REX.W prefix promotes this instruction (CDQE when promoted) to operate on 64-bit operands. In which case, CDQE copies the sign (bit 31) of the doubleword in the EAX register into the high 32 bits of RAX.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/CBW:CWDE:CDQE.html"
        ]
    },
    "pmaxsd": {
        "detail": [
            "Maximum of Packed Signed Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.",
            "EVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html"
        ]
    },
    "vfnmsub132sd": {
        "detail": [
            "Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMSUB132SD: Multiplies the low packed double-precision floating-point value from the first source operand to the low packed double-precision floating-point value in the third source operand. From negated infinite precision intermediate result, subtracts the low double-precision floating-point value in the second source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFNMSUB213SD: Multiplies the low packed double-precision floating-point value from the second source operand to the low packed double-precision floating-point value in the first source operand. From negated infinite precision intermediate result, subtracts the low double-precision floating-point value in the third source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VFNMSUB231SD: Multiplies the low packed double-precision floating-point value from the second source to the low packed double-precision floating-point value in the third source operand. From negated infinite precision intermediate result, subtracts the low double-precision floating-point value in the first source operand, performs rounding and stores the resulting packed double-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:64 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low quadword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMSUB132SD:VFNMSUB213SD:VFNMSUB231SD.html"
        ]
    },
    "vmptrst": {
        "detail": [
            "Store Pointer to Virtual-Machine Control Structure"
        ],
        "documentation": [
            "Stores the current-VMCS pointer into a specified memory address. The operand of this instruction is always 64 bits and is always in memory.",
            "Flags Affected:",
            "See the operation section and Section 30.2."
        ],
        "operands": [
            "mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VMPTRST.html"
        ]
    },
    "repe xcryptcbc": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.b, reg, reg.d, reg, reg.q, mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "fucomi": {
        "detail": [
            "Compare Floating Point Values and Set EFLAGS"
        ],
        "documentation": [
            "Performs an unordered comparison of the contents of registers ST(0) and ST(i) and sets the status flags ZF, PF, and CF in the EFLAGS register according to the results (see the table below). The sign of zero is ignored for comparisons, so that –0.0 is equal to +0.0."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FCOMI:FCOMIP:FUCOMI:FUCOMIP.html"
        ]
    },
    "pmaxsw": {
        "detail": [
            "Maximum of Packed Signed Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed signed byte, word, dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMAXSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded VPMAXSD/Q: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1.",
            "EVEX encoded VPMAXSB/W: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html"
        ]
    },
    "maxss": {
        "detail": [
            "Return Maximum Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "Compares the low single-precision floating-point values in the first source operand and the second source operand, and returns the maximum value to the low doubleword of the destination operand.",
            "If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second source operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN from either source operand be returned, the action of MAXSS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.",
            "The second source operand can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers.",
            "128-bit Legacy SSE version: The destination and first source operand are the same. Bits (MAXVL:32) of the corresponding destination register remain unchanged.",
            "VEX.128 and EVEX encoded version: The first source operand is an xmm register encoded by VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL:128) of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination operand is updated according to the writemask.",
            "Software should ensure VMAXSS is encoded with VEX.L=0. Encoding VMAXSS with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/MAXSS.html"
        ]
    },
    "fucomp": {
        "detail": [
            "Unordered Compare Floating Point Values"
        ],
        "documentation": [
            "Performs an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2, and C3 in the FPU status word according to the results (see the table below). If no operand is specified, the contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that –0.0 is equal to +0.0."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FUCOM:FUCOMP:FUCOMPP.html"
        ]
    },
    "vfnmsub132ss": {
        "detail": [
            "Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFNMSUB132SS: Multiplies the low packed single-precision floating-point value from the first source operand to the low packed single-precision floating-point value in the third source operand. From negated infinite precision intermediate result, the low single-precision floating-point value in the second source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFNMSUB213SS: Multiplies the low packed single-precision floating-point value from the second source operand to the low packed single-precision floating-point value in the first source operand. From negated infinite precision intermediate result, the low single-precision floating-point value in the third source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VFNMSUB231SS: Multiplies the low packed single-precision floating-point value from the second source to the low packed single-precision floating-point value in the third source operand. From negated infinite precision intermediate result, the low single-precision floating-point value in the first source operand, performs rounding and stores the resulting packed single-precision floating-point value to the destination operand (first source operand).",
            "VEX.128 and EVEX encoded version: The destination operand (also first source operand) is encoded in reg_field. The second source operand is encoded in VEX.vvvv/EVEX.vvvv. The third source operand is encoded in rm_field. Bits 127:32 of the destination are unchanged. Bits MAXVL-1:128 of the destination register are zeroed.",
            "EVEX encoded version: The low doubleword element of the destination is updated according to the writemask.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFNMSUB132SS:VFNMSUB213SS:VFNMSUB231SS.html"
        ]
    },
    "kunpckdq": {
        "detail": [
            "Unpack for Mask Registers"
        ],
        "documentation": [
            "Unpacks the lower 8/16/32 bits of the second and third operands (source operands) into the low part of the first operand (destination operand), starting from the low bytes. The result is zero-extended in the destination.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KUNPCKBW:KUNPCKWD:KUNPCKDQ.html"
        ]
    },
    "leave": {
        "detail": [
            "High Level Procedure Exit"
        ],
        "documentation": [
            "Releases the stack frame set up by an earlier ENTER instruction. The LEAVE instruction copies the frame pointer (in the EBP register) into the stack pointer register (ESP), which releases the stack space allocated to the stack frame. The old frame pointer (the frame pointer for the calling procedure that was saved by the ENTER instruction) is then popped from the stack into the EBP register, restoring the calling procedure’s stack frame.",
            "A RET instruction is commonly executed following a LEAVE instruction to return program control to the calling procedure.",
            "See “Procedure Calls for Block-Structured Languages” in Chapter 7 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for detailed information on the use of the ENTER and LEAVE instructions.",
            "In 64-bit mode, the instruction’s default operation size is 64 bits; 32-bit operation cannot be encoded. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "mem.q, reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/LEAVE.html"
        ]
    },
    "rex64 xbegin": {
        "detail": [
            "Transactional Begin"
        ],
        "documentation": [
            "The XBEGIN instruction specifies the start of an RTM code region. If the logical processor was not already in transactional execution, then the XBEGIN instruction causes the logical processor to transition into transactional execution. The XBEGIN instruction that transitions the logical processor into transactional execution is referred to as the outermost XBEGIN instruction. The instruction also specifies a relative offset to compute the address of the fallback code path following a transactional abort.",
            "On an RTM abort, the logical processor discards all architectural register and memory updates performed during the RTM execution and restores architectural state to that corresponding to the outermost XBEGIN instruction. The fallback address following an abort is computed from the outermost XBEGIN instruction.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "relbr.d, reg.q, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XBEGIN.html"
        ]
    },
    "kmovb": {
        "detail": [
            "Move from and to Mask Registers"
        ],
        "documentation": [
            "Copies values from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be mask registers, memory location or general purpose. The instruction cannot be used to transfer data between general purpose registers and or memory locations.",
            "When moving to a mask register, the result is zero extended to MAX_KL size (i.e., 64 bits currently). When moving to a general-purpose register (GPR), the result is zero-extended to the size of the destination. In 32-bit mode, the default GPR destination’s size is 32 bits. In 64-bit mode, the default GPR destination’s size is 64 bits. Note that VEX.W can only be used to modify the size of the GPR operand in 64b mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, mem.b",
            "reg.q, reg.q",
            "mem.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KMOVW:KMOVB:KMOVQ:KMOVD.html"
        ]
    },
    "kmovd": {
        "detail": [
            "Move from and to Mask Registers"
        ],
        "documentation": [
            "Copies values from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be mask registers, memory location or general purpose. The instruction cannot be used to transfer data between general purpose registers and or memory locations.",
            "When moving to a mask register, the result is zero extended to MAX_KL size (i.e., 64 bits currently). When moving to a general-purpose register (GPR), the result is zero-extended to the size of the destination. In 32-bit mode, the default GPR destination’s size is 32 bits. In 64-bit mode, the default GPR destination’s size is 64 bits. Note that VEX.W can only be used to modify the size of the GPR operand in 64b mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, mem.d",
            "reg.q, reg.q",
            "mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KMOVW:KMOVB:KMOVQ:KMOVD.html"
        ]
    },
    "dec": {
        "detail": [
            "Decrement by 1"
        ],
        "documentation": [
            "Subtracts 1 from the destination operand, while preserving the state of the CF flag. The destination operand can be a register or a memory location. This instruction allows a loop counter to be updated without disturbing the CF flag. (To perform a decrement operation that updates the CF flag, use a SUB instruction with an immediate operand of 1.)",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, DEC r16 and DEC r32 are not encodable (because opcodes 48H through 4FH are REX prefixes). Otherwise, the instruction’s 64-bit mode default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits.",
            "See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The CF flag is not affected. The OF, SF, ZF, AF, and PF flags are set according to the result."
        ],
        "operands": [
            "reg.b",
            "mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/DEC.html"
        ]
    },
    "phminposuw": {
        "detail": [
            "Packed Horizontal Word Minimum"
        ],
        "documentation": [
            "Determine the minimum unsigned word value in the source operand (second operand) and place the unsigned word in the low word (bits 0-15) of the destination operand (first operand). The word index of the minimum value is stored in bits 16-18 of the destination operand. The remaining upper bits of the destination are set to zero.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding XMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination XMM register are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PHMINPOSUW.html"
        ]
    },
    "kmovq": {
        "detail": [
            "Move from and to Mask Registers"
        ],
        "documentation": [
            "Copies values from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be mask registers, memory location or general purpose. The instruction cannot be used to transfer data between general purpose registers and or memory locations.",
            "When moving to a mask register, the result is zero extended to MAX_KL size (i.e., 64 bits currently). When moving to a general-purpose register (GPR), the result is zero-extended to the size of the destination. In 32-bit mode, the default GPR destination’s size is 32 bits. In 64-bit mode, the default GPR destination’s size is 64 bits. Note that VEX.W can only be used to modify the size of the GPR operand in 64b mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KMOVW:KMOVB:KMOVQ:KMOVD.html"
        ]
    },
    "aeskeygenassist": {
        "detail": [
            "AES Round Key Generation Assist"
        ],
        "documentation": [
            "Assist in expanding the AES cipher key, by computing steps towards generating a round key for encryption, using 128-bit data specified in the source operand and an 8-bit round constant specified as an immediate, store the result in the destination operand.",
            "The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/AESKEYGENASSIST.html"
        ]
    },
    "vmovupd": {
        "detail": [
            "Move Unaligned Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Note: VEX.vvvv and EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX.512 encoded version:",
            "Moves 512 bits of packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a ZMM register from a float64 memory location, to store the contents of a ZMM register into a memory. The destination operand is updated according to the writemask.",
            "VEX.256 encoded version:",
            "Moves 256 bits of packed double-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers. Bits (MAXVL-1:256) of the destination register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.x, reg.x",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVUPD.html"
        ]
    },
    "pfpnacc": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "kmovw": {
        "detail": [
            "Move from and to Mask Registers"
        ],
        "documentation": [
            "Copies values from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be mask registers, memory location or general purpose. The instruction cannot be used to transfer data between general purpose registers and or memory locations.",
            "When moving to a mask register, the result is zero extended to MAX_KL size (i.e., 64 bits currently). When moving to a general-purpose register (GPR), the result is zero-extended to the size of the destination. In 32-bit mode, the default GPR destination’s size is 32 bits. In 64-bit mode, the default GPR destination’s size is 64 bits. Note that VEX.W can only be used to modify the size of the GPR operand in 64b mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, mem.w",
            "reg.q, reg.q",
            "mem.w, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KMOVW:KMOVB:KMOVQ:KMOVD.html"
        ]
    },
    "enter": {
        "detail": [
            "Make Stack Frame for Procedure Parameters"
        ],
        "documentation": [
            "Creates a stack frame (comprising of space for dynamic storage and 1-32 frame pointer storage) for a procedure. The first operand (imm16) specifies the size of the dynamic storage in the stack frame (that is, the number of bytes of dynamically allocated on the stack for the procedure). The second operand (imm8) gives the lexical nesting level (0 to 31) of the procedure. The nesting level (imm8 mod 32) and the OperandSize attribute determine the size in bytes of the storage space for frame pointers.",
            "The nesting level determines the number of frame pointers that are copied into the “display area” of the new stack frame from the preceding frame. The default size of the frame pointer is the StackAddrSize attribute, but can be overridden using the 66H prefix. Thus, the OperandSize attribute determines the size of each frame pointer that will be copied into the stack frame and the data being transferred from SP/ESP/RSP register into the BP/EBP/RBP register.",
            "The ENTER and companion LEAVE instructions are provided to support block structured languages. The ENTER instruction (when used) is typically the first instruction in a procedure and is used to set up a new stack frame for a procedure. The LEAVE instruction is then used at the end of the procedure (just before the RET instruction) to release the stack frame.",
            "If the nesting level is 0, the processor pushes the frame pointer from the BP/EBP/RBP register onto the stack, copies the current stack pointer from the SP/ESP/RSP register into the BP/EBP/RBP register, and loads the SP/ESP/RSP register with the current stack-pointer value minus the value in the size operand. For nesting levels of 1 or greater, the processor pushes additional frame pointers on the stack before adjusting the stack pointer. These additional frame pointers provide the called procedure with access points to other nested frames on the stack. See “Procedure Calls for Block-Structured Languages” in Chapter 6 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information about the actions of the ENTER instruction.",
            "The ENTER instruction causes a page fault whenever a write using the final value of the stack pointer (within the current stack segment) would do so.",
            "In 64-bit mode, default operation size is 64 bits; 32-bit operation size cannot be encoded. Use of 66H prefix changes frame pointer operand size to 16 bits.",
            "When the 66H prefix is used and causing the OperandSize attribute to be less than the StackAddrSize, software is responsible for the following:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "imm.w, imm.b, reg.q, reg.q, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/ENTER.html"
        ]
    },
    "vmovups": {
        "detail": [
            "Move Unaligned Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Note: VEX.vvvv and EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "EVEX.512 encoded version:",
            "Moves 512 bits of packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a ZMM register from a 512-bit float32 memory location, to store the contents of a ZMM register into memory. The destination operand is updated according to the writemask.",
            "VEX.256 and EVEX.256 encoded versions:",
            "Moves 256 bits of packed single-precision floating-point values from the source operand (second operand) to the destination operand (first operand). This instruction can be used to load a YMM register from a 256-bit memory location, to store the contents of a YMM register into a 256-bit memory location, or to move data between two YMM registers. Bits (MAXVL-1:256) of the destination register are zeroed."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.x, reg.x",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVUPS.html"
        ]
    },
    "vmpsadbw": {
        "detail": [
            "Compute Multiple Packed Sums of Absolute Difference"
        ],
        "documentation": [
            "(V)MPSADBW calculates packed word results of sum-absolute-difference (SAD) of unsigned bytes from two blocks of 32-bit dword elements, using two select fields in the immediate byte to select the offsets of the two blocks within the first source operand and the second operand. Packed SAD word results are calculated within each 128-bit lane. Each SAD word result is calculated between a stationary block_2 (whose offset within the second source operand is selected by a two bit select control, multiplied by 32 bits) and a sliding block_1 at consecutive byte-granular position within the first source operand. The offset of the first 32-bit block of block_1 is selectable using a one bit select control, multiplied by 32 bits.",
            "128-bit Legacy SSE version: Imm8[1:0]*32 specifies the bit offset of block_2 within the second source operand. Imm[2]*32 specifies the initial bit offset of the block_1 within the first source operand. The first source operand and destination operand are the same. The first source and destination operands are XMM registers. The second source operand is either an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. Bits 7:3 of the immediate byte are ignored.",
            "VEX.128 encoded version: Imm8[1:0]*32 specifies the bit offset of block_2 within the second source operand. Imm[2]*32 specifies the initial bit offset of the block_1 within the first source operand. The first source and destination operands are XMM registers. The second source operand is either an XMM register or a 128-bit memory location. Bits (127:128) of the corresponding YMM register are zeroed. Bits 7:3 of the immediate byte are ignored.",
            "VEX.256 encoded version: The sum-absolute-difference (SAD) operation is repeated 8 times for MPSADW between the same block_2 (fixed offset within the second source operand) and a variable block_1 (offset is shifted by 8 bits for each SAD operation) in the first source operand. Each 16-bit result of eight SAD operations between block_2 and block_1 is written to the respective word in the lower 128 bits of the destination operand.",
            "Additionally, VMPSADBW performs another eight SAD operations on block_4 of the second source operand and block_3 of the first source operand. (Imm8[4:3]*32 + 128) specifies the bit offset of block_4 within the second source operand. (Imm[5]*32+128) specifies the initial bit offset of the block_3 within the first source operand. Each 16-bit result of eight SAD operations between block_4 and block_3 is written to the respective word in the upper 128 bits of the destination operand.",
            "The first source operand is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. Bits 7:6 of the immediate byte are ignored.",
            "Note: If VMPSADBW is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/MPSADBW.html"
        ]
    },
    "lock btc": {
        "detail": [
            "Bit Test and Complement"
        ],
        "documentation": [
            "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and complements the selected bit in the bit string. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:",
            "Flags Affected:",
            "The CF flag contains the value of the selected bit before it is complemented. The ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined."
        ],
        "operands": [
            "mem.w, imm.b",
            "mem.w, reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/BTC.html"
        ]
    },
    "vperm2f128": {
        "detail": [
            "Permute Floating-Point Values"
        ],
        "documentation": [
            "Permute 128 bit floating-point-containing fields from the first source operand (second operand) and second source operand (third operand) using bits in the 8-bit immediate and store results in the destination operand (first operand). The first source operand is a YMM register, the second source operand is a YMM register or a 256-bit memory location, and the destination operand is a YMM register."
        ],
        "operands": [
            "reg.y, reg.y, mem.y, imm.b",
            "reg.y, reg.y, reg.y, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERM2F128.html"
        ]
    },
    "lock btr": {
        "detail": [
            "Bit Test and Reset"
        ],
        "documentation": [
            "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and clears the selected bit in the bit string to 0. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:",
            "Flags Affected:",
            "The CF flag contains the value of the selected bit before it is cleared. The ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined."
        ],
        "operands": [
            "mem.w, imm.b",
            "mem.w, reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/BTR.html"
        ]
    },
    "lock bts": {
        "detail": [
            "Bit Test and Set"
        ],
        "documentation": [
            "Selects the bit in a bit string (specified with the first operand, called the bit base) at the bit-position designated by the bit offset operand (second operand), stores the value of the bit in the CF flag, and sets the selected bit in the bit string to 1. The bit base operand can be a register or a memory location; the bit offset operand can be a register or an immediate value:",
            "Flags Affected:",
            "The CF flag contains the value of the selected bit before it is set. The ZF flag is unaffected. The OF, SF, AF, and PF flags are undefined."
        ],
        "operands": [
            "mem.w, imm.b",
            "mem.w, reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/BTS.html"
        ]
    },
    "vpextrb": {
        "detail": [
            "Extract Byte/Dword/Qword"
        ],
        "documentation": [
            "Extract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a register, the upper bits of the register are zero extended.",
            "In legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros. PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.",
            "Note: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD. In EVEX.128 encoded versions, EVEX.vvvv is reserved and must be 1111b, EVEX.L”L must be",
            "0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRB/VPEXTRD is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.d, reg.x, imm.b",
            "mem.b, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PEXTRB:PEXTRD:PEXTRQ.html"
        ]
    },
    "vpextrd": {
        "detail": [
            "Extract Byte/Dword/Qword"
        ],
        "documentation": [
            "Extract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a register, the upper bits of the register are zero extended.",
            "In legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros. PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.",
            "Note: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD. In EVEX.128 encoded versions, EVEX.vvvv is reserved and must be 1111b, EVEX.L”L must be",
            "0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRB/VPEXTRD is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.d, reg.x, imm.b",
            "mem.d, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PEXTRB:PEXTRD:PEXTRQ.html"
        ]
    },
    "knotb": {
        "detail": [
            "NOT Mask Register"
        ],
        "documentation": [
            "Performs a bitwise NOT of vector mask k2 and writes the result into vector mask k1.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KNOTW:KNOTB:KNOTQ:KNOTD.html"
        ]
    },
    "vcvtqq2pd": {
        "detail": [
            "Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Converts packed quadword integers in the source operand (second operand) to packed double-precision floating-point values in the destination operand (first operand).",
            "The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operation is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTQQ2PD.html"
        ]
    },
    "knotd": {
        "detail": [
            "NOT Mask Register"
        ],
        "documentation": [
            "Performs a bitwise NOT of vector mask k2 and writes the result into vector mask k1.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KNOTW:KNOTB:KNOTQ:KNOTD.html"
        ]
    },
    "vrsqrt28sd": {
        "detail": [
            "Approximation to the Reciprocal Square Root of Scalar Double-Precision Floating-Point Value with Less Than 2^-28 Relative Error"
        ],
        "documentation": [
            "Computes the reciprocal square root of the low float64 value in the second source operand (the third operand) and store the result to the destination operand (the first operand). The approximate reciprocal square root is evaluated with less than 2^-28 of maximum relative error. The result is written into the low float64 element of xmm1 according to the writemask k1. Bits 127:64 of the destination is copied from the corresponding bits of the first source operand (the second operand).",
            "If any source element is NaN, the quietized NaN source value is returned for that element. Negative (non-zero) source numbers, as well as -∞, return the canonical NaN and set the Invalid Flag (#I).",
            "A value of -0 must return -∞ and set the DivByZero flags (#Z). Negative numbers should return NaN and set the Invalid flag (#I). Note however that the instruction flush input denormals to zero of the same sign, so negative denormals return -∞ and set the DivByZero flag.",
            "The first source operand is an XMM register. The second source operand is an XMM register or a 64-bit memory location. The destination operand is a XMM register."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRSQRT28SD.html"
        ]
    },
    "fwait": {
        "detail": [
            "Wait"
        ],
        "documentation": [
            "Causes the processor to check for and handle pending, unmasked, floating-point exceptions before proceeding. (FWAIT is an alternate mnemonic for WAIT.)",
            "This instruction is useful for synchronizing exceptions in critical sections of code. Coding a WAIT instruction after a floating-point instruction ensures that any unmasked floating-point exceptions the instruction may raise are handled before the processor can modify the instruction’s results. See the section titled “Floating-Point Exception Synchronization” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for more information on using the WAIT/FWAIT instruction.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://felixcloutier.com/x86/WAIT:FWAIT.html"
        ]
    },
    "vaesenc": {
        "detail": [
            "Perform One Round of an AES Encryption Flow"
        ],
        "documentation": [
            "This instruction performs a single round of an AES encryption flow using a round key from the second source operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination operand.",
            "Use the AESENC instruction for all but the last encryption rounds. For the last encryption round, use the AESENCCLAST instruction.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/AESENC.html"
        ]
    },
    "cvtps2dq": {
        "detail": [
            "Convert Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values"
        ],
        "documentation": [
            "Converts four, eight or sixteen packed single-precision floating-point values in the source operand to four, eight or sixteen signed doubleword integers in the destination operand.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.",
            "EVEX encoded versions: The source operand is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The source operand is a YMM register or 256- bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The source operand is an XMM register or 128- bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The source operand is an XMM register or 128- bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTPS2DQ.html"
        ]
    },
    "vpextrq": {
        "detail": [
            "Extract Byte/Dword/Qword"
        ],
        "documentation": [
            "Extract a byte/dword/qword integer value from the source XMM register at a byte/dword/qword offset determined from imm8[3:0]. The destination can be a register or byte/dword/qword memory location. If the destination is a register, the upper bits of the register are zero extended.",
            "In legacy non-VEX encoded version and if the destination operand is a register, the default operand size in 64-bit mode for PEXTRB/PEXTRD is 64 bits, the bits above the least significant byte/dword data are filled with zeros. PEXTRQ is not encodable in non-64-bit modes and requires REX.W in 64-bit mode.",
            "Note: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD. In EVEX.128 encoded versions, EVEX.vvvv is reserved and must be 1111b, EVEX.L”L must be",
            "0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRB/VPEXTRD is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.x, imm.b",
            "mem.q, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PEXTRB:PEXTRD:PEXTRQ.html"
        ]
    },
    "vpminsb": {
        "detail": [
            "Minimum of Packed Signed Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed signed byte, word, or dword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMINSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMINSB:PMINSW.html"
        ]
    },
    "vpminsd": {
        "detail": [
            "Minimum of Packed Signed Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed signed dword or qword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMINSD:PMINSQ.html"
        ]
    },
    "vcvtqq2ps": {
        "detail": [
            "Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Converts packed quadword integers in the source operand (second operand) to packed single-precision floating-point values in the destination operand (first operand).",
            "The source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operation is a YMM/XMM/XMM (lower 64 bits) register conditionally updated with writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTQQ2PS.html"
        ]
    },
    "vpmovqb": {
        "detail": [
            "Down Convert QWord to Byte"
        ],
        "documentation": [
            "VPMOVQB down converts 64-bit integer elements in the source operand (the second operand) into packed byte elements using truncation. VPMOVSQB converts signed 64-bit integers into packed signed bytes using signed saturation. VPMOVUSQB convert unsigned quad-word values into unsigned byte values using unsigned saturation. The source operand is a vector register. The destination operand is an XMM register or a memory location.",
            "Down-converted byte elements are written to the destination operand (the first operand) from the least-significant byte. Byte elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:64) of the destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.z",
            "mem.q, reg.q, reg.z",
            "mem.q, reg.z",
            "reg.x, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVQB:VPMOVSQB:VPMOVUSQB.html"
        ]
    },
    "vpextrw": {
        "detail": [
            "Extract Word"
        ],
        "documentation": [
            "Copies the word in the source operand (second operand) specified by the count operand (third operand) to the destination operand (first operand). The source operand can be an MMX technology register or an XMM register. The destination operand can be the low word of a general-purpose register or a 16-bit memory address. The count operand is an 8-bit immediate. When specifying a word location in an MMX technology register, the 2 least-significant bits of the count operand specify the location; for an XMM register, the 3 least-significant bits specify the location. The content of the destination register above bit 16 is cleared (set to all 0s).",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15, R8-15). If the destination operand is a general-purpose register, the default operand size is 64-bits in 64-bit mode.",
            "Note: In VEX.128 encoded versions, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD. In EVEX.128 encoded versions, EVEX.vvvv is reserved and must be 1111b, EVEX.L must be 0, otherwise the instruction will #UD. If the destination operand is a register, the default operand size in 64-bit mode for VPEXTRW is 64 bits, the bits above the least significant byte/word/dword data are filled with zeros.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.d, reg.x, imm.b",
            "mem.w, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PEXTRW.html"
        ]
    },
    "vpmovqd": {
        "detail": [
            "Down Convert QWord to DWord"
        ],
        "documentation": [
            "VPMOVQW down converts 64-bit integer elements in the source operand (the second operand) into packed double-words using truncation. VPMOVSQW converts signed 64-bit integers into packed signed doublewords using signed saturation. VPMOVUSQW convert unsigned quad-word values into unsigned double-word values using unsigned saturation.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a YMM/XMM/XMM register or a 256/128/64-bit memory location.",
            "Down-converted doubleword elements are written to the destination operand (the first operand) from the least-significant doubleword. Doubleword elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:256/128/64) of the register destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.y, reg.z",
            "mem.y, reg.q, reg.z",
            "mem.y, reg.z",
            "reg.y, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVQD:VPMOVSQD:VPMOVUSQD.html"
        ]
    },
    "aesenc128kl": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.xy"
        ],
        "url": [
            "https://"
        ]
    },
    "knotw": {
        "detail": [
            "NOT Mask Register"
        ],
        "documentation": [
            "Performs a bitwise NOT of vector mask k2 and writes the result into vector mask k1.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KNOTW:KNOTB:KNOTQ:KNOTD.html"
        ]
    },
    "vpsrad": {
        "detail": [
            "Shift Packed Data Right Arithmetic"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords or quadwords) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element. If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), each destination data element is filled with the initial value of the sign bit of the element. (Figure 4-18 gives an example of shifting words in a 64-bit operand.)",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.z, reg.q, reg.z, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html"
        ]
    },
    "vscatterpf0dpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint with Intent to Write"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "cache lines will be brought into exclusive state (RFO) specified by a locality hint (T0):"
        ],
        "operands": [
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCATTERPF0DPS:VSCATTERPF0QPS:VSCATTERPF0DPD:VSCATTERPF0QPD.html"
        ]
    },
    "vrsqrt28ss": {
        "detail": [
            "Approximation to the Reciprocal Square Root of Scalar Single-Precision Floating- Point Value with Less Than 2^-28 Relative Error"
        ],
        "documentation": [
            "Computes the reciprocal square root of the low float32 value in the second source operand (the third operand) and store the result to the destination operand (the first operand). The approximate reciprocal square root is evaluated with less than 2^-28 of maximum relative error prior to final rounding. The final result is rounded to < 2^-23 relative error before written to the low float32 element of the destination according to the writemask k1. Bits 127:32 of the destination is copied from the corresponding bits of the first source operand (the second operand).",
            "If any source element is NaN, the quietized NaN source value is returned for that element. Negative (non-zero) source numbers, as well as -∞, return the canonical NaN and set the Invalid Flag (#I).",
            "A value of -0 must return -∞ and set the DivByZero flags (#Z). Negative numbers should return NaN and set the Invalid flag (#I). Note however that the instruction flush input denormals to zero of the same sign, so negative denormals return -∞ and set the DivByZero flag.",
            "The first source operand is an XMM register. The second source operand is an XMM register or a 32-bit memory location. The destination operand is a XMM register."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRSQRT28SS.html"
        ]
    },
    "vpsraq": {
        "detail": [
            "Shift Packed Data Right Arithmetic"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords or quadwords) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element. If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), each destination data element is filled with the initial value of the sign bit of the element. (Figure 4-18 gives an example of shifting words in a 64-bit operand.)",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, reg.x",
            "reg.z, reg.z, mem.x",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html"
        ]
    },
    "pmaxub": {
        "detail": [
            "Maximum of Packed Unsigned Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed unsigned byte, word integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMAXUB: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMAXUB:PMAXUW.html"
        ]
    },
    "pfrsqit1": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vpminsq": {
        "detail": [
            "Minimum of Packed Signed Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed signed dword or qword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMINSD:PMINSQ.html"
        ]
    },
    "knotq": {
        "detail": [
            "NOT Mask Register"
        ],
        "documentation": [
            "Performs a bitwise NOT of vector mask k2 and writes the result into vector mask k1.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/KNOTW:KNOTB:KNOTQ:KNOTD.html"
        ]
    },
    "vpsraw": {
        "detail": [
            "Shift Packed Data Right Arithmetic"
        ],
        "documentation": [
            "Shifts the bits in the individual data elements (words, doublewords or quadwords) in the destination operand (first operand) to the right by the number of bits specified in the count operand (second operand). As the bits in the data elements are shifted right, the empty high-order bits are filled with the initial value of the sign bit of the data element. If the value specified by the count operand is greater than 15 (for words), 31 (for doublewords), or 63 (for quadwords), each destination data element is filled with the initial value of the sign bit of the element. (Figure 4-18 gives an example of shifting words in a 64-bit operand.)",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, mem.x, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.x, reg.q, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html"
        ]
    },
    "vpmadd52huq": {
        "detail": [
            "Packed Multiply of Unsigned 52-bit Unsigned Integers and Add High 52-bit Products to 64-bit Accumulators"
        ],
        "documentation": [
            "Multiplies packed unsigned 52-bit integers in each qword element of the first source operand (the second operand) with the packed unsigned 52-bit integers in the corresponding elements of the second source operand (the third operand) to form packed 104-bit intermediate results. The high 52-bit, unsigned integer of each 104-bit product is added to the corresponding qword unsigned integer of the destination operand (the first operand) under the writemask k1.",
            "The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 64-bit granularity.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMADD52HUQ.html"
        ]
    },
    "vpminsw": {
        "detail": [
            "Minimum of Packed Signed Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed signed byte, word, or dword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMINSW: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMINSB:PMINSW.html"
        ]
    },
    "vscatterpf0dps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint with Intent to Write"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "cache lines will be brought into exclusive state (RFO) specified by a locality hint (T0):"
        ],
        "operands": [
            "mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCATTERPF0DPS:VSCATTERPF0QPS:VSCATTERPF0DPD:VSCATTERPF0QPD.html"
        ]
    },
    "vpmovqw": {
        "detail": [
            "Down Convert QWord to Word"
        ],
        "documentation": [
            "VPMOVQW down converts 64-bit integer elements in the source operand (the second operand) into packed words using truncation. VPMOVSQW converts signed 64-bit integers into packed signed words using signed saturation. VPMOVUSQW convert unsigned quad-word values into unsigned word values using unsigned saturation.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a XMM register or a 128/64/32-bit memory location.",
            "Down-converted word elements are written to the destination operand (the first operand) from the least-significant word. Word elements of the destination operand are updated according to the writemask. Bits (MAXVL-1:128/64/32) of the register destination are zeroed.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, reg.z",
            "mem.x, reg.q, reg.z",
            "mem.x, reg.z",
            "reg.x, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVQW:VPMOVSQW:VPMOVUSQW.html"
        ]
    },
    "pmaxuw": {
        "detail": [
            "Maximum of Packed Unsigned Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed unsigned byte, word integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMAXUB: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMAXUB:PMAXUW.html"
        ]
    },
    "rcpss": {
        "detail": [
            "Compute Reciprocal of Scalar Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Computes of an approximate reciprocal of the low single-precision floating-point value in the source operand (second operand) and stores the single-precision floating-point result in the destination operand. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register. The three high-order doublewords of the destination operand remain unchanged. See Figure 10-6 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for an illustration of a scalar single-precision floating-point operation.",
            "The relative error for this approximation is:",
            "|Relative Error| ≤ 1.5 ∗ 2−12",
            "The RCPSS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ of the sign of the source value is returned. A denormal source value is treated as a 0.0 (of the same sign). Tiny results (see Section 4.9.1.5, “Numeric Underflow Exception (#U)” in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1) are always flushed to 0.0, with the sign of the operand. (Input values greater than or equal to |1.11111111110100000000000B∗2125| are guaranteed to not produce tiny results; input values less than or equal to |1.00000000000110000000001B*2126| are guaranteed to produce tiny results, which are in turn flushed to 0.0; and input values in between this range may or may not produce tiny results, depending on the implementation.) When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.",
            "In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same. Bits (MAXVL-1:32) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/RCPSS.html"
        ]
    },
    "cdq": {
        "detail": [
            "Convert Word to Doubleword/Convert Doubleword to Quadword"
        ],
        "documentation": [
            "Doubles the size of the operand in register AX, EAX, or RAX (depending on the operand size) by means of sign extension and stores the result in registers DX:AX, EDX:EAX, or RDX:RAX, respectively. The CWD instruction copies the sign (bit 15) of the value in the AX register into every bit position in the DX register. The CDQ instruction copies the sign (bit 31) of the value in the EAX register into every bit position in the EDX register. The CQO instruction (available in 64-bit mode only) copies the sign (bit 63) of the value in the RAX register into every bit position in the RDX register.",
            "The CWD instruction can be used to produce a doubleword dividend from a word before word division. The CDQ instruction can be used to produce a quadword dividend from a doubleword before doubleword division. The CQO instruction can be used to produce a double quadword dividend from a quadword before a quadword division.",
            "The CWD and CDQ mnemonics reference the same opcode. The CWD instruction is intended for use when the operand-size attribute is 16 and the CDQ instruction for when the operand-size attribute is 32. Some assemblers may force the operand size to 16 when CWD is used and to 32 when CDQ is used. Others may treat these mnemonics as synonyms (CWD/CDQ) and use the current setting of the operand-size attribute to determine the size of values to be converted, regardless of the mnemonic used.",
            "In 64-bit mode, use of the REX.W prefix promotes operation to 64 bits. The CQO mnemonics reference the same opcode as CWD/CDQ. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/CWD:CDQ:CQO.html"
        ]
    },
    "pmaxud": {
        "detail": [
            "Maximum of Packed Unsigned Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed unsigned dword or qword integers in the second source operand and the first source operand and returns the maximum value for each pair of integers to the destination operand.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register; The second source operand is a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMAXUD:PMAXUQ.html"
        ]
    },
    "leavew": {
        "detail": [
            "High Level Procedure Exit"
        ],
        "documentation": [
            "Releases the stack frame set up by an earlier ENTER instruction. The LEAVE instruction copies the frame pointer (in the EBP register) into the stack pointer register (ESP), which releases the stack space allocated to the stack frame. The old frame pointer (the frame pointer for the calling procedure that was saved by the ENTER instruction) is then popped from the stack into the EBP register, restoring the calling procedure’s stack frame.",
            "A RET instruction is commonly executed following a LEAVE instruction to return program control to the calling procedure.",
            "See “Procedure Calls for Block-Structured Languages” in Chapter 7 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for detailed information on the use of the ENTER and LEAVE instructions.",
            "In 64-bit mode, the instruction’s default operation size is 64 bits; 32-bit operation cannot be encoded. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "mem.w, reg.w, reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/LEAVE.html"
        ]
    },
    "shrd": {
        "detail": [
            "Double Precision Shift Right"
        ],
        "documentation": [
            "The SHRD instruction is useful for multi-precision shifts of 64 bits or more.",
            "The instruction shifts the first operand (destination operand) to the right the number of bits specified by the third operand (count operand). The second operand (source operand) provides bits to shift in from the left (starting with the most significant bit of the destination operand).",
            "The destination operand can be a register or a memory location; the source operand is a register. The count operand is an unsigned integer that can be stored in an immediate byte or the CL register. If the count operand is CL, the shift count is the logical AND of CL and a count mask. In non-64-bit modes and default 64-bit mode, the width of the count mask is 5 bits. Only bits 0 through 4 of the count register are used (masking the count to a value between 0 and 31). If the count is greater than the operand size, the result is undefined.",
            "If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. If the count operand is 0, flags are not affected.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits (upgrading the count mask to 6 bits). See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "If the count is 1 or greater, the CF flag is filled with the last bit shifted out of the destination operand and the SF, ZF, and PF flags are set according to the value of the result. For a 1-bit shift, the OF flag is set if a sign change occurred; otherwise, it is cleared. For shifts greater than 1 bit, the OF flag is undefined. If a shift occurs, the AF flag is undefined. If the count operand is 0, the flags are not affected. If the count is greater than the operand size, the flags are undefined."
        ],
        "operands": [
            "reg.w, reg.w, imm.b",
            "reg.w, reg.w, imm.b",
            "mem.w, reg.w, imm.b",
            "reg.w, reg.w, reg",
            "mem.w, reg.w, reg",
            "mem.w, reg.w, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/SHRD.html"
        ]
    },
    "vcvtss2sd": {
        "detail": [
            "Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Converts a single-precision floating-point value in the “convert-from” source operand to a double-precision floating-point value in the destination operand. When the “convert-from” source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register. The result is stored in the low quadword of the destination operand.",
            "128-bit Legacy SSE version: The “convert-from” source operand (the second operand) is an XMM register or memory location. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged. The destination operand is an XMM register.",
            "VEX.128 and EVEX encoded versions: The “convert-from” source operand (the third operand) can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers. Bits (127:64) of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "Software should ensure VCVTSS2SD is encoded with VEX.L=0. Encoding VCVTSS2SD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTSS2SD.html"
        ]
    },
    "rdfsbase": {
        "detail": [
            "Read FS/GS Segment Base"
        ],
        "documentation": [
            "Loads the general-purpose register indicated by the modR/M:r/m field with the FS or GS segment base address.",
            "The destination operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source base address (for FS or GS) are ignored and upper 32 bits of the destination register are cleared.",
            "This instruction is supported only in 64-bit mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/RDFSBASE:RDGSBASE.html"
        ]
    },
    "vcvtss2si": {
        "detail": [
            "Convert Scalar Single-Precision Floating-Point Value to Doubleword Integer"
        ],
        "documentation": [
            "Converts a single-precision floating-point value in the source operand (the second operand) to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand). The source operand can be an XMM register or a memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.",
            "Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to produce 64-bit data. See the summary chart at the beginning of this section for encoding data and limits.",
            "VEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCVTSS2SI is encoded with VEX.L=0. Encoding VCVTSS2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTSS2SI.html"
        ]
    },
    "invpcid": {
        "detail": [
            "Invalidate Process-Context Identifier"
        ],
        "documentation": [
            "Invalidates mappings in the translation lookaside buffers (TLBs) and paging-structure caches based on process-context identifier (PCID). (See Section 4.10, “Caching Translation Information,” in Intel 64 and IA-32 Architecture Software Developer’s Manual, Volume 3A.) Invalidation is based on the INVPCID type specified in the register operand and the INVPCID descriptor specified in the memory operand.",
            "Outside 64-bit mode, the register operand is always 32 bits, regardless of the value of CS.D. In 64-bit mode the register operand has 64 bits.",
            "There are four INVPCID types currently defined:"
        ],
        "operands": [
            "reg.q, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/INVPCID.html"
        ]
    },
    "vexpandpd": {
        "detail": [
            "Load Sparse Packed Double-Precision Floating-Point Values from Dense Memory"
        ],
        "documentation": [
            "Expand (load) up to 8/4/2, contiguous, double-precision floating-point values of the input vector in the source operand (the second operand) to sparse elements in the destination operand (the first operand) selected by the writemask k1.",
            "The destination operand is a ZMM/YMM/XMM register, the source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.",
            "The input vector starts from the lowest element in the source operand. The writemask register k1 selects the destination elements (a partial vector or sparse elements if less than 8 elements) to be replaced by the ascending elements in the input vector. Destination elements not selected by the writemask k1 are either unmodified or zeroed, depending on EVEX.z.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VEXPANDPD.html"
        ]
    },
    "shrx": {
        "detail": [
            "Shift Without Affecting Flags"
        ],
        "documentation": [
            "Shifts the bits of the first source operand (the second operand) to the left or right by a COUNT value specified in the second source operand (the third operand). The result is written to the destination operand (the first operand).",
            "The shift arithmetic right (SARX) and shift logical right (SHRX) instructions shift the bits of the destination operand to the right (toward less significant bit locations), SARX keeps and propagates the most significant bit (sign bit) while shifting.",
            "The logical shift left (SHLX) shifts the bits of the destination operand to the left (toward more significant bit locations).",
            "This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.",
            "If the value specified in the first source operand exceeds OperandSize -1, the COUNT value is masked.",
            "SARX,SHRX, and SHLX instructions do not update flags.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.d, reg.d, reg.d",
            "reg.d, mem.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/SARX:SHLX:SHRX.html"
        ]
    },
    "vplzcntd": {
        "detail": [
            "Count the Number of Leading Zero Bits for Packed Dword, Packed Qword Values"
        ],
        "documentation": [
            "Counts the number of leading most significant zero bits in each dword or qword element of the source operand (the second operand) and stores the results in the destination register (the first operand) according to the writemask. If an element is zero, the result for that element is the operand size of the element.",
            "EVEX.512 encoded version: The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.",
            "EVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPLZCNTD:VPLZCNTQ.html"
        ]
    },
    "vmovhlps": {
        "detail": [
            "Move Packed Single-Precision Floating-Point Values High to Low"
        ],
        "documentation": [
            "This instruction cannot be used for memory to register moves.",
            "128-bit two-argument form:",
            "Moves two packed single-precision floating-point values from the high quadword of the second XMM argument (second operand) to the low quadword of the first XMM register (first argument). The quadword at bits 127:64 of the destination operand is left unchanged. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "128-bit and EVEX three-argument form",
            "Moves two packed single-precision floating-point values from the high quadword of the third XMM argument (third operand) to the low quadword of the destination (first operand). Copies the high quadword from the second XMM argument (second operand) to the high quadword of the destination (first operand). Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "If VMOVHLPS is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVHLPS.html"
        ]
    },
    "vcvttps2qq": {
        "detail": [
            "Convert with Truncation Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values"
        ],
        "documentation": [
            "Converts with truncation packed single-precision floating-point values in the source operand to eight signed quadword integers in the destination operand.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.",
            "EVEX encoded versions: The source operand is a YMM/XMM/XMM (low 64 bits) register or a 256/128/64-bit memory location. The destination operation is a vector register conditionally updated with writemask k1.",
            "Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.q",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.q",
            "reg.x, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTTPS2QQ.html"
        ]
    },
    "vphaddd": {
        "detail": [
            "Packed Horizontal Add"
        ],
        "documentation": [
            "(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and packs the 16-bit signed results to the destination operand (first operand). (V)PHADDD adds two adjacent 32-bit signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Note that these instructions can operate on either unsigned or signed (two’s complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.",
            "Legacy SSE instructions: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "In 64-bit mode, use the REX prefix to access additional registers.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: Horizontal addition of two adjacent data elements of the low 16-bytes of the first and second source operands are packed into the low 16-bytes of the destination operand. Horizontal addition of two adjacent data elements of the high 16-bytes of the first and second source operands are packed into the high 16-bytes of the destination operand. The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.",
            "Note: VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PHADDW:PHADDD.html"
        ]
    },
    "vexpandps": {
        "detail": [
            "Load Sparse Packed Single-Precision Floating-Point Values from Dense Memory"
        ],
        "documentation": [
            "Expand (load) up to 16/8/4, contiguous, single-precision floating-point values of the input vector in the source operand (the second operand) to sparse elements of the destination operand (the first operand) selected by the writemask k1.",
            "The destination operand is a ZMM/YMM/XMM register, the source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location.",
            "The input vector starts from the lowest element in the source operand. The writemask k1 selects the destination elements (a partial vector or sparse elements if less than 16 elements) to be replaced by the ascending elements in the input vector. Destination elements not selected by the writemask k1 are either unmodified or zeroed, depending on EVEX.z.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD.",
            "Note that the compressed displacement assumes a pre-scaling (N) corresponding to the size of one single element instead of the size of the full vector."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VEXPANDPS.html"
        ]
    },
    "vpmadcswd": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "vplzcntq": {
        "detail": [
            "Count the Number of Leading Zero Bits for Packed Dword, Packed Qword Values"
        ],
        "documentation": [
            "Counts the number of leading most significant zero bits in each dword or qword element of the source operand (the second operand) and stores the results in the destination register (the first operand) according to the writemask. If an element is zero, the result for that element is the operand size of the element.",
            "EVEX.512 encoded version: The source operand is a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.",
            "EVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPLZCNTD:VPLZCNTQ.html"
        ]
    },
    "xgetbv": {
        "detail": [
            "Get Value of Extended Control Register"
        ],
        "documentation": [
            "Reads the contents of the extended control register (XCR) specified in the ECX register into registers EDX:EAX. (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) The EDX register is loaded with the high-order 32 bits of the XCR and the EAX register is loaded with the low-order 32 bits. (On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX and RDX are cleared.) If fewer than 64 bits are implemented in the XCR being read, the values returned to EDX:EAX in unimplemented bit locations are undefined.",
            "XCR0 is supported on any processor that supports the XGETBV instruction. If CPUID.(EAX=0DH,ECX=1):EAX.XG1[bit 2] = 1, executing XGETBV with ECX = 1 returns in EDX:EAX the logicalAND of XCR0 and the current value of the XINUSE state-component bitmap. This allows software to discover the state of the init optimization used by XSAVEOPT and XSAVES. See Chapter 13, “Managing State Using the XSAVE Feature Set‚” in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Use of any other value for ECX results in a general-protection (#GP) exception.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg, reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XGETBV.html"
        ]
    },
    "seamret": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "vphaddw": {
        "detail": [
            "Packed Horizontal Add"
        ],
        "documentation": [
            "(V)PHADDW adds two adjacent 16-bit signed integers horizontally from the source and destination operands and packs the 16-bit signed results to the destination operand (first operand). (V)PHADDD adds two adjacent 32-bit signed integers horizontally from the source and destination operands and packs the 32-bit signed results to the destination operand (first operand). When the source operand is a 128-bit memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.",
            "Note that these instructions can operate on either unsigned or signed (two’s complement notation) integers; however, it does not set bits in the EFLAGS register to indicate overflow and/or a carry. To prevent undetected overflow conditions, software must control the ranges of the values operated on.",
            "Legacy SSE instructions: Both operands can be MMX registers. The second source operand can be an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "In 64-bit mode, use the REX prefix to access additional registers.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM register are zeroed.",
            "VEX.256 encoded version: Horizontal addition of two adjacent data elements of the low 16-bytes of the first and second source operands are packed into the low 16-bytes of the destination operand. Horizontal addition of two adjacent data elements of the high 16-bytes of the first and second source operands are packed into the high 16-bytes of the destination operand. The first source and destination operands are YMM registers. The second source operand can be an YMM register or a 256-bit memory location.",
            "Note: VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PHADDW:PHADDD.html"
        ]
    },
    "movntdq": {
        "detail": [
            "Store Packed Integers Using Non-Temporal Hint"
        ],
        "documentation": [
            "Moves the packed integers in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register, YMM register or ZMM register, which is assumed to contain integer data (packed bytes, words, double-words, or quadwords). The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (512-bit version) boundary otherwise a general-protection exception (#GP) will be generated.",
            "The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the IA-32 Intel Architecture Software Developer’s Manual, Volume 1.",
            "Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with VMOVNTDQ instructions if multiple processors might use different memory types to read/write the destination memory locations.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, VEX.L must be 0; otherwise instructions will #UD."
        ],
        "operands": [
            "mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVNTDQ.html"
        ]
    },
    "vdbpsadbw": {
        "detail": [
            "Double Block Packed Sum-Absolute-Differences (SAD) on Unsigned Bytes"
        ],
        "documentation": [
            "Compute packed SAD (sum of absolute differences) word results of unsigned bytes from two 32-bit dword elements. Packed SAD word results are calculated in multiples of qword superblocks, producing 4 SAD word results in each 64-bit superblock of the destination register.",
            "Within each super block of packed word results, the SAD results from two 32-bit dword elements are calculated as follows:"
        ],
        "operands": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VDBPSADBW.html"
        ]
    },
    "pand": {
        "detail": [
            "Logical AND"
        ],
        "documentation": [
            "Performs a bitwise logical AND operation on the first source operand and second source operand and stores the result in the destination operand. Each bit of the result is set to 1 if the corresponding bits of the first and second operands are 1, otherwise it is set to 0.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source operand is an XMM register. The second operand can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1 at 32/64-bit granularity.",
            "VEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/PAND.html"
        ]
    },
    "vrsqrt14pd": {
        "detail": [
            "Compute Approximate Reciprocals of Square Roots of Packed Float64 Values"
        ],
        "documentation": [
            "This instruction performs a SIMD computation of the approximate reciprocals of the square roots of the eight packed double-precision floating-point values in the source operand (the second operand) and stores the packed double-precision floating-point results in the destination operand (the first operand) according to the writemask. The maximum relative error for this approximation is less than 2-14.",
            "EVEX.512 encoded version: The source operand can be a ZMM register, a 512-bit memory location, or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 64-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.",
            "EVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 64-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.",
            "The VRSQRT14PD instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ with the sign of the source value is returned. When the source operand is an +∞ then +ZERO value is returned. A denormal source value is treated as zero only if DAZ bit is set in MXCSR. Otherwise it is treated correctly and performs the approximation with the specified masked response. When a source value is a negative value (other than 0.0) a floating-point QNaN_indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.",
            "MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported.",
            "Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRSQRT14PD.html"
        ]
    },
    "fld": {
        "detail": [
            "Load Floating Point Value"
        ],
        "documentation": [
            "Pushes the source operand onto the FPU register stack. The source operand can be in single-precision, double-precision, or double extended-precision floating-point format. If the source operand is in single-precision or double-precision floating-point format, it is automatically converted to the double extended-precision floating-point format before being pushed on the stack.",
            "The FLD instruction can also push the value in a selected FPU register [ST(i)] onto the stack. Here, pushing register ST(0) duplicates the stack top.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg",
            "reg.wq, mem.d, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FLD.html"
        ]
    },
    "vinsertf128": {
        "detail": [
            "Insert Packed Floating-Point Values"
        ],
        "documentation": [
            "VINSERTF128/VINSERTF32x4 and VINSERTF64x2 insert 128-bits of packed floating-point values from the second source operand (the third operand) into the destination operand (the first operand) at an 128-bit granularity offset multiplied by imm8[0] (256-bit) or imm8[1:0]. The remaining portions of the destination operand are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an XMM register or a 128-bit memory location. The destination and first source operands are vector registers.",
            "VINSERTF32x4: The destination operand is a ZMM/YMM register and updated at 32-bit granularity according to the writemask. The high 6/7 bits of the immediate are ignored.",
            "VINSERTF64x2: The destination operand is a ZMM/YMM register and updated at 64-bit granularity according to the writemask. The high 6/7 bits of the immediate are ignored.",
            "VINSERTF32x8 and VINSERTF64x4 inserts 256-bits of packed floating-point values from the second source operand (the third operand) into the destination operand (the first operand) at a 256-bit granular offset multiplied by imm8[0]. The remaining portions of the destination are copied from the corresponding fields of the first source operand (the second operand). The second source operand can be either an YMM register or a 256-bit memory location. The high 7 bits of the immediate are ignored. The destination operand is a ZMM register and updated at 32/64-bit granularity according to the writemask."
        ],
        "operands": [
            "reg.y, reg.y, mem.x, imm.b",
            "reg.y, reg.y, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html"
        ]
    },
    "fxrstor": {
        "detail": [
            "Restore x87 FPU, MMX, XMM, and MXCSR State"
        ],
        "documentation": [
            "Reloads the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte memory image specified in the source operand. This data should have been written to memory previously using the FXSAVE instruction, and in the same format as required by the operating modes. The first byte of the data should be located on a 16-byte boundary. There are three distinct layouts of the FXSAVE state map: one for legacy and compatibility mode, a second format for 64-bit mode FXSAVE/FXRSTOR with REX.W=0, and the third format is for 64-bit mode with FXSAVE64/FXRSTOR64. Table 3-43 shows the layout of the legacy/compatibility mode state information in memory and describes the fields in the memory image for the FXRSTOR and FXSAVE instructions. Table 3-46 shows the layout of the 64-bit mode state information when REX.W is set (FXSAVE64/FXRSTOR64). Table 3-47 shows the layout of the 64-bit mode state information when REX.W is clear (FXSAVE/FXRSTOR).",
            "The state image referenced with an FXRSTOR instruction must have been saved using an FXSAVE instruction or be in the same format as required by Table 3-43, Table 3-46, or Table 3-47. Referencing a state image saved with an FSAVE, FNSAVE instruction or incompatible field layout will result in an incorrect state restoration.",
            "The FXRSTOR instruction does not flush pending x87 FPU exceptions. To check and raise exceptions when loading x87 FPU state information with the FXRSTOR instruction, use an FWAIT instruction after the FXRSTOR instruction.",
            "If the OSFXSR bit in control register CR4 is not set, the FXRSTOR instruction may not restore the states of the XMM and MXCSR registers. This behavior is implementation dependent.",
            "If the MXCSR state contains an unmasked exception with a corresponding status flag also set, loading the register with the FXRSTOR instruction will not result in a SIMD floating-point error condition being generated. Only the next occurrence of this unmasked exception will result in the exception being generated.",
            "Bits 16 through 32 of the MXCSR register are defined as reserved and should be set to 0. Attempting to write a 1 in any of these bits from the saved state image will result in a general protection exception (#GP) being generated.",
            "Bytes 464:511 of an FXSAVE image are available for software use. FXRSTOR ignores the content of bytes 464:511 in an FXSAVE state image."
        ],
        "operands": [
            "mem.[4096], reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FXRSTOR.html"
        ]
    },
    "vpminub": {
        "detail": [
            "Minimum of Packed Unsigned Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed unsigned byte or word integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMINUB: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMINUB:PMINUW.html"
        ]
    },
    "vpminud": {
        "detail": [
            "Minimum of Packed Unsigned Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed unsigned dword/qword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMINUD:PMINUQ.html"
        ]
    },
    "vpmulhuw": {
        "detail": [
            "Multiply Packed Unsigned Integers and Store High Result"
        ],
        "documentation": [
            "Performs a SIMD unsigned multiply of the packed unsigned word integers in the destination operand (first operand) and the source operand (second operand), and stores the high 16 bits of each 32-bit intermediate results in the destination operand. (Figure 4-12 shows this operation when using 64-bit operands.)",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed. VEX.L must be 0, otherwise the instruction will #UD.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMULHUW.html"
        ]
    },
    "dppd": {
        "detail": [
            "Dot Product of Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Conditionally multiplies the packed double-precision floating-point values in the destination operand (first operand) with the packed double-precision floating-point values in the source (second operand) depending on a mask extracted from bits [5:4] of the immediate operand (third operand). If a condition mask bit is zero, the corresponding multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "The two resulting double-precision values are summed into an intermediate result. The intermediate result is conditionally broadcasted to the destination using a broadcast mask specified by bits [1:0] of the immediate byte.",
            "If a broadcast mask bit is “1”, the intermediate result is copied to the corresponding qword element in the destination operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.",
            "DPPD follows the NaN forwarding rules stated in the Software Developer’s Manual, vol. 1, table 4-7. These rules do not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally generated NaNs will have at least one NaN propagated to the destination.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "If VDPPD is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/DPPD.html"
        ]
    },
    "vrsqrt14ps": {
        "detail": [
            "Compute Approximate Reciprocals of Square Roots of Packed Float32 Values"
        ],
        "documentation": [
            "This instruction performs a SIMD computation of the approximate reciprocals of the square roots of 16 packed single-precision floating-point values in the source operand (the second operand) and stores the packed single-precision floating-point results in the destination operand (the first operand) according to the writemask. The maximum relative error for this approximation is less than 2-14.",
            "EVEX.512 encoded version: The source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM register, conditionally updated using writemask k1.",
            "EVEX.256 encoded version: The source operand is a YMM register, a 256-bit memory location, or a 256-bit vector broadcasted from a 32-bit memory location. The destination operand is a YMM register, conditionally updated using writemask k1.",
            "EVEX.128 encoded version: The source operand is a XMM register, a 128-bit memory location, or a 128-bit vector broadcasted from a 32-bit memory location. The destination operand is a XMM register, conditionally updated using writemask k1.",
            "The VRSQRT14PS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ with the sign of the source value is returned. When the source operand is an +∞ then +ZERO value is returned. A denormal source value is treated as zero only if DAZ bit is set in MXCSR. Otherwise it is treated correctly and performs the approximation with the specified masked response. When a source value is a negative value (other than 0.0) a floating-point QNaN_indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.",
            "MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported.",
            "Note: EVEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRSQRT14PS.html"
        ]
    },
    "repe outsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.b, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "repe outsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vfmaddsub231pd": {
        "detail": [
            "Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFMADDSUB132PD: Multiplies the two, four, or eight packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the even double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMADDSUB213PD: Multiplies the two, four, or eight packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the first source operand. From the infinite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the even double-precision floating-point values in the third source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMADDSUB231PD: Multiplies the two, four, or eight packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the even double-precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADDSUB132PD:VFMADDSUB213PD:VFMADDSUB231PD.html"
        ]
    },
    "vpminuq": {
        "detail": [
            "Minimum of Packed Unsigned Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed unsigned dword/qword integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers. Bits (MAXVL-1:256) of the corresponding destination register are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMINUD:PMINUQ.html"
        ]
    },
    "valignd": {
        "detail": [
            "Align Doubleword/Quadword Vectors"
        ],
        "documentation": [
            "Concatenates and shifts right doubleword/quadword elements of the first source operand (the second operand) and the second source operand (the third operand) into a 1024/512/256-bit intermediate vector. The low 512/256/128-bit of the intermediate vector is written to the destination operand (the first operand) using the writemask k1. The destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location.",
            "This instruction is writemasked, so only those elements with the corresponding bit set in vector mask register k1 are computed and stored into zmm1. Elements in zmm1 with the corresponding bit clear in k1 retain their previous values (merging-masking) or are set to 0 (zeroing-masking)."
        ],
        "operands": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VALIGND:VALIGNQ.html"
        ]
    },
    "dpps": {
        "detail": [
            "Dot Product of Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Conditionally multiplies the packed single precision floating-point values in the destination operand (first operand) with the packed single-precision floats in the source (second operand) depending on a mask extracted from the high 4 bits of the immediate byte (third operand). If a condition mask bit in Imm8[7:4] is zero, the corresponding multiplication is replaced by a value of 0.0 in the manner described by Section 12.8.4 of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "The four resulting single-precision values are summed into an intermediate result. The intermediate result is conditionally broadcasted to the destination using a broadcast mask specified by bits [3:0] of the immediate byte.",
            "If a broadcast mask bit is “1”, the intermediate result is copied to the corresponding dword element in the destination operand. If a broadcast mask bit is zero, the corresponding element in the destination is set to zero.",
            "DPPS follows the NaN forwarding rules stated in the Software Developer’s Manual, vol. 1, table 4-7. These rules do not cover horizontal prioritization of NaNs. Horizontal propagation of NaNs to the destination and the positioning of those NaNs in the destination is implementation dependent. NaNs on the input sources or computationally generated NaNs will have at least one NaN propagated to the destination.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.",
            "VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/DPPS.html"
        ]
    },
    "vpminuw": {
        "detail": [
            "Minimum of Packed Unsigned Integers"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed unsigned byte or word integers in the second source operand and the first source operand and returns the minimum value for each pair of integers to the destination operand.",
            "Legacy SSE version PMINUB: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand can be an MMX technology register.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register; The second source operand is a ZMM/YMM/XMM register or a 512/256/128-bit memory location. The destination operand is conditionally updated based on writemask k1."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMINUB:PMINUW.html"
        ]
    },
    "repe xcryptcfb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "mem.b, reg, reg.d, reg, reg.q, mem.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "vcvttps2udq": {
        "detail": [
            "Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values"
        ],
        "documentation": [
            "Converts with truncation packed single-precision floating-point values in the source operand to sixteen unsigned doubleword integers in the destination operand.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w – 1 is returned, where w represents the number of bits in the destination format.",
            "EVEX encoded versions: The source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Note: EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTTPS2UDQ.html"
        ]
    },
    "vmsave": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "vfmaddsub231ps": {
        "detail": [
            "Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFMADDSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the corresponding packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and subtracts the even single-precision floating-point values in the second source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMADDSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the corresponding packed single-precision floating-point values in the first source operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and subtracts the even single-precision floating-point values in the third source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMADDSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the corresponding packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and subtracts the even single-precision floating-point values in the first source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADDSUB132PS:VFMADDSUB213PS:VFMADDSUB231PS.html"
        ]
    },
    "valignq": {
        "detail": [
            "Align Doubleword/Quadword Vectors"
        ],
        "documentation": [
            "Concatenates and shifts right doubleword/quadword elements of the first source operand (the second operand) and the second source operand (the third operand) into a 1024/512/256-bit intermediate vector. The low 512/256/128-bit of the intermediate vector is written to the destination operand (the first operand) using the writemask k1. The destination and first source operands are ZMM/YMM/XMM registers. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location.",
            "This instruction is writemasked, so only those elements with the corresponding bit set in vector mask register k1 are computed and stored into zmm1. Elements in zmm1 with the corresponding bit clear in k1 retain their previous values (merging-masking) or are set to 0 (zeroing-masking)."
        ],
        "operands": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/VALIGND:VALIGNQ.html"
        ]
    },
    "repe outsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "documentation": [
            "Repeats a string instruction the number of times specified in the count register or until the indicated condition of the ZF flag is no longer met. The REP (repeat), REPE (repeat while equal), REPNE (repeat while not equal), REPZ (repeat while zero), and REPNZ (repeat while not zero) mnemonics are prefixes that can be added to one of the string instructions. The REP prefix can be added to the INS, OUTS, MOVS, LODS, and STOS instructions, and the REPE, REPNE, REPZ, and REPNZ prefixes can be added to the CMPS and SCAS instructions. (The REPZ and REPNZ prefixes are synonymous forms of the REPE and REPNE prefixes, respectively.) The F3H prefix is defined for the following instructions and undefined for the rest:",
            "Flags Affected:",
            "None; however, the CMPS and SCAS instructions do set the status flags in the EFLAGS register."
        ],
        "operands": [
            "reg, mem.w, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html"
        ]
    },
    "rdpru": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.d, reg.d"
        ],
        "url": [
            "https://"
        ]
    },
    "punpcklwd": {
        "detail": [
            "Unpack Low Data"
        ],
        "documentation": [
            "Unpacks and interleaves the low-order data elements (bytes, words, doublewords, and quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. (Figure 4-22 shows the unpack operation for bytes in 64-bit operands.). The high-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, mem.d",
            "reg.q, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html"
        ]
    },
    "cvtss2sd": {
        "detail": [
            "Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "Converts a single-precision floating-point value in the “convert-from” source operand to a double-precision floating-point value in the destination operand. When the “convert-from” source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register. The result is stored in the low quadword of the destination operand.",
            "128-bit Legacy SSE version: The “convert-from” source operand (the second operand) is an XMM register or memory location. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged. The destination operand is an XMM register.",
            "VEX.128 and EVEX encoded versions: The “convert-from” source operand (the third operand) can be an XMM register or a 32-bit memory location. The first source and destination operands are XMM registers. Bits (127:64) of the XMM register destination are copied from the corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "Software should ensure VCVTSS2SD is encoded with VEX.L=0. Encoding VCVTSS2SD with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.q, mem.d",
            "reg.q, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTSS2SD.html"
        ]
    },
    "cvtss2si": {
        "detail": [
            "Convert Scalar Single-Precision Floating-Point Value to Doubleword Integer"
        ],
        "documentation": [
            "Converts a single-precision floating-point value in the source operand (the second operand) to a signed doubleword integer (or signed quadword integer if operand size is 64 bits) in the destination operand (the first operand). The source operand can be an XMM register or a memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the single-precision floating-point value is contained in the low doubleword of the register.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (2w-1, where w represents the number of bits in the destination format) is returned.",
            "Legacy SSE instructions: In 64-bit mode, Use of the REX.W prefix promotes the instruction to produce 64-bit data. See the summary chart at the beginning of this section for encoding data and limits.",
            "VEX.W1 and EVEX.W1 versions: promotes the instruction to produce 64-bit data in 64-bit mode.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, otherwise instructions will #UD.",
            "Software should ensure VCVTSS2SI is encoded with VEX.L=0. Encoding VCVTSS2SI with VEX.L=1 may encounter unpredictable behavior across different processor generations."
        ],
        "operands": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTSS2SI.html"
        ]
    },
    "movhpd": {
        "detail": [
            "Move High Packed Double-Precision Floating-Point Value"
        ],
        "documentation": [
            "This instruction cannot be used for register to register or memory to memory moves.",
            "128-bit Legacy SSE load:",
            "Moves a double-precision floating-point value from the source 64-bit memory operand and stores it in the high 64-bits of the destination XMM register. The lower 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.",
            "VEX.128 & EVEX encoded load:",
            "Loads a double-precision floating-point value from the source 64-bit memory operand (the third operand) and stores it in the upper 64-bits of the destination XMM register (first operand). The low 64-bits from the first source operand (second operand) are copied to the low 64-bits of the destination. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "128-bit store:",
            "Stores a double-precision floating-point value from the high 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).",
            "Note: VMOVHPD (store) (VEX.128.66.0F 17 /r) is legal and has the same behavior as the existing 66 0F 17 store. For VMOVHPD (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.",
            "If VMOVHPD is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.q, mem.q",
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVHPD.html"
        ]
    },
    "pf2id": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vtestpd": {
        "detail": [
            "Packed Bit Test"
        ],
        "documentation": [
            "VTESTPS performs a bitwise comparison of all the sign bits of the packed single-precision elements in the first source operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with the dest sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND of the source sign bits with the inverted dest sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with VEX.W=1 will cause #UD.",
            "VTESTPD performs a bitwise comparison of all the sign bits of the double-precision elements in the first source operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with the dest sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND the source sign bits with the inverted dest sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with VEX.W=1 will cause #UD.",
            "The first source register is specified by the ModR/M reg field.",
            "128-bit version: The first source register is an XMM register. The second source register can be an XMM register or a 128-bit memory location. The destination register is not modified.",
            "VEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination register is not modified.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
            "Flags Affected:",
            "The 0F, AF, PF, SF flags are cleared and the ZF, CF flags are set according to the operation."
        ],
        "operands": [
            "reg.x, reg.x",
            "reg.x, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VTESTPD:VTESTPS.html"
        ]
    },
    "ldmxcsr": {
        "detail": [
            "Load MXCSR Register"
        ],
        "documentation": [
            "Loads the source operand into the MXCSR control/status register. The source operand is a 32-bit memory location. See “MXCSR Control and Status Register” in Chapter 10, of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a description of the MXCSR register and its contents.",
            "The LDMXCSR instruction is typically used in conjunction with the (V)STMXCSR instruction, which stores the contents of the MXCSR register in memory.",
            "The default MXCSR value at reset is 1F80H.",
            "If a (V)LDMXCSR instruction clears a SIMD floating-point exception mask bit and sets the corresponding exception flag bit, a SIMD floating-point exception will not be immediately generated. The exception will be generated only upon the execution of the next instruction that meets both conditions below:"
        ],
        "operands": [
            "mem.d, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/LDMXCSR.html"
        ]
    },
    "tzmsk": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://"
        ]
    },
    "movhps": {
        "detail": [
            "Move High Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "This instruction cannot be used for register to register or memory to memory moves.",
            "128-bit Legacy SSE load:",
            "Moves two packed single-precision floating-point values from the source 64-bit memory operand and stores them in the high 64-bits of the destination XMM register. The lower 64bits of the XMM register are preserved. Bits (MAXVL-1:128) of the corresponding destination register are preserved.",
            "VEX.128 & EVEX encoded load:",
            "Loads two single-precision floating-point values from the source 64-bit memory operand (the third operand) and stores it in the upper 64-bits of the destination XMM register (first operand). The low 64-bits from the first source operand (the second operand) are copied to the lower 64-bits of the destination. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "128-bit store:",
            "Stores two packed single-precision floating-point values from the high 64-bits of the XMM register source (second operand) to the 64-bit memory location (first operand).",
            "Note: VMOVHPS (store) (VEX.128.0F 17 /r) is legal and has the same behavior as the existing 0F 17 store. For VMOVHPS (store) VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.",
            "If VMOVHPS is encoded with VEX.L or EVEX.L’L= 1, an attempt to execute the instruction encoded with VEX.L or EVEX.L’L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.q, mem.q",
            "mem.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVHPS.html"
        ]
    },
    "vmovntpd": {
        "detail": [
            "Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint"
        ],
        "documentation": [
            "Moves the packed double-precision floating-point values in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register, YMM register or ZMM register, which is assumed to contain packed double-precision, floating-pointing data. The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.",
            "The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the IA-32 Intel Architecture Software Developer’s Manual, Volume 1.",
            "Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPD instructions if multiple processors might use different memory types to read/write the destination memory locations.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b, VEX.L must be 0; otherwise instructions will #UD."
        ],
        "operands": [
            "mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVNTPD.html"
        ]
    },
    "pf2iw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vtestps": {
        "detail": [
            "Packed Bit Test"
        ],
        "documentation": [
            "VTESTPS performs a bitwise comparison of all the sign bits of the packed single-precision elements in the first source operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with the dest sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND of the source sign bits with the inverted dest sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with VEX.W=1 will cause #UD.",
            "VTESTPD performs a bitwise comparison of all the sign bits of the double-precision elements in the first source operation and corresponding sign bits in the second source operand. If the AND of the source sign bits with the dest sign bits produces all zeros, the ZF is set else the ZF is clear. If the AND the source sign bits with the inverted dest sign bits produces all zeros the CF is set else the CF is clear. An attempt to execute VTESTPS with VEX.W=1 will cause #UD.",
            "The first source register is specified by the ModR/M reg field.",
            "128-bit version: The first source register is an XMM register. The second source register can be an XMM register or a 128-bit memory location. The destination register is not modified.",
            "VEX.256 encoded version: The first source register is a YMM register. The second source register can be a YMM register or a 256-bit memory location. The destination register is not modified.",
            "Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.",
            "Flags Affected:",
            "The 0F, AF, PF, SF flags are cleared and the ZF, CF flags are set according to the operation."
        ],
        "operands": [
            "reg.x, reg.x",
            "reg.x, mem.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VTESTPD:VTESTPS.html"
        ]
    },
    "pmuldq": {
        "detail": [
            "Multiply Packed Doubleword Integers"
        ],
        "documentation": [
            "Multiplies packed signed doubleword integers in the even-numbered (zero-based reference) elements of the first source operand with the packed signed doubleword integers in the corresponding elements of the second source operand and stores packed signed quadword results in the destination operand.",
            "128-bit Legacy SSE version: The input signed doubleword integers are taken from the even-numbered elements of the source operands, i.e. the first (low) and third doubleword element. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation. The first source operand and the destination XMM operand is the same. The second source operand can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: The input signed doubleword integers are taken from the even-numbered elements of the source operands, i.e., the first (low) and third doubleword element. For 128-bit memory operands, 128 bits are fetched from memory, but only the first and third doublewords are used in the computation.The first source operand and the destination operand are XMM registers. The second source operand can be an XMM register or 128-bit memory location. Bits (MAXVL-1:128) of the corresponding destination register are zeroed.",
            "VEX.256 encoded version: The input signed doubleword integers are taken from the even-numbered elements of the source operands, i.e. the first, 3rd, 5th, 7th doubleword element. For 256-bit memory operands, 256 bits are fetched from memory, but only the four even-numbered doublewords are used in the computation. The first source operand and the destination operand are YMM registers. The second source operand can be a YMM register or 256-bit memory location. Bits (MAXVL-1:256) of the corresponding destination ZMM register are zeroed.",
            "EVEX encoded version: The input signed doubleword integers are taken from the even-numbered elements of the source operands. The first source operand is a ZMM/YMM/XMM registers. The second source operand can be an ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination is a ZMM/YMM/XMM register, and updated according to the writemask at 64-bit granularity."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMULDQ.html"
        ]
    },
    "endbr32": {
        "detail": [
            ""
        ],
        "operands": [
            ""
        ],
        "url": [
            "https://"
        ]
    },
    "vscatterpf1dpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint with Intent to Write"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "cache lines will be brought into exclusive state (RFO) specified by a locality hint (T1):"
        ],
        "operands": [
            "mem.q, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCATTERPF1DPS:VSCATTERPF1QPS:VSCATTERPF1DPD:VSCATTERPF1QPD.html"
        ]
    },
    "vmovntps": {
        "detail": [
            "Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint"
        ],
        "documentation": [
            "Moves the packed single-precision floating-point values in the source operand (second operand) to the destination operand (first operand) using a non-temporal hint to prevent caching of the data during the write to memory. The source operand is an XMM register, YMM register or ZMM register, which is assumed to contain packed single-precision, floating-pointing. The destination operand is a 128-bit, 256-bit or 512-bit memory location. The memory operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.",
            "The non-temporal hint is implemented by using a write combining (WC) memory type protocol when writing the data to memory. Using this protocol, the processor does not write the data into the cache hierarchy, nor does it fetch the corresponding cache line from memory into the cache hierarchy. The memory type of the region being written to can override the non-temporal hint, if the memory address specified for the non-temporal store is in an uncacheable (UC) or write protected (WP) memory region. For more information on non-temporal stores, see “Caching of Temporal vs. Non-Temporal Data” in Chapter 10 in the IA-32 Intel Architecture Software Developer’s Manual, Volume 1.",
            "Because the WC protocol uses a weakly-ordered memory consistency model, a fencing operation implemented with the SFENCE or MFENCE instruction should be used in conjunction with MOVNTPS instructions if multiple processors might use different memory types to read/write the destination memory locations.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "mem.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVNTPS.html"
        ]
    },
    "div": {
        "detail": [
            "Unsigned Divide"
        ],
        "documentation": [
            "Divides unsigned the value in the AX, DX:AX, EDX:EAX, or RDX:RAX registers (dividend) by the source operand (divisor) and stores the result in the AX (AH:AL), DX:AX, EDX:EAX, or RDX:RAX registers. The source operand can be a general-purpose register or a memory location. The action of this instruction depends on the operand size (dividend/divisor). Division using 64-bit operand is available only in 64-bit mode.",
            "Non-integral results are truncated (chopped) towards 0. The remainder is always less than the divisor in magnitude. Overflow is indicated with the #DE (divide error) exception rather than with the CF flag.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Use of the REX.R prefix permits access to additional registers (R8-R15). Use of the REX.W prefix promotes operation to 64 bits. In 64-bit mode when REX.W is applied, the instruction divides the unsigned value in RDX:RAX by the source operand and stores the quotient in RAX, the remainder in RDX.",
            "See the summary chart at the beginning of this section for encoding data and limits. See Table 3-15.",
            "Flags Affected:",
            "The CF, OF, SF, ZF, AF, and PF flags are undefined."
        ],
        "operands": [
            "reg.b, reg",
            "reg.w, reg.w, reg.w",
            "mem.b, reg",
            "mem.w, reg.w, reg.w"
        ],
        "url": [
            "https://felixcloutier.com/x86/DIV.html"
        ]
    },
    "ftst": {
        "detail": [
            "TEST"
        ],
        "documentation": [
            "Compares the value in the ST(0) register with 0.0 and sets the condition code flags C0, C2, and C3 in the FPU status word according to the results (see table below)."
        ],
        "operands": [
            "reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FTST.html"
        ]
    },
    "vpmovq2m": {
        "detail": [
            "Convert a Vector Register to a Mask"
        ],
        "documentation": [
            "Converts a vector register to a mask register. Each element in the destination register is set to 1 or 0 depending on the value of most significant bit of the corresponding element in the source register.",
            "The source operand is a ZMM/YMM/XMM register. The destination operand is a mask register.",
            "EVEX.vvvv is reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPMOVB2M:VPMOVW2M:VPMOVD2M:VPMOVQ2M.html"
        ]
    },
    "vscatterpf1dps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint with Intent to Write"
        ],
        "documentation": [
            "The instruction conditionally prefetches up to sixteen 32-bit or eight 64-bit integer byte data elements. The elements are specified via the VSIB (i.e., the index register is an zmm, holding packed indices). Elements will only be prefetched if their corresponding mask bit is one.",
            "cache lines will be brought into exclusive state (RFO) specified by a locality hint (T1):"
        ],
        "operands": [
            "mem.d, reg.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/VSCATTERPF1DPS:VSCATTERPF1QPS:VSCATTERPF1DPD:VSCATTERPF1QPD.html"
        ]
    },
    "vpxor": {
        "detail": [
            "Logical Exclusive OR"
        ],
        "documentation": [
            "Performs a bitwise logical exclusive-OR (XOR) operation on the source operand (second operand) and the destination operand (first operand) and stores the result in the destination operand. Each bit of the result is 1 if the corresponding bits of the two operands are different; each bit is 0 if the corresponding bits of the operands are the same.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE instructions 64-bit operand: The source operand can be an MMX technology register or a 64-bit memory location. The destination operand is an MMX technology register.",
            "128-bit Legacy SSE version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The second source operand is an XMM register or a 128-bit memory location. The first source operand and destination operands are XMM registers. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding register destination are zeroed.",
            "EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PXOR.html"
        ]
    },
    "vpmaddwd": {
        "detail": [
            "Multiply and Add Packed Integers"
        ],
        "documentation": [
            "Multiplies the individual signed words of the destination operand (first operand) by the corresponding signed words of the source operand (second operand), producing temporary signed, doubleword results. The adjacent double-word results are then summed and stored in the destination operand. For example, the corresponding low-order words (15-0) and (31-16) in the source and destination operands are multiplied by one another and the double-word results are added together and stored in the low doubleword of the destination register (31-0). The same operation is performed on the other pairs of adjacent words. (Figure 4-11 shows this operation when using 64-bit operands).",
            "The (V)PMADDWD instruction wraps around only in one situation: when the 2 pairs of words being operated on in a group are all 8000H. In this case, the result wraps around to 80000000H.",
            "In 64-bit mode and not encoded with VEX/EVEX, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).",
            "Legacy SSE version: The first source and destination operands are MMX registers. The second source operand is an MMX register or a 64-bit memory location.",
            "128-bit Legacy SSE version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source and destination operands are XMM registers. The second source operand is an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed.",
            "VEX.256 encoded version: The second source operand can be an YMM register or a 256-bit memory location. The first source and destination operands are YMM registers.",
            "EVEX.512 encoded version: The second source operand can be an ZMM register or a 512-bit memory location. The first source and destination operands are ZMM registers.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PMADDWD.html"
        ]
    },
    "vbroadcastsd": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "documentation": [
            "VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).",
            "VEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4 load floating-point values as tuples from the source operand (the second operand) in memory or register and broadcast to all elements of the destination operand (the first operand). The destination operand is a YMM/ZMM register updated according to the writemask k1. The source operand is either a register or 64-bit/128-bit/256-bit memory location.",
            "VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as 256-bit and 512-bit wide versions and up. VBROADCASTSS is supported in 128-bit, 256-bit and 512-bit wide versions. F32x8 and F64x4 are only supported as 512-bit wide versions.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32-bit granularity. VBROADCASTF64X2 and VBROADCASTF64X4 have 64-bit granularity.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.y, mem.q",
            "reg.y, reg.x",
            "reg.z, reg.q, mem.q",
            "reg.z, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBROADCAST.html"
        ]
    },
    "vbroadcastss": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "documentation": [
            "VBROADCASTSD/VBROADCASTSS/VBROADCASTF128 load floating-point values as one tuple from the source operand (second operand) in memory and broadcast to all elements of the destination operand (first operand).",
            "VEX256-encoded versions: The destination operand is a YMM register. The source operand is either a 32-bit, 64-bit, or 128-bit memory location. Register source encodings are reserved and will #UD. Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX-encoded versions: The destination operand is a ZMM/YMM/XMM register and updated according to the writemask k1. The source operand is either a 32-bit, 64-bit memory location or the low doubleword/quadword element of an XMM register.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF64X2/VBROADCASTF32X8/VBROADCASTF64X4 load floating-point values as tuples from the source operand (the second operand) in memory or register and broadcast to all elements of the destination operand (the first operand). The destination operand is a YMM/ZMM register updated according to the writemask k1. The source operand is either a register or 64-bit/128-bit/256-bit memory location.",
            "VBROADCASTSD and VBROADCASTF128,F32x4 and F64x2 are only supported as 256-bit and 512-bit wide versions and up. VBROADCASTSS is supported in 128-bit, 256-bit and 512-bit wide versions. F32x8 and F64x4 are only supported as 512-bit wide versions.",
            "VBROADCASTF32X2/VBROADCASTF32X4/VBROADCASTF32X8 have 32-bit granularity. VBROADCASTF64X2 and VBROADCASTF64X4 have 64-bit granularity.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD.",
            "If VBROADCASTSD or VBROADCASTF128 is encoded with VEX.L= 0, an attempt to execute the instruction encoded with VEX.L= 0 will cause an #UD exception."
        ],
        "operands": [
            "reg.x, mem.d",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.d",
            "reg.z, reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VBROADCAST.html"
        ]
    },
    "pext": {
        "detail": [
            "Parallel Bits Extract"
        ],
        "documentation": [
            "PEXT uses a mask in the second source operand (the third operand) to transfer either contiguous or non-contiguous bits in the first source operand (the second operand) to contiguous low order bit positions in the destination (the first operand). For each bit set in the MASK, PEXT extracts the corresponding bits from the first source operand and writes them into contiguous lower bits of destination operand. The remaining upper bits of destination are zeroed.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.d, reg.d, mem.d",
            "reg.d, reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/PEXT.html"
        ]
    },
    "fld1": {
        "detail": [
            "Load Constant"
        ],
        "documentation": [
            "Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, π, log102, and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.",
            "See the section titled “Approximation of Pi” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a description of the π constant.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FLD1:FLDL2T:FLDL2E:FLDPI:FLDLG2:FLDLN2:FLDZ.html"
        ]
    },
    "vpcmpistri": {
        "detail": [
            "Packed Compare Implicit Length Strings, Return Index"
        ],
        "documentation": [
            "The instruction compares data from two strings based on the encoded value in the Imm8 Control Byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”), and generates an index stored to ECX.",
            "Each string is represented by a single value. The value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). Each input byte/word is augmented with a valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null byte/word. (The least significant null byte/word is also considered invalid.)",
            "The comparison and aggregation operations are performed according to the encoded value of Imm8 bit fields (see Section 4.1). The index of the first (or last, according to imm8[6]) set bit of IntRes2 is returned in ECX. If no bits are set in IntRes2, ECX is set to 16 (8).",
            "Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:",
            "CFlag – Reset if IntRes2 is equal to zero, set otherwise",
            "ZFlag – Set if any byte/word of xmm2/mem128 is null, reset otherwise",
            "SFlag – Set if any byte/word of xmm1 is null, reset otherwise",
            "OFlag –IntRes2[0]",
            "AFlag – Reset",
            "PFlag – Reset",
            "Note: In VEX.128 encoded version, VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.x, reg.x, imm.b, reg",
            "reg.x, mem.x, imm.b, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPISTRI.html"
        ]
    },
    "adc": {
        "detail": [
            "Add with Carry"
        ],
        "documentation": [
            "Adds the destination operand (first operand), the source operand (second operand), and the carry (CF) flag and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a carry from a previous addition. When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.",
            "The ADC instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a carry in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.",
            "The ADC instruction is usually executed as part of a multibyte or multiword addition in which an ADD instruction is followed by an ADC instruction.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF, SF, ZF, AF, CF, and PF flags are set according to the result."
        ],
        "operands": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADC.html"
        ]
    },
    "add": {
        "detail": [
            "Add"
        ],
        "documentation": [
            "Adds the destination operand (first operand) and the source operand (second operand) and then stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.",
            "The ADD instruction performs integer addition. It evaluates the result for both signed and unsigned integer operands and sets the CF and OF flags to indicate a carry (overflow) in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.",
            "This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.",
            "In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.",
            "Flags Affected:",
            "The OF, SF, ZF, AF, CF, and PF flags are set according to the result."
        ],
        "operands": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADD.html"
        ]
    },
    "vpunpckhbw": {
        "detail": [
            "Unpack High Data"
        ],
        "documentation": [
            "Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. Figure 4-20 shows the unpack operation for bytes in 64-bit operands. The low-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html"
        ]
    },
    "vpcmpistrm": {
        "detail": [
            "Packed Compare Implicit Length Strings, Return Mask"
        ],
        "documentation": [
            "The instruction compares data from two strings based on the encoded value in the imm8 byte (see Section 4.1, “Imm8 Control Byte Operation for PCMPESTRI / PCMPESTRM / PCMPISTRI / PCMPISTRM”) generating a mask stored to XMM0.",
            "Each string is represented by a single value. The value is an xmm (or possibly m128 for the second operand) which contains the data elements of the string (byte or word data). Each input byte/word is augmented with a valid/invalid tag. A byte/word is considered valid only if it has a lower index than the least significant null byte/word. (The least significant null byte/word is also considered invalid.)",
            "The comparison and aggregation operation are performed according to the encoded value of Imm8 bit fields (see Section 4.1). As defined by imm8[6], IntRes2 is then either stored to the least significant bits of XMM0 (zero extended to 128 bits) or expanded into a byte/word-mask and then stored to XMM0.",
            "Note that the Arithmetic Flags are written in a non-standard manner in order to supply the most relevant information:",
            "CFlag – Reset if IntRes2 is equal to zero, set otherwise",
            "ZFlag – Set if any byte/word of xmm2/mem128 is null, reset otherwise",
            "SFlag – Set if any byte/word of xmm1 is null, reset otherwise",
            "OFlag – IntRes2[0]",
            "AFlag – Reset",
            "PFlag – Reset",
            "Note: In VEX.128 encoded versions, bits (MAXVL-1:128) of XMM0 are zeroed. VEX.vvvv is reserved and must be 1111b, VEX.L must be 0, otherwise the instruction will #UD."
        ],
        "operands": [
            "reg.x, reg.x, imm.b, reg.x",
            "reg.x, mem.x, imm.b, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PCMPISTRM.html"
        ]
    },
    "fdivp": {
        "detail": [
            "Divide"
        ],
        "documentation": [
            "Divides the destination operand by the source operand and stores the result in the destination location. The destination operand (dividend) is always in an FPU register; the source operand (divisor) can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format.",
            "The no-operand version of the instruction divides the contents of the ST(1) register by the contents of the ST(0) register. The one-operand version divides the contents of the ST(0) register by the contents of a memory location (either a floating-point or an integer value). The two-operand version, divides the contents of the ST(0) register by the contents of the ST(i) register or vice versa.",
            "The FDIVP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIV rather than FDIVP.",
            "The FIDIV instructions convert an integer source operand to double extended-precision floating-point format before performing the division. When the source operand is an integer 0, it is treated as a +0.",
            "If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.",
            "The following table shows the results obtained when dividing various classes of numbers, assuming that neither overflow nor underflow occurs."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FDIV:FDIVP:FIDIV.html"
        ]
    },
    "fdivr": {
        "detail": [
            "Reverse Divide"
        ],
        "documentation": [
            "Divides the source operand by the destination operand and stores the result in the destination location. The destination operand (divisor) is always in an FPU register; the source operand (dividend) can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format, word or doubleword integer format.",
            "These instructions perform the reverse operations of the FDIV, FDIVP, and FIDIV instructions. They are provided to support more efficient coding.",
            "The no-operand version of the instruction divides the contents of the ST(0) register by the contents of the ST(1) register. The one-operand version divides the contents of a memory location (either a floating-point or an integer value) by the contents of the ST(0) register. The two-operand version, divides the contents of the ST(i) register by the contents of the ST(0) register or vice versa.",
            "The FDIVRP instructions perform the additional operation of popping the FPU register stack after storing the result. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point divide instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FDIVR rather than FDIVRP.",
            "The FIDIVR instructions convert an integer source operand to double extended-precision floating-point format before performing the division.",
            "If an unmasked divide-by-zero exception (#Z) is generated, no result is stored; if the exception is masked, an ∞ of the appropriate sign is stored in the destination operand.",
            "The following table shows the results obtained when dividing various classes of numbers, assuming that neither overflow nor underflow occurs."
        ],
        "operands": [
            "reg.wq, mem.d, reg",
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FDIVR:FDIVRP:FIDIVR.html"
        ]
    },
    "vmovsldup": {
        "detail": [
            "Replicate Single FP Values"
        ],
        "documentation": [
            "Duplicates even-indexed single-precision floating-point values from the source operand (the second operand). See Figure 4-4. The source operand is an XMM, YMM or ZMM register or 128, 256 or 512-bit memory location and the destination operand is an XMM, YMM or ZMM register.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX encoded version: The destination operand is updated at 32-bit granularity according to the writemask.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVSLDUP.html"
        ]
    },
    "vinsertps": {
        "detail": [
            "Insert Scalar Single-Precision Floating-Point Value"
        ],
        "documentation": [
            "(register source form)",
            "Copy a single-precision scalar floating-point element into a 128-bit vector register. The immediate operand has three fields, where the ZMask bits specify which elements of the destination will be set to zero, the Count_D bits specify which element of the destination will be overwritten with the scalar value, and for vector register sources the Count_S bits specify which element of the source will be copied. When the scalar source is a memory operand the Count_S bits are ignored.",
            "(memory source form)",
            "Load a floating-point element from a 32-bit memory location and destination operand it into the first source at the location indicated by the Count_D bits of the immediate operand. Store in the destination and zero out destination elements based on the ZMask bits of the immediate operand.",
            "128-bit Legacy SSE version: The first source register is an XMM register. The second source operand is either an XMM register or a 32-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.",
            "VEX.128 and EVEX encoded version: The destination and first source register is an XMM register. The second source operand is either an XMM register or a 32-bit memory location. The upper bits (MAXVL-1:128) of the corresponding register destination are zeroed.",
            "If VINSERTPS is encoded with VEX.L= 1, an attempt to execute the instruction encoded with VEX.L= 1 will cause an #UD exception."
        ],
        "operands": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ],
        "url": [
            "https://felixcloutier.com/x86/INSERTPS.html"
        ]
    },
    "vfmaddsub132pd": {
        "detail": [
            "Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFMADDSUB132PD: Multiplies the two, four, or eight packed double-precision floating-point values from the first source operand to the two or four packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the even double-precision floating-point values in the second source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMADDSUB213PD: Multiplies the two, four, or eight packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the first source operand. From the infinite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the even double-precision floating-point values in the third source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "VFMADDSUB231PD: Multiplies the two, four, or eight packed double-precision floating-point values from the second source operand to the two or four packed double-precision floating-point values in the third source operand. From the infinite precision intermediate result, adds the odd double-precision floating-point elements and subtracts the even double-precision floating-point values in the first source operand, performs rounding and stores the resulting two or four packed double-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADDSUB132PD:VFMADDSUB213PD:VFMADDSUB231PD.html"
        ]
    },
    "xrstors": {
        "detail": [
            "Restore Processor Extended States Supervisor"
        ],
        "documentation": [
            "Performs a full or partial restore of processor state components from the XSAVE area located at the memory address specified by the source operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components restored correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XRSTORS may be executed only if CPL = 0.",
            "The format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Section 13.12, “Operation of XRSTORS,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XRSTOR instruction. The following items provide a high-level outline:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.z[4096], reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XRSTORS.html"
        ]
    },
    "xsavec": {
        "detail": [
            "Save Processor Extended States with Compaction"
        ],
        "documentation": [
            "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), which is the logical-AND of EDX:EAX and XCR0.",
            "The format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Section 13.10, “Operation of XSAVEC,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XSAVEC instruction. The following items provide a highlevel outline:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.z[4096], reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XSAVEC.html"
        ]
    },
    "vpermi2b": {
        "detail": [
            "Full Permute of Bytes from Two Tables Overwriting the Index"
        ],
        "documentation": [
            "Permutes byte values in the second operand (the first source operand) and the third operand (the second source operand) using the byte indices in the first operand (the destination operand) to select byte elements from the second or third source operands. The selected byte elements are written to the destination at byte granularity under the writemask k1.",
            "The first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the result. The third operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. In each index byte, the id bit for table selection is bit 6/5/4, and bits [5:0]/[4:0]/[3:0] selects element within each input table.",
            "Note that these instructions permit a byte value in the source operands to be copied to more than one location in the destination operand. Also, the same tables can be reused in subsequent iterations, but the index elements are overwritten.",
            "Bits (MAX_VL-1:256/128) of the destination are zeroed for VL=256,128."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMI2B.html"
        ]
    },
    "vpermi2d": {
        "detail": [
            "Full Permute From Two Tables Overwriting the Index"
        ],
        "documentation": [
            "Permutes 16-bit/32-bit/64-bit values in the second operand (the first source operand) and the third operand (the second source operand) using indices in the first operand to select elements from the second and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.",
            "The first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the result.",
            "D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).",
            "Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.",
            "Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.",
            "Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.",
            "Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. Note also that in this case, the same table can be reused for example for a second iteration, while the index elements are overwritten.",
            "Bits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMI2W:VPERMI2D:VPERMI2Q:VPERMI2PS:VPERMI2PD.html"
        ]
    },
    "vfmaddsub132ps": {
        "detail": [
            "Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "VFMADDSUB132PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the first source operand to the corresponding packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and subtracts the even single-precision floating-point values in the second source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMADDSUB213PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the corresponding packed single-precision floating-point values in the first source operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and subtracts the even single-precision floating-point values in the third source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "VFMADDSUB231PS: Multiplies the four, eight or sixteen packed single-precision floating-point values from the second source operand to the corresponding packed single-precision floating-point values in the third source operand. From the infinite precision intermediate result, adds the odd single-precision floating-point elements and subtracts the even single-precision floating-point values in the first source operand, performs rounding and stores the resulting packed single-precision floating-point values to the destination operand (first source operand).",
            "EVEX encoded versions: The destination operand (also first source operand) and the second source operand are ZMM/YMM/XMM register. The third source operand is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is conditionally updated with write mask k1.",
            "VEX.256 encoded version: The destination operand (also first source operand) is a YMM register and encoded in reg_field. The second source operand is a YMM register and encoded in VEX.vvvv. The third source operand is a YMM register or a 256-bit memory location and encoded in rm_field.",
            "VEX.128 encoded version: The destination operand (also first source operand) is a XMM register and encoded in reg_field. The second source operand is a XMM register and encoded in VEX.vvvv. The third source operand is a XMM register or a 128-bit memory location and encoded in rm_field. The upper 128 bits of the YMM destination register are zeroed.",
            "Compiler tools may optionally support a complementary mnemonic for each instruction mnemonic listed in the opcode/instruction column of the summary table. The behavior of the complementary mnemonic in situations involving NANs are governed by the definition of the instruction mnemonic defined in the opcode/instruction column."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VFMADDSUB132PS:VFMADDSUB213PS:VFMADDSUB231PS.html"
        ]
    },
    "adcx": {
        "detail": [
            "Unsigned Integer Addition of Two Operands with Carry Flag"
        ],
        "documentation": [
            "Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the carry-flag (CF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of CF can represent a carry from a previous addition. The instruction sets the CF flag with the carry generated by the unsigned addition of the operands.",
            "The ADCX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we need to make sure the CF is in a desired initial state. Often, this initial state needs to be 0, which can be achieved with an instruction to zero the CF (e.g. XOR).",
            "This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.",
            "In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64 bits.",
            "ADCX executes normally either inside or outside a transaction region.",
            "Note: ADCX defines the OF flag differently than the ADD/ADC instructions as defined in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A.",
            "Flags Affected:",
            "CF is updated based on result. OF, SF, ZF, AF and PF flags are unmodified."
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/ADCX.html"
        ]
    },
    "fldz": {
        "detail": [
            "Load Constant"
        ],
        "documentation": [
            "Push one of seven commonly used constants (in double extended-precision floating-point format) onto the FPU register stack. The constants that can be loaded with these instructions include +1.0, +0.0, log210, log2e, π, log102, and loge2. For each constant, an internal 66-bit constant is rounded (as specified by the RC field in the FPU control word) to double extended-precision floating-point format. The inexact-result exception (#P) is not generated as a result of the rounding, nor is the C1 flag set in the x87 FPU status word if the value is rounded up.",
            "See the section titled “Approximation of Pi” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a description of the π constant.",
            "This instruction’s operation is the same in non-64-bit modes and 64-bit mode."
        ],
        "operands": [
            "reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FLD1:FLDL2T:FLDL2E:FLDPI:FLDLG2:FLDLN2:FLDZ.html"
        ]
    },
    "xsaves": {
        "detail": [
            "Save Processor Extended States Supervisor"
        ],
        "documentation": [
            "Performs a full or partial save of processor state components to the XSAVE area located at the memory address specified by the destination operand. The implicit EDX:EAX register pair specifies a 64-bit instruction mask. The specific state components saved correspond to the bits set in the requested-feature bitmap (RFBM), the logicalAND of EDX:EAX and the logical-OR of XCR0 with the IA32_XSS MSR. XSAVES may be executed only if CPL = 0.",
            "The format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1. Like FXRSTOR and FXSAVE, the memory format used for x87 state depends on a REX.W prefix; see Section 13.5.1, “x87 State” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.",
            "Section 13.11, “Operation of XSAVES,” of Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1 provides a detailed description of the operation of the XSAVES instruction. The following items provide a highlevel outline:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "mem.z[4096], reg, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/XSAVES.html"
        ]
    },
    "vpermi2q": {
        "detail": [
            "Full Permute From Two Tables Overwriting the Index"
        ],
        "documentation": [
            "Permutes 16-bit/32-bit/64-bit values in the second operand (the first source operand) and the third operand (the second source operand) using indices in the first operand to select elements from the second and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.",
            "The first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the result.",
            "D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).",
            "Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.",
            "Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.",
            "Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.",
            "Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. Note also that in this case, the same table can be reused for example for a second iteration, while the index elements are overwritten.",
            "Bits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMI2W:VPERMI2D:VPERMI2Q:VPERMI2PS:VPERMI2PD.html"
        ]
    },
    "vpermi2w": {
        "detail": [
            "Full Permute From Two Tables Overwriting the Index"
        ],
        "documentation": [
            "Permutes 16-bit/32-bit/64-bit values in the second operand (the first source operand) and the third operand (the second source operand) using indices in the first operand to select elements from the second and third operands. The selected elements are written to the destination operand (the first operand) according to the writemask k1.",
            "The first and second operands are ZMM/YMM/XMM registers. The first operand contains input indices to select elements from the two input tables in the 2nd and 3rd operands. The first operand is also the destination of the result.",
            "D/Q/PS/PD element versions: The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32/64-bit memory location. Broadcast from the low 32/64-bit memory location is performed if EVEX.b and the id bit for table selection are set (selecting table_2).",
            "Dword/PS versions: The id bit for table selection is bit 4/3/2, depending on VL=512, 256, 128. Bits [3:0]/[2:0]/[1:0] of each element in the input index vector select an element within the two source operands, If the id bit is 0, table_1 (the first source) is selected; otherwise the second source operand is selected.",
            "Qword/PD versions: The id bit for table selection is bit 3/2/1, and bits [2:0]/[1:0] /bit 0 selects element within each input table.",
            "Word element versions: The second source operand can be a ZMM/YMM/XMM register, or a 512/256/128-bit memory location. The id bit for table selection is bit 5/4/3, and bits [4:0]/[3:0]/[2:0] selects element within each input table.",
            "Note that these instructions permit a 16-bit/32-bit/64-bit value in the source operands to be copied to more than one location in the destination operand. Note also that in this case, the same table can be reused for example for a second iteration, while the index elements are overwritten.",
            "Bits (MAXVL-1:256/128) of the destination are zeroed for VL=256,128."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPERMI2W:VPERMI2D:VPERMI2Q:VPERMI2PS:VPERMI2PD.html"
        ]
    },
    "sahf": {
        "detail": [
            "Store AH into Flags"
        ],
        "documentation": [
            "Loads the SF, ZF, AF, PF, and CF flags of the EFLAGS register with values from the corresponding bits in the AH register (bits 7, 6, 4, 2, and 0, respectively). Bits 1, 3, and 5 of register AH are ignored; the corresponding reserved bits (1, 3, and 5) in the EFLAGS register remain as shown in the “Operation” section below.",
            "This instruction executes as described above in compatibility mode and legacy mode. It is valid in 64-bit mode only if CPUID.80000001H:ECX.LAHF-SAHF[bit 0] = 1.",
            "Flags Affected:",
            "The SF, ZF, AF, PF, and CF flags are loaded with values from the AH register. Bits 1, 3, and 5 of the EFLAGS register are unaffected, with the values remaining 1, 0, and 0, respectively."
        ],
        "operands": [
            "reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/SAHF.html"
        ]
    },
    "vaesenclast": {
        "detail": [
            "Perform Last Round of an AES Encryption Flow"
        ],
        "documentation": [
            "This instruction performs the last round of an AES encryption flow using a round key from the second source operand, operating on 128-bit data (state) from the first source operand, and store the result in the destination operand.",
            "128-bit Legacy SSE version: The first source operand and the destination operand are the same and must be an XMM register. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.",
            "VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand can be an XMM register or a 128-bit memory location. Bits (MAXVL-1:128) of the destination YMM register are zeroed."
        ],
        "operands": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/AESENCLAST.html"
        ]
    },
    "vminpd": {
        "detail": [
            "Minimum of Packed Double-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed double-precision floating-point values in the first source operand and the second source operand and returns the minimum value for each pair of values to the destination operand.",
            "If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MINPD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MINPD.html"
        ]
    },
    "vrsqrt14sd": {
        "detail": [
            "Compute Approximate Reciprocal of Square Root of Scalar Float64 Value"
        ],
        "documentation": [
            "Computes the approximate reciprocal of the square roots of the scalar double-precision floating-point value in the low quadword element of the source operand (the second operand) and stores the result in the low quadword element of the destination operand (the first operand) according to the writemask. The maximum relative error for this approximation is less than 2-14. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register.",
            "Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "The VRSQRT14SD instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ with the sign of the source value is returned. When the source operand is an +∞ then +ZERO value is returned. A denormal source value is treated as zero only if DAZ bit is set in MXCSR. Otherwise it is treated correctly and performs the approximation with the specified masked response. When a source value is a negative value (other than 0.0) a floating-point QNaN_indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.",
            "MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRSQRT14SD.html"
        ]
    },
    "vprolvd": {
        "detail": [
            "Bit Rotate Left"
        ],
        "documentation": [
            "Rotates the bits in the individual data elements (doublewords, or quadword) in the first source operand to the left by the number of bits specified in the count operand. If the value specified by the count operand is greater than 31 (for doublewords), or 63 (for a quadword), then the count operand modulo the data size (32 or 64) is used.",
            "EVEX.128 encoded version: The destination operand is a XMM register. The source operand is a XMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.",
            "EVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX.512 encoded version: The destination operand is a ZMM register updated according to the writemask. For the count operand in immediate form, the source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location, the count operand is an 8-bit immediate. For the count operand in variable form, the first source operand (the second operand) is a ZMM register and the counter operand (the third operand) is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPROLD:VPROLVD:VPROLQ:VPROLVQ.html"
        ]
    },
    "monitorx": {
        "detail": [
            ""
        ],
        "operands": [
            "reg, reg, reg"
        ],
        "url": [
            "https://"
        ]
    },
    "vminps": {
        "detail": [
            "Minimum of Packed Single-Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a SIMD compare of the packed single-precision floating-point values in the first source operand and the second source operand and returns the minimum value for each pair of values to the destination operand.",
            "If the values being compared are both 0.0s (of either sign), the value in the second operand (source operand) is returned. If a value in the second operand is an SNaN, then SNaN is forwarded unchanged to the destination (that is, a QNaN version of the SNaN is not returned).",
            "If only one value is a NaN (SNaN or QNaN) for this instruction, the second operand (source operand), either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN source operand (from either the first or second operand) be returned, the action of MINPS can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.",
            "EVEX encoded versions: The first source operand (the second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.",
            "VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 encoded version: The first source operand is a XMM register. The second source operand can be a XMM register or a 128-bit memory location. The destination operand is a XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MINPS.html"
        ]
    },
    "vrsqrt14ss": {
        "detail": [
            "Compute Approximate Reciprocal of Square Root of Scalar Float32 Value"
        ],
        "documentation": [
            "Computes of the approximate reciprocal of the square root of the scalar single-precision floating-point value in the low doubleword element of the source operand (the second operand) and stores the result in the low doubleword element of the destination operand (the first operand) according to the writemask. The maximum relative error for this approximation is less than 2-14. The source operand can be an XMM register or a 32-bit memory location. The destination operand is an XMM register.",
            "Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.",
            "The VRSQRT14SS instruction is not affected by the rounding control bits in the MXCSR register. When a source value is a 0.0, an ∞ with the sign of the source value is returned. When the source operand is an ∞, zero with the sign of the source value is returned. A denormal source value is treated as zero only if DAZ bit is set in MXCSR. Otherwise it is treated correctly and performs the approximation with the specified masked response. When a source value is a negative value (other than 0.0) a floating-point indefinite is returned. When a source value is an SNaN or QNaN, the SNaN is converted to a QNaN or the source QNaN is returned.",
            "MXCSR exception flags are not affected by this instruction and floating-point exceptions are not reported."
        ],
        "operands": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VRSQRT14SS.html"
        ]
    },
    "xorpd": {
        "detail": [
            "Bitwise Logical XOR of Packed Double Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical XOR of the two, four or eight packed double-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand",
            "EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand can be a ZMM register or a vector memory location. The destination operand is a ZMM register conditionally updated with writemask k1.",
            "VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register (conditionally updated with writemask k1 in case of EVEX). The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register (conditionally updated with writemask k1 in case of EVEX). The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/XORPD.html"
        ]
    },
    "vprolvq": {
        "detail": [
            "Bit Rotate Left"
        ],
        "documentation": [
            "Rotates the bits in the individual data elements (doublewords, or quadword) in the first source operand to the left by the number of bits specified in the count operand. If the value specified by the count operand is greater than 31 (for doublewords), or 63 (for a quadword), then the count operand modulo the data size (32 or 64) is used.",
            "EVEX.128 encoded version: The destination operand is a XMM register. The source operand is a XMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:128) of the corresponding ZMM register are zeroed.",
            "EVEX.256 encoded version: The destination operand is a YMM register. The source operand is a YMM register or a memory location (for immediate form). The count operand can come either from an XMM register or a memory location or an 8-bit immediate. Bits (MAXVL-1:256) of the corresponding ZMM register are zeroed.",
            "EVEX.512 encoded version: The destination operand is a ZMM register updated according to the writemask. For the count operand in immediate form, the source operand can be a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location, the count operand is an 8-bit immediate. For the count operand in variable form, the first source operand (the second operand) is a ZMM register and the counter operand (the third operand) is a ZMM register, a 512-bit memory location or a 512-bit vector broadcasted from a 32/64-bit memory location."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ],
        "url": [
            "https://felixcloutier.com/x86/VPROLD:VPROLVD:VPROLQ:VPROLVQ.html"
        ]
    },
    "fprem": {
        "detail": [
            "Partial Remainder"
        ],
        "documentation": [
            "Computes the remainder obtained from dividing the value in the ST(0) register (the dividend) by the value in the ST(1) register (the divisor or modulus), and stores the result in ST(0). The remainder represents the following value:",
            "Remainder ← ST(0) − (Q ∗ ST(1))",
            "Here, Q is an integer value that is obtained by truncating the floating-point number quotient of [ST(0) / ST(1)] toward zero. The sign of the remainder is the same as the sign of the dividend. The magnitude of the remainder is less than that of the modulus, unless a partial remainder was computed (as described below).",
            "This instruction produces an exact result; the inexact-result exception does not occur and the rounding control has no effect. The following table shows the results obtained when computing the remainder of various classes of numbers, assuming that underflow does not occur."
        ],
        "operands": [
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FPREM.html"
        ]
    },
    "pfsubr": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "vphsubbw": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://"
        ]
    },
    "fsubp": {
        "detail": [
            "Subtract"
        ],
        "documentation": [
            "Subtracts the source operand from the destination operand and stores the difference in the destination location. The destination operand is always an FPU data register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.",
            "The no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floating-point or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.",
            "The FSUBP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUB rather than FSUBP.",
            "The FISUB instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.",
            "Table 3-38 shows the results obtained when subtracting various classes of numbers from one another, assuming that neither overflow nor underflow occurs. Here, the SRC value is subtracted from the DEST value (DEST − SRC = result).",
            "When the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.",
            "When one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalidoperation exception is generated."
        ],
        "operands": [
            "reg.wq, reg.wq, reg, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FSUB:FSUBP:FISUB.html"
        ]
    },
    "fsubr": {
        "detail": [
            "Reverse Subtract"
        ],
        "documentation": [
            "Subtracts the destination operand from the source operand and stores the difference in the destination location. The destination operand is always an FPU register; the source operand can be a register or a memory location. Source operands in memory can be in single-precision or double-precision floating-point format or in word or doubleword integer format.",
            "These instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided to support more efficient coding.",
            "The no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.",
            "The FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtraction. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1. The no-operand version of the floating-point reverse subtract instructions always results in the register stack being popped. In some assemblers, the mnemonic for this instruction is FSUBR rather than FSUBRP.",
            "The FISUBR instructions convert an integer source operand to double extended-precision floating-point format before performing the subtraction.",
            "The following table shows the results obtained when subtracting various classes of numbers from one another, assuming that neither overflow nor underflow occurs. Here, the DEST value is subtracted from the SRC value (SRC − DEST = result).",
            "When the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode, in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the source operand is an integer 0, it is treated as a +0.",
            "When one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalidoperation exception is generated."
        ],
        "operands": [
            "reg.wq, mem.d, reg",
            "reg.wq, reg.wq, reg"
        ],
        "url": [
            "https://felixcloutier.com/x86/FSUBR:FSUBRP:FISUBR.html"
        ]
    },
    "xorps": {
        "detail": [
            "Bitwise Logical XOR of Packed Single Precision Floating-Point Values"
        ],
        "documentation": [
            "Performs a bitwise logical XOR of the four, eight or sixteen packed single-precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand",
            "EVEX.512 encoded version: The first source operand is a ZMM register. The second source operand can be a ZMM register or a vector memory location. The destination operand is a ZMM register conditionally updated with writemask k1.",
            "VEX.256 and EVEX.256 encoded versions: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register (conditionally updated with writemask k1 in case of EVEX). The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.",
            "VEX.128 and EVEX.128 encoded versions: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register (conditionally updated with writemask k1 in case of EVEX). The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.",
            "128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/XORPS.html"
        ]
    },
    "tilezero": {
        "detail": [
            ""
        ],
        "operands": [
            "reg"
        ],
        "url": [
            "https://"
        ]
    },
    "cvttpd2pi": {
        "detail": [
            "Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers"
        ],
        "documentation": [
            "Converts two packed double-precision floating-point values in the source operand (second operand) to two packed signed doubleword integers in the destination operand (first operand). The source operand can be an XMM register or a 128-bit memory location. The destination operand is an MMX technology register.",
            "When a conversion is inexact, a truncated (round toward zero) result is returned. If a converted result is larger than the maximum signed doubleword integer, the floating-point invalid exception is raised, and if this exception is masked, the indefinite integer value (80000000H) is returned.",
            "This instruction causes a transition from x87 FPU to MMX technology operation (that is, the x87 FPU top-of-stack pointer is set to 0 and the x87 FPU tag word is set to all 0s [valid]). If this instruction is executed while an x87 FPU floating-point exception is pending, the exception is handled before the CVTTPD2PI instruction is executed.",
            "In 64-bit mode, use of the REX.R prefix permits this instruction to access additional registers (XMM8-XMM15)."
        ],
        "operands": [
            "reg.q, mem.x",
            "reg.q, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/CVTTPD2PI.html"
        ]
    },
    "pfmax": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ],
        "url": [
            "https://"
        ]
    },
    "retf": {
        "detail": [
            "Return from Procedure"
        ],
        "documentation": [
            "Transfers program control to a return address located on the top of the stack. The address is usually placed on the stack by a CALL instruction, and the return is made to the instruction that follows the CALL instruction.",
            "The optional source operand specifies the number of stack bytes to be released after the return address is popped; the default is none. This operand can be used to release parameters from the stack that were passed to the called procedure and are no longer needed. It must be used when the CALL instruction used to switch to a new procedure uses a call gate with a non-zero word count to access the new procedure. Here, the source operand for the RET instruction must specify the same number of bytes as is specified in the word count field of the call gate.",
            "The RET instruction can be used to execute three different types of returns:",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.q, reg.q, mem.q",
            "imm.w, reg.q, reg.q, mem.q"
        ],
        "url": [
            "https://felixcloutier.com/x86/RET.html"
        ]
    },
    "rdgsbase": {
        "detail": [
            "Read FS/GS Segment Base"
        ],
        "documentation": [
            "Loads the general-purpose register indicated by the modR/M:r/m field with the FS or GS segment base address.",
            "The destination operand may be either a 32-bit or a 64-bit general-purpose register. The REX.W prefix indicates the operand size is 64 bits. If no REX.W prefix is used, the operand size is 32 bits; the upper 32 bits of the source base address (for FS or GS) are ignored and upper 32 bits of the destination register are cleared.",
            "This instruction is supported only in 64-bit mode.",
            "Flags Affected:",
            "None"
        ],
        "operands": [
            "reg.d, reg.d"
        ],
        "url": [
            "https://felixcloutier.com/x86/RDFSBASE:RDGSBASE.html"
        ]
    },
    "vpunpckhdq": {
        "detail": [
            "Unpack High Data"
        ],
        "documentation": [
            "Unpacks and interleaves the high-order data elements (bytes, words, doublewords, or quadwords) of the destination operand (first operand) and source operand (second operand) into the destination operand. Figure 4-20 shows the unpack operation for bytes in 64-bit operands. The low-order data elements are ignored.",
            "Flags Affected:",
            "None."
        ],
        "operands": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html"
        ]
    },
    "movsldup": {
        "detail": [
            "Replicate Single FP Values"
        ],
        "documentation": [
            "Duplicates even-indexed single-precision floating-point values from the source operand (the second operand). See Figure 4-4. The source operand is an XMM, YMM or ZMM register or 128, 256 or 512-bit memory location and the destination operand is an XMM, YMM or ZMM register.",
            "128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding destination register remain unchanged.",
            "VEX.128 encoded version: Bits (MAXVL-1:128) of the destination register are zeroed.",
            "VEX.256 encoded version: Bits (MAXVL-1:256) of the destination register are zeroed.",
            "EVEX encoded version: The destination operand is updated at 32-bit granularity according to the writemask.",
            "Note: VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instructions will #UD."
        ],
        "operands": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/MOVSLDUP.html"
        ]
    },
    "blcfill": {
        "detail": [
            ""
        ],
        "operands": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ],
        "url": [
            "https://"
        ]
    },
    "vcvtsd2usi": {
        "detail": [
            "Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword Integer"
        ],
        "documentation": [
            "Converts a double-precision floating-point value in the source operand (the second operand) to an unsigned doubleword integer in the destination operand (the first operand). The source operand can be an XMM register or a 64-bit memory location. The destination operand is a general-purpose register. When the source operand is an XMM register, the double-precision floating-point value is contained in the low quadword of the register.",
            "When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register or the embedded rounding control bits. If a converted result cannot be represented in the destination format, the floating-point invalid exception is raised, and if this exception is masked, the integer value 2w – 1 is returned, where w represents the number of bits in the destination format."
        ],
        "operands": [
            "reg.d, mem.q",
            "reg.d, reg.x"
        ],
        "url": [
            "https://felixcloutier.com/x86/VCVTSD2USI.html"
        ]
    }
}
