{

    "vpmovwb": {
        "detail": [
            "Down Convert Word to Byte"
        ],
        "description": [
            "reg.x, reg.x",
            "mem.q, reg.q, reg.x",
            "mem.q, reg.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vfnmsubpd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "insertps": {
        "detail": [
            "Insert Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.d, imm.b"
        ]
    },
    "pcmpestri": {
        "detail": [
            "Packed Compare Explicit Length Strings, Return Index"
        ],
        "description": [
            "reg.x, reg.x, imm.b, reg, reg, reg",
            "reg.x, mem.x, imm.b, reg, reg, reg"
        ]
    },
    "endbr64": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "pcmpestrm": {
        "detail": [
            "Packed Compare Explicit Length Strings, Return Mask"
        ],
        "description": [
            "reg.x, reg.x, imm.b, reg, reg, reg.x",
            "reg.x, mem.x, imm.b, reg, reg, reg.x"
        ]
    },
    "blsfill": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "fidivr": {
        "detail": [
            "Reverse Divide"
        ],
        "description": [
            "reg.wq, mem.d, reg"
        ]
    },
    "fstp": {
        "detail": [
            "Store Floating Point Value"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg",
            "mem.d, reg.wq, reg, reg"
        ]
    },
    "vfnmsubps": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "fnstsw": {
        "detail": [
            "Store x87 FPU Status Word"
        ],
        "description": [
            "reg, reg",
            "mem.w, reg"
        ]
    },
    "xsaveopt64": {
        "detail": [
            "Save Processor Extended States Optimized"
        ],
        "description": [
            "mem.z[4096], reg, reg, reg"
        ]
    },
    "bndldx": {
        "detail": [
            "Load Extended Bounds Using Address Translation"
        ],
        "description": [
            "reg, mem.qx"
        ]
    },
    "pmaddubsw": {
        "detail": [
            "Multiply and Add Packed Signed and Unsigned Bytes"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "fxsave": {
        "detail": [
            "Save x87 FPU, MMX Technology, and SSE State"
        ],
        "description": [
            "mem.[4096], reg"
        ]
    },
    "pcmpgtb": {
        "detail": [
            "Compare Packed Signed Integers for Greater Than"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "sha256rnds2": {
        "detail": [
            "Perform Two Rounds of SHA256 Operation"
        ],
        "description": [
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "pcmpgtd": {
        "detail": [
            "Compare Packed Signed Integers for Greater Than"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "fsub": {
        "detail": [
            "Subtract"
        ],
        "description": [
            "reg.wq, mem.d, reg",
            "reg.wq, reg.wq, reg"
        ]
    },
    "vphsubdq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "blsi": {
        "detail": [
            "Extract Lowest Set Isolated Bit"
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "loadiwkey": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.d, reg.x"
        ]
    },
    "pmulhw": {
        "detail": [
            "Multiply Packed Signed Integers and Store High Result"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "pcmpgtq": {
        "detail": [
            "Compare Packed Data for Greater Than"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "movdiri": {
        "detail": [
            "Move Doubleword as Direct Store"
        ],
        "description": [
            "mem.d, reg.d"
        ]
    },
    "blsr": {
        "detail": [
            "Reset Lowest Set Bit"
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "pcmpgtw": {
        "detail": [
            "Compare Packed Signed Integers for Greater Than"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "kshiftlb": {
        "detail": [
            "Shift Left Mask Registers"
        ],
        "description": [
            "reg.q, reg.q, imm.b"
        ]
    },
    "kshiftld": {
        "detail": [
            "Shift Left Mask Registers"
        ],
        "description": [
            "reg.q, reg.q, imm.b"
        ]
    },
    "vpmultishiftqb": {
        "detail": [
            "Select Packed Unaligned Bytes from Quadword Sources"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "fisubr": {
        "detail": [
            "Reverse Subtract"
        ],
        "description": [
            "reg.wq, mem.d, reg"
        ]
    },
    "rdrand": {
        "detail": [
            "Read Random Number"
        ],
        "description": [
            "reg.w"
        ]
    },
    "rmpadjust": {
        "detail": [
            ""
        ],
        "description": [
            "reg, reg, reg"
        ]
    },
    "kshiftlq": {
        "detail": [
            "Shift Left Mask Registers"
        ],
        "description": [
            "reg.q, reg.q, imm.b"
        ]
    },
    "vcvttpd2dq": {
        "detail": [
            "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.y, reg.q, mem.z",
            "reg.y, reg.q, reg.z"
        ]
    },
    "kshiftlw": {
        "detail": [
            "Shift Left Mask Registers"
        ],
        "description": [
            "reg.q, reg.q, imm.b"
        ]
    },
    "vblendvpd": {
        "detail": [
            "Variable Blend Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "vpmacssdqh": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "vpmacssdql": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "pblendw": {
        "detail": [
            "Blend Packed Words"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "vminsd": {
        "detail": [
            "Return Minimum Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ]
    },
    "clc": {
        "detail": [
            "Clear Carry Flag"
        ],
        "description": [
            ""
        ]
    },
    "cld": {
        "detail": [
            "Clear Direction Flag"
        ],
        "description": [
            ""
        ]
    },
    "vblendvps": {
        "detail": [
            "Variable Blend Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "prefetchw": {
        "detail": [
            "Prefetch Data into Caches in Anticipation of a Write"
        ],
        "description": [
            "mem.z"
        ]
    },
    "cli": {
        "detail": [
            "Clear Interrupt Flag"
        ],
        "description": [
            ""
        ]
    },
    "pcmpeqd": {
        "detail": [
            "Compare Packed Data for Equal"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "pcmpeqb": {
        "detail": [
            "Compare Packed Data for Equal"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vrangepd": {
        "detail": [
            "Range Restriction Calculation For Packed Pairs of Float64 Values"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vminss": {
        "detail": [
            "Return Minimum Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ]
    },
    "blsmsk": {
        "detail": [
            "Get Mask Up to Lowest Set Bit"
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "popcnt": {
        "detail": [
            "Return the Count of Number of Bits Set to 1"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "pcmpeqq": {
        "detail": [
            "Compare Packed Qword Data for Equal"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "lwpins": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.d, imm.d",
            "reg.d, mem.d, imm.d"
        ]
    },
    "vpavgb": {
        "detail": [
            "Average Packed Integers"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "pcmpeqw": {
        "detail": [
            "Compare Packed Data for Equal"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vrangeps": {
        "detail": [
            "Range Restriction Calculation For Packed Pairs of Float32 Values"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "emms": {
        "detail": [
            "Empty MMX Technology State"
        ],
        "description": [
            ""
        ]
    },
    "aesencwide128kl": {
        "detail": [
            ""
        ],
        "description": [
            "mem.xy, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x"
        ]
    },
    "vperm2i128": {
        "detail": [
            "Permute Integer Values"
        ],
        "description": [
            "reg.y, reg.y, mem.y, imm.b",
            "reg.y, reg.y, reg.y, imm.b"
        ]
    },
    "vpavgw": {
        "detail": [
            "Average Packed Integers"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "setb": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "bndstx": {
        "detail": [
            "Store Extended Bounds Using Address Translation"
        ],
        "description": [
            "mem.qx, reg"
        ]
    },
    "setl": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "vroundpd": {
        "detail": [
            "Round Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "pi2fd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "setp": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "cmc": {
        "detail": [
            "Complement Carry Flag"
        ],
        "description": [
            ""
        ]
    },
    "seto": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "sets": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "vgf2p8affineqb": {
        "detail": [
            "Galois Field Affine Transformation"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vmcall": {
        "detail": [
            "Call to VM Monitor"
        ],
        "description": [
            ""
        ]
    },
    "vucomisd": {
        "detail": [
            "Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS"
        ],
        "description": [
            "reg.x, reg.q",
            "reg.x, mem.q"
        ]
    },
    "setz": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "rstorssp": {
        "detail": [
            ""
        ],
        "description": [
            "mem.q, reg.q"
        ]
    },
    "vroundps": {
        "detail": [
            "Round Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "cmp": {
        "detail": [
            "Compare Two Operands"
        ],
        "description": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "fst": {
        "detail": [
            "Store Floating Point Value"
        ],
        "description": [
            "reg.wq, reg.wq, reg",
            "mem.d, reg.wq, reg"
        ]
    },
    "vfnmsubsd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.q, mem.q",
            "reg.x, reg.q, reg.q, reg.q",
            "reg.x, reg.q, mem.q, reg.q"
        ]
    },
    "aesenc256kl": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.z"
        ]
    },
    "pi2fw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vmovdqu16": {
        "detail": [
            "Move Unaligned Packed Integer Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "mem.x, reg.q, reg.x",
            "mem.x, reg.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vucomiss": {
        "detail": [
            "Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS"
        ],
        "description": [
            "reg.x, reg.d",
            "reg.x, mem.d"
        ]
    },
    "vfnmsubss": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.d, reg.d, mem.d",
            "reg.x, reg.d, reg.d, reg.d",
            "reg.x, reg.d, mem.d, reg.d"
        ]
    },
    "pcmpestriq": {
        "detail": [
            "Packed Compare Explicit Length Strings, Return Index"
        ],
        "description": [
            "reg.x, reg.x, imm.b, reg, reg, reg",
            "reg.x, mem.x, imm.b, reg, reg, reg"
        ]
    },
    "andnpd": {
        "detail": [
            "Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "pmulhrw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "rdmsr": {
        "detail": [
            "Read from Model Specific Register"
        ],
        "description": [
            "reg, reg, reg, reg"
        ]
    },
    "v4fmaddps": {
        "detail": [
            "Packed Single-Precision Floating-Point Fused Multiply-Add (4-iterations)"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.z, mem.x"
        ]
    },
    "blendvpd": {
        "detail": [
            "Variable Blend Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "andnps": {
        "detail": [
            "Bitwise Logical AND NOT of Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vphaddubd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "mpsadbw": {
        "detail": [
            "Compute Multiple Packed Sums of Absolute Difference"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "vphaddubq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "blendvps": {
        "detail": [
            "Variable Blend Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "vphaddubw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vcvtps2pd": {
        "detail": [
            "Convert Packed Single-Precision Floating-Point Values to Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ]
    },
    "vmovsd": {
        "detail": [
            "Move or Merge Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.q, mem.q",
            "mem.q, reg.q, reg.x",
            "mem.q, reg.q",
            "reg.x, reg.x, reg.q"
        ]
    },
    "vcvtps2ph": {
        "detail": [
            "Convert Single-Precision FP value to 16-bit FP value"
        ],
        "description": [
            "mem.y, reg.q, reg.z, imm.b",
            "reg.y, reg.z, imm.b",
            "reg.y, reg.q, reg.z, imm.b",
            "mem.y, reg.z, imm.b"
        ]
    },
    "vpsrlvd": {
        "detail": [
            "Variable Bit Shift Right Logical"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "fimul": {
        "detail": [
            "Multiply"
        ],
        "description": [
            "reg.wq, mem.d, reg"
        ]
    },
    "vhaddpd": {
        "detail": [
            "Packed Double-FP Horizontal Add"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vmovddup": {
        "detail": [
            "Replicate Double FP Values"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vmovss": {
        "detail": [
            "Move or Merge Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.q, mem.d",
            "mem.d, reg.q, reg.x",
            "mem.d, reg.d",
            "reg.x, reg.x, reg.d"
        ]
    },
    "vpsrlvq": {
        "detail": [
            "Variable Bit Shift Right Logical"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vcvtss2usi": {
        "detail": [
            "Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.x"
        ]
    },
    "jnbe": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "vhaddps": {
        "detail": [
            "Packed Single-FP Horizontal Add"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpsrlvw": {
        "detail": [
            "Variable Bit Shift Right Logical"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vcvttsd2si": {
        "detail": [
            "Convert with Truncation Scalar Double-Precision Floating-Point Value to Signed Integer"
        ],
        "description": [
            "reg.d, mem.q",
            "reg.d, reg.q"
        ]
    },
    "vpshufb": {
        "detail": [
            "Packed Shuffle Bytes"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpshufd": {
        "detail": [
            "Shuffle Packed Doublewords"
        ],
        "description": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "punpckhwd": {
        "detail": [
            "Unpack High Data"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.d"
        ]
    },
    "vgetexppd": {
        "detail": [
            "Convert Exponents of Packed DP FP Values to DP FP Values"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vpternlogd": {
        "detail": [
            "Bitwise Ternary Logic"
        ],
        "description": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ]
    },
    "hreset": {
        "detail": [
            ""
        ],
        "description": [
            "imm.b, reg.d"
        ]
    },
    "subpd": {
        "detail": [
            "Subtract Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "pmulld": {
        "detail": [
            "Multiply Packed Integers and Store Low Result"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vpsrld": {
        "detail": [
            "Shift Packed Data Right Logical"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.z, reg.q, reg.z, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "test": {
        "detail": [
            "Logical Compare"
        ],
        "description": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "vinserti128": {
        "detail": [
            "Insert Packed Integer Values"
        ],
        "description": [
            "reg.y, reg.y, mem.x, imm.b",
            "reg.y, reg.y, reg.x, imm.b"
        ]
    },
    "vpternlogq": {
        "detail": [
            "Bitwise Ternary Logic"
        ],
        "description": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ]
    },
    "vcvttpd2uqq": {
        "detail": [
            "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vgetexpps": {
        "detail": [
            "Convert Exponents of Packed SP FP Values to SP FP Values"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vrangesd": {
        "detail": [
            "Range Restriction Calculation From a pair of Scalar Float64 Values"
        ],
        "description": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "subps": {
        "detail": [
            "Subtract Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vcvtps2qq": {
        "detail": [
            "Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.q",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vscalefpd": {
        "detail": [
            "Scale Packed Float64 Values With Float64 Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vpsrlq": {
        "detail": [
            "Shift Packed Data Right Logical"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.z, reg.q, reg.z, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "vmovdqu32": {
        "detail": [
            "Move Unaligned Packed Integer Values"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vsqrtpd": {
        "detail": [
            "Square Root of Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "gf2p8affineqb": {
        "detail": [
            "Galois Field Affine Transformation"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "movdir64b": {
        "detail": [
            "Move 64 Bytes as Direct Store"
        ],
        "description": [
            "reg, mem.z, mem.z"
        ]
    },
    "vpmovm2b": {
        "detail": [
            "Convert a Mask Register to a Vector Register"
        ],
        "description": [
            "reg.x, reg.q"
        ]
    },
    "vpsrlw": {
        "detail": [
            "Shift Packed Data Right Logical"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, mem.x, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.x, reg.q, reg.x, imm.b"
        ]
    },
    "vpmovm2d": {
        "detail": [
            "Convert a Mask Register to a Vector Register"
        ],
        "description": [
            "reg.x, reg.q"
        ]
    },
    "vrangess": {
        "detail": [
            "Range Restriction Calculation From a Pair of Scalar Float32 Values"
        ],
        "description": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "clts": {
        "detail": [
            "Clear Task-Switched Flag in CR0"
        ],
        "description": [
            ""
        ]
    },
    "paddd": {
        "detail": [
            "Add Packed Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "paddb": {
        "detail": [
            "Add Packed Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vscalefps": {
        "detail": [
            "Scale Packed Float32 Values With Float32 Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "kandb": {
        "detail": [
            "Bitwise Logical AND Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "kandd": {
        "detail": [
            "Bitwise Logical AND Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "vsqrtps": {
        "detail": [
            "Square Root of Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "movhlps": {
        "detail": [
            "Move Packed Single-Precision Floating-Point Values High to Low"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "vpmovm2q": {
        "detail": [
            "Convert a Mask Register to a Vector Register"
        ],
        "description": [
            "reg.x, reg.q"
        ]
    },
    "fdivrp": {
        "detail": [
            "Reverse Divide"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg"
        ]
    },
    "pmullw": {
        "detail": [
            "Multiply Packed Signed Integers and Store Low Result"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "senduipi": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d"
        ]
    },
    "paddq": {
        "detail": [
            "Add Packed Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpmovm2w": {
        "detail": [
            "Convert a Mask Register to a Vector Register"
        ],
        "description": [
            "reg.x, reg.q"
        ]
    },
    "kandq": {
        "detail": [
            "Bitwise Logical AND Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "paddw": {
        "detail": [
            "Add Packed Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "blsic": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "fnop": {
        "detail": [
            "No Operation"
        ],
        "description": [
            ""
        ]
    },
    "movdqa": {
        "detail": [
            "Move Aligned Packed Integer Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ]
    },
    "kandw": {
        "detail": [
            "Bitwise Logical AND Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "cvtps2pd": {
        "detail": [
            "Convert Packed Single-Precision Floating-Point Values to Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ]
    },
    "vphaddudq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "cvtps2pi": {
        "detail": [
            "Convert Packed Single-Precision FP Values to Packed Dword Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vroundsd": {
        "detail": [
            "Round Scalar Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.q, imm.b"
        ]
    },
    "vunpcklpd": {
        "detail": [
            "Unpack and Interleave Low Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "movdqu": {
        "detail": [
            "Move Unaligned Packed Integer Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ]
    },
    "vpgatherdd": {
        "detail": [
            "Gather Packed Dword, Packed Qword with Signed Dword Indices"
        ],
        "description": [
            "reg.z, reg.q, mem.d",
            "reg.y, mem.d, reg.y"
        ]
    },
    "vroundss": {
        "detail": [
            "Round Scalar Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.d, imm.b"
        ]
    },
    "vunpcklps": {
        "detail": [
            "Unpack and Interleave Low Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "clui": {
        "detail": [
            ""
        ],
        "description": [
            "reg.1"
        ]
    },
    "lock sbb": {
        "detail": [
            "Integer Subtraction with Borrow"
        ],
        "description": [
            "mem.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "xrstor": {
        "detail": [
            "Restore Processor Extended States"
        ],
        "description": [
            "mem.z[4096], reg, reg, reg"
        ]
    },
    "vpgatherdq": {
        "detail": [
            "Gather Packed Dword, Packed Qword with Signed Dword Indices"
        ],
        "description": [
            "reg.z, reg.q, mem.q",
            "reg.y, mem.q, reg.y"
        ]
    },
    "tpause": {
        "detail": [
            "Timed PAUSE"
        ],
        "description": [
            "reg.d, reg.d, reg.d"
        ]
    },
    "umonitor": {
        "detail": [
            "User Level Set Up Monitor Address"
        ],
        "description": [
            "reg"
        ]
    },
    "vmrun": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q"
        ]
    },
    "pmulhuw": {
        "detail": [
            "Multiply Packed Unsigned Integers and Store High Result"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "v4fmaddss": {
        "detail": [
            "Scalar Single-Precision Floating-Point Fused Multiply-Add (4-iterations)"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.x, mem.x"
        ]
    },
    "xsusldtrk": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "tileloaddt1": {
        "detail": [
            ""
        ],
        "description": [
            "reg, mem"
        ]
    },
    "vpmacsdqh": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "cqo": {
        "detail": [
            "Convert Word to Doubleword/Convert Doubleword to Quadword"
        ],
        "description": [
            "reg, reg"
        ]
    },
    "vpmacsdql": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "pfsub": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vorpd": {
        "detail": [
            "Bitwise Logical OR of Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "movntpd": {
        "detail": [
            "Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint"
        ],
        "description": [
            "mem.x, reg.x"
        ]
    },
    "vcomisd": {
        "detail": [
            "Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS"
        ],
        "description": [
            "reg.q, reg.q",
            "reg.q, mem.q"
        ]
    },
    "pcmpestrmq": {
        "detail": [
            "Packed Compare Explicit Length Strings, Return Mask"
        ],
        "description": [
            "reg.x, reg.x, imm.b, reg, reg, reg.x",
            "reg.x, mem.x, imm.b, reg, reg, reg.x"
        ]
    },
    "kshiftrb": {
        "detail": [
            "Shift Right Mask Registers"
        ],
        "description": [
            "reg.q, reg.q, imm.b"
        ]
    },
    "kshiftrd": {
        "detail": [
            "Shift Right Mask Registers"
        ],
        "description": [
            "reg.q, reg.q, imm.b"
        ]
    },
    "pfmin": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vorps": {
        "detail": [
            "Bitwise Logical OR of Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vcomiss": {
        "detail": [
            "Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS"
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "kshiftrq": {
        "detail": [
            "Shift Right Mask Registers"
        ],
        "description": [
            "reg.q, reg.q, imm.b"
        ]
    },
    "movntps": {
        "detail": [
            "Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint"
        ],
        "description": [
            "mem.x, reg.x"
        ]
    },
    "kshiftrw": {
        "detail": [
            "Shift Right Mask Registers"
        ],
        "description": [
            "reg.q, reg.q, imm.b"
        ]
    },
    "psubsb": {
        "detail": [
            "Subtract Packed Signed Integers with Signed Saturation"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vp4dpwssds": {
        "detail": [
            "Dot Product of Signed Words with Dword Accumulation and Saturation (4-iterations)"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.z, mem.x"
        ]
    },
    "unpcklpd": {
        "detail": [
            "Unpack and Interleave Low Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.q"
        ]
    },
    "vfrczpd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vgetexpsd": {
        "detail": [
            "Convert Exponents of Scalar DP FP Values to DP FP Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "pmaddwd": {
        "detail": [
            "Multiply and Add Packed Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vcvtne2ps2bf16": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpandnd": {
        "detail": [
            "Logical AND NOT"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "subsd": {
        "detail": [
            "Subtract Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vmaskmovdqu": {
        "detail": [
            "Conditional SIMD Packed Loads and Stores"
        ],
        "description": [
            "reg.x, reg.x, mem.x"
        ]
    },
    "and": {
        "detail": [
            "Logical AND"
        ],
        "description": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "vprold": {
        "detail": [
            "Bit Rotate Left"
        ],
        "description": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "unpcklps": {
        "detail": [
            "Unpack and Interleave Low Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.q"
        ]
    },
    "vfrczps": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vgetexpss": {
        "detail": [
            "Convert Exponents of Scalar SP FP Values to SP FP Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "clwb": {
        "detail": [
            "Cache Line Write Back"
        ],
        "description": [
            "mem.z"
        ]
    },
    "psubsw": {
        "detail": [
            "Subtract Packed Signed Integers with Signed Saturation"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpandnq": {
        "detail": [
            "Logical AND NOT"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "subss": {
        "detail": [
            "Subtract Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ]
    },
    "movq2dq": {
        "detail": [
            "Move Quadword from MMX Technology to XMM Register"
        ],
        "description": [
            "reg.x, reg.q"
        ]
    },
    "vscalefsd": {
        "detail": [
            "Scale Scalar Float64 Values With Float64 Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpbroadcastb": {
        "detail": [
            "Load with Broadcast Integer Data from General Purpose Register"
        ],
        "description": [
            "reg.x, mem.b",
            "reg.x, reg.b",
            "reg.x, reg.q, mem.b",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vprolq": {
        "detail": [
            "Bit Rotate Left"
        ],
        "description": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "vsqrtsd": {
        "detail": [
            "Compute Square Root of Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ]
    },
    "vpbroadcastd": {
        "detail": [
            "Load with Broadcast Integer Data from General Purpose Register"
        ],
        "description": [
            "reg.x, mem.d",
            "reg.x, reg.d",
            "reg.z, reg.q, mem.d",
            "reg.z, reg.q, reg.x"
        ]
    },
    "vmovdqu64": {
        "detail": [
            "Move Unaligned Packed Integer Values"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vscalefss": {
        "detail": [
            "Scale Scalar Float32 Value With Float32 Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpbroadcastq": {
        "detail": [
            "Load with Broadcast Integer Data from General Purpose Register"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.q",
            "reg.z, reg.q, reg.x"
        ]
    },
    "vsqrtss": {
        "detail": [
            "Compute Square Root of Scalar Single-Precision Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ]
    },
    "vpbroadcastw": {
        "detail": [
            "Load with Broadcast Integer Data from General Purpose Register"
        ],
        "description": [
            "reg.x, mem.w",
            "reg.x, reg.w",
            "reg.x, reg.q, mem.w",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vpbroadcastmb2q": {
        "detail": [
            "Broadcast Mask to Vector Register"
        ],
        "description": [
            "reg.z, reg.q"
        ]
    },
    "vpshrdd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vpshrdq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "cmpxchg": {
        "detail": [
            "Compare and Exchange"
        ],
        "description": [
            "reg.b, reg.b, reg",
            "mem.b, reg.b, reg"
        ]
    },
    "xsave64": {
        "detail": [
            "Save Processor Extended States"
        ],
        "description": [
            "mem.z[4096], reg, reg, reg"
        ]
    },
    "vpshrdw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "mulpd": {
        "detail": [
            "Multiply Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "sarx": {
        "detail": [
            "Shift Without Affecting Flags"
        ],
        "description": [
            "reg.d, reg.d, reg.d",
            "reg.d, mem.d, reg.d"
        ]
    },
    "cpuid": {
        "detail": [
            "CPU Identification"
        ],
        "description": [
            "reg, reg, reg, reg"
        ]
    },
    "vlddqu": {
        "detail": [
            "Load Unaligned Integer 128 Bits"
        ],
        "description": [
            "reg.x, mem.x"
        ]
    },
    "mulps": {
        "detail": [
            "Multiply Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vcvttps2uqq": {
        "detail": [
            "Convert with Truncation Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.q",
            "reg.x, reg.q, reg.x"
        ]
    },
    "tileloadd": {
        "detail": [
            ""
        ],
        "description": [
            "reg, mem"
        ]
    },
    "lock xor": {
        "detail": [
            "Logical Exclusive OR"
        ],
        "description": [
            "mem.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "vpermt2pd": {
        "detail": [
            "Full Permute from Two Tables Overwriting one Table"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "mulx": {
        "detail": [
            "Unsigned Multiply Without Affecting Flags"
        ],
        "description": [
            "reg.d, reg.d, reg.d, reg",
            "reg.d, reg.d, mem.d, reg"
        ]
    },
    "sha1msg1": {
        "detail": [
            "Perform an Intermediate Calculation for the Next Four SHA1 Message Dwords"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "sha1msg2": {
        "detail": [
            "Perform a Final Calculation for the Next Four SHA1 Message Dwords"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "repne lodsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.b, reg.q"
        ]
    },
    "repne lodsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.d, reg.q"
        ]
    },
    "vpermt2ps": {
        "detail": [
            "Full Permute from Two Tables Overwriting one Table"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "bndmov": {
        "detail": [
            "Move Bounds"
        ],
        "description": [
            "reg, mem.x",
            "reg, reg",
            "mem.x, reg"
        ]
    },
    "xadd": {
        "detail": [
            "Exchange and Add"
        ],
        "description": [
            "reg.b, reg.b",
            "mem.b, reg.b"
        ]
    },
    "xchg": {
        "detail": [
            "Exchange Register/Memory with Register"
        ],
        "description": [
            "reg.b, reg.b",
            "mem.b, reg.b"
        ]
    },
    "repne lodsq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.q, reg.q"
        ]
    },
    "repne lodsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.w, reg.q"
        ]
    },
    "verr": {
        "detail": [
            "Verify a Segment for Reading or Writing"
        ],
        "description": [
            "reg.w",
            "mem.w"
        ]
    },
    "verw": {
        "detail": [
            "Verify a Segment for Reading or Writing"
        ],
        "description": [
            "reg.w",
            "mem.w"
        ]
    },
    "wrfsbase": {
        "detail": [
            "Write FS/GS Segment Base"
        ],
        "description": [
            "reg.d, reg.d"
        ]
    },
    "vpmacsdd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "movntsd": {
        "detail": [
            ""
        ],
        "description": [
            "mem.q, reg.q"
        ]
    },
    "fidiv": {
        "detail": [
            "Divide"
        ],
        "description": [
            "reg.wq, mem.d, reg"
        ]
    },
    "bswap": {
        "detail": [
            "Byte Swap"
        ],
        "description": [
            "reg.d"
        ]
    },
    "adox": {
        "detail": [
            "Unsigned Integer Addition of Two Operands with Overflow Flag"
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "pslldq": {
        "detail": [
            "Shift Double Quadword Left Logical"
        ],
        "description": [
            "reg.x, imm.b"
        ]
    },
    "movntss": {
        "detail": [
            ""
        ],
        "description": [
            "mem.d, reg.d"
        ]
    },
    "vgatherpf0qpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint"
        ],
        "description": [
            "mem.q, reg.q"
        ]
    },
    "repe xcryptctr": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.b, reg, reg.d, reg, reg.q, mem.b"
        ]
    },
    "vpunpcklwd": {
        "detail": [
            "Unpack Low Data"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "fcmovbe": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "vpmovsxbd": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "description": [
            "reg.x, mem.d",
            "reg.x, reg.d",
            "reg.z, reg.q, mem.x",
            "reg.z, reg.q, reg.x"
        ]
    },
    "vfrczsd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ]
    },
    "vgatherpf0qps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint"
        ],
        "description": [
            "mem.d, reg.q"
        ]
    },
    "movapd": {
        "detail": [
            "Move Aligned Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ]
    },
    "vpmovsxbq": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "description": [
            "reg.x, mem.w",
            "reg.x, reg.w",
            "reg.z, reg.q, mem.q",
            "reg.z, reg.q, reg.x"
        ]
    },
    "fldl2e": {
        "detail": [
            "Load Constant"
        ],
        "description": [
            "reg.wq, reg, reg"
        ]
    },
    "vpmovsxbw": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.x, reg.q, mem.q",
            "reg.x, reg.q, reg.x"
        ]
    },
    "bsf": {
        "detail": [
            "Bit Scan Forward"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "vfrczss": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.d",
            "reg.x, reg.d"
        ]
    },
    "movaps": {
        "detail": [
            "Move Aligned Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ]
    },
    "fldl2t": {
        "detail": [
            "Load Constant"
        ],
        "description": [
            "reg.wq, reg, reg"
        ]
    },
    "fiadd": {
        "detail": [
            "Add"
        ],
        "description": [
            "reg.wq, mem.d, reg"
        ]
    },
    "vpmovsdb": {
        "detail": [
            "Down Convert DWord to Byte"
        ],
        "description": [
            "reg.x, reg.z",
            "mem.x, reg.q, reg.z",
            "mem.x, reg.z",
            "reg.x, reg.q, reg.z"
        ]
    },
    "vmovlpd": {
        "detail": [
            "Move Low Packed Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.x, mem.q",
            "mem.q, reg.q"
        ]
    },
    "ptest": {
        "detail": [
            "Logical Compare"
        ],
        "description": [
            "reg.x, reg.x",
            "reg.x, mem.x"
        ]
    },
    "bsr": {
        "detail": [
            "Bit Scan Reverse"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "fxtract": {
        "detail": [
            "Extract Exponent and Significand"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "kunpckwd": {
        "detail": [
            "Unpack for Mask Registers"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "vmovlps": {
        "detail": [
            "Move Low Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, mem.q",
            "mem.q, reg.q"
        ]
    },
    "vpmovsdw": {
        "detail": [
            "Down Convert DWord to Word"
        ],
        "description": [
            "reg.y, reg.z",
            "mem.y, reg.q, reg.z",
            "mem.y, reg.z",
            "reg.y, reg.q, reg.z"
        ]
    },
    "vpmovmskb": {
        "detail": [
            "Move Byte Mask"
        ],
        "description": [
            "reg.d, reg.x"
        ]
    },
    "aesencwide256kl": {
        "detail": [
            ""
        ],
        "description": [
            "mem.z, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x"
        ]
    },
    "sysret": {
        "detail": [
            "Return From Fast System Call"
        ],
        "description": [
            "reg.q, reg, reg"
        ]
    },
    "vcvtpd2dq": {
        "detail": [
            "Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.y, reg.q, mem.z",
            "reg.y, reg.q, reg.z"
        ]
    },
    "vpermil2pd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x, imm.b",
            "reg.x, reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, mem.x, reg.x, imm.b"
        ]
    },
    "xsetbv": {
        "detail": [
            "Set Extended Control Register"
        ],
        "description": [
            "reg, reg, reg, reg"
        ]
    },
    "xend": {
        "detail": [
            "Transactional End"
        ],
        "description": [
            ""
        ]
    },
    "btc": {
        "detail": [
            "Bit Test and Complement"
        ],
        "description": [
            "reg.w, reg.w",
            "mem.w, imm.b",
            "reg.w, imm.b",
            "mem.w, reg.w"
        ]
    },
    "mulsd": {
        "detail": [
            "Multiply Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpermil2ps": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x, imm.b",
            "reg.x, reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, mem.x, reg.x, imm.b"
        ]
    },
    "rmpupdate": {
        "detail": [
            ""
        ],
        "description": [
            "reg, reg"
        ]
    },
    "btr": {
        "detail": [
            "Bit Test and Reset"
        ],
        "description": [
            "reg.w, reg.w",
            "mem.w, imm.b",
            "reg.w, imm.b",
            "mem.w, reg.w"
        ]
    },
    "bts": {
        "detail": [
            "Bit Test and Set"
        ],
        "description": [
            "reg.w, reg.w",
            "mem.w, imm.b",
            "reg.w, imm.b",
            "mem.w, reg.w"
        ]
    },
    "tzcnt": {
        "detail": [
            "Count the Number of Trailing Zero Bits"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "mulss": {
        "detail": [
            "Multiply Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ]
    },
    "fild": {
        "detail": [
            "Load Integer"
        ],
        "description": [
            "reg.wq, mem.d, reg, reg"
        ]
    },
    "seamops": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q"
        ]
    },
    "pmovsxbd": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "description": [
            "reg.x, mem.d",
            "reg.x, reg.d"
        ]
    },
    "vpmulhrsw": {
        "detail": [
            "Packed Multiply High with Round and Scale"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "bt": {
        "detail": [
            "Bit Test"
        ],
        "description": [
            "reg.w, reg.w",
            "mem.w, imm.b",
            "reg.w, imm.b",
            "mem.w, reg.w"
        ]
    },
    "pmovsxbq": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "description": [
            "reg.x, mem.w",
            "reg.x, reg.w"
        ]
    },
    "pmovsxbw": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ]
    },
    "pswapd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpmovsxdq": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ]
    },
    "fprem1": {
        "detail": [
            "Partial Remainder"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "cwd": {
        "detail": [
            "Convert Word to Doubleword/Convert Doubleword to Quadword"
        ],
        "description": [
            "reg, reg"
        ]
    },
    "wrussd": {
        "detail": [
            ""
        ],
        "description": [
            "mem.d, reg.d"
        ]
    },
    "slwpcb": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d"
        ]
    },
    "wrussq": {
        "detail": [
            ""
        ],
        "description": [
            "mem.q, reg.q"
        ]
    },
    "roundpd": {
        "detail": [
            "Round Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "wrpkru": {
        "detail": [
            "Write Data to User Page Key Register"
        ],
        "description": [
            "reg, reg, reg"
        ]
    },
    "vmovd": {
        "detail": [
            "Move Doubleword/Move Quadword"
        ],
        "description": [
            "reg.x, mem.d",
            "reg.x, reg.d",
            "mem.d, reg.d"
        ]
    },
    "fmul": {
        "detail": [
            "Multiply"
        ],
        "description": [
            "reg.wq, mem.d, reg",
            "reg.wq, reg.wq, reg"
        ]
    },
    "wrssd": {
        "detail": [
            ""
        ],
        "description": [
            "mem.d, reg.d"
        ]
    },
    "pmovmskb": {
        "detail": [
            "Move Byte Mask"
        ],
        "description": [
            "reg.d, reg.q"
        ]
    },
    "ucomisd": {
        "detail": [
            "Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS"
        ],
        "description": [
            "reg.q, reg.q",
            "reg.q, mem.q"
        ]
    },
    "roundps": {
        "detail": [
            "Round Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "vphsubd": {
        "detail": [
            "Packed Horizontal Subtract"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vmovq": {
        "detail": [
            "Move Quadword"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "mem.q, reg.q"
        ]
    },
    "cvtpd2dq": {
        "detail": [
            "Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "fldcw": {
        "detail": [
            "Load x87 FPU Control Word"
        ],
        "description": [
            "mem.w, reg, reg"
        ]
    },
    "wrssq": {
        "detail": [
            ""
        ],
        "description": [
            "mem.q, reg.q"
        ]
    },
    "cmpxchg16b": {
        "detail": [
            "Compare and Exchange Bytes"
        ],
        "description": [
            "mem.x, reg, reg, reg, reg"
        ]
    },
    "tilerelease": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "vgatherpf1qpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint"
        ],
        "description": [
            "mem.q, reg.q"
        ]
    },
    "ucomiss": {
        "detail": [
            "Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS"
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "vpdpwssds": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vphsubw": {
        "detail": [
            "Packed Horizontal Subtract"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vgatherpf1qps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint"
        ],
        "description": [
            "mem.d, reg.q"
        ]
    },
    "vshufpd": {
        "detail": [
            "Packed Interleave Shuffle of Pairs of Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vpsadbw": {
        "detail": [
            "Compute Sum of Absolute Differences"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "lodsd": {
        "detail": [
            "Load String"
        ],
        "description": [
            "reg, mem.d"
        ]
    },
    "vunpckhpd": {
        "detail": [
            "Unpack and Interleave High Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vprord": {
        "detail": [
            "Bit Rotate Right"
        ],
        "description": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "lodsb": {
        "detail": [
            "Load String"
        ],
        "description": [
            "reg, mem.b"
        ]
    },
    "vpshab": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "vpcmpestri": {
        "detail": [
            "Packed Compare Explicit Length Strings, Return Index"
        ],
        "description": [
            "reg.x, reg.x, imm.b, reg, reg, reg",
            "reg.x, mem.x, imm.b, reg, reg, reg"
        ]
    },
    "vpshad": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "vpcmpestrm": {
        "detail": [
            "Packed Compare Explicit Length Strings, Return Mask"
        ],
        "description": [
            "reg.x, reg.x, imm.b, reg, reg, reg.x",
            "reg.x, mem.x, imm.b, reg, reg, reg.x"
        ]
    },
    "vprorq": {
        "detail": [
            "Bit Rotate Right"
        ],
        "description": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "serialize": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "vshufps": {
        "detail": [
            "Packed Interleave Shuffle of Quadruplets of Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vunpckhps": {
        "detail": [
            "Unpack and Interleave High Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpinsrb": {
        "detail": [
            "Insert Byte/Dword/Qword"
        ],
        "description": [
            "reg.x, reg.x, mem.b, imm.b",
            "reg.x, reg.x, reg.d, imm.b"
        ]
    },
    "vfmadd213pd": {
        "detail": [
            "Fused Multiply-Add of Packed Double- Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vpinsrd": {
        "detail": [
            "Insert Byte/Dword/Qword"
        ],
        "description": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.d, imm.b"
        ]
    },
    "jnle": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "lodsw": {
        "detail": [
            "Load String"
        ],
        "description": [
            "reg, mem.w"
        ]
    },
    "lodsq": {
        "detail": [
            "Load String"
        ],
        "description": [
            "reg, mem.q"
        ]
    },
    "vpshaq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "vcvtsd2si": {
        "detail": [
            "Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer"
        ],
        "description": [
            "reg.d, mem.q",
            "reg.d, reg.q"
        ]
    },
    "pmulhrsw": {
        "detail": [
            "Packed Multiply High with Round and Scale"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "movddup": {
        "detail": [
            "Replicate Double FP Values"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ]
    },
    "vpshaw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "vpinsrq": {
        "detail": [
            "Insert Byte/Dword/Qword"
        ],
        "description": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.q, imm.b"
        ]
    },
    "vfmadd213ps": {
        "detail": [
            "Fused Multiply-Add of Packed Single- Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vcvtsd2ss": {
        "detail": [
            "Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ]
    },
    "xsavec64": {
        "detail": [
            "Save Processor Extended States with Compaction"
        ],
        "description": [
            "mem.z[4096], reg, reg, reg"
        ]
    },
    "vpinsrw": {
        "detail": [
            "Insert Word"
        ],
        "description": [
            "reg.x, reg.x, mem.w, imm.b",
            "reg.x, reg.x, reg.d, imm.b"
        ]
    },
    "vpmaxsb": {
        "detail": [
            "Maximum of Packed Signed Integers"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpmaxsd": {
        "detail": [
            "Maximum of Packed Signed Integers"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "pfcmpeq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vcvttpd2qq": {
        "detail": [
            "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Quadword Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vpmaskmovd": {
        "detail": [
            "Conditional SIMD Integer Packed Loads and Stores"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "mem.x, reg.x, reg.x"
        ]
    },
    "pmovsxdq": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ]
    },
    "vpackssdw": {
        "detail": [
            "Pack with Signed Saturation"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpmaxsq": {
        "detail": [
            "Maximum of Packed Signed Integers"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vpmaddubsw": {
        "detail": [
            "Multiply and Add Packed Signed and Unsigned Bytes"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpmaskmovq": {
        "detail": [
            "Conditional SIMD Integer Packed Loads and Stores"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "mem.x, reg.x, reg.x"
        ]
    },
    "vpmaxsw": {
        "detail": [
            "Maximum of Packed Signed Integers"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vbroadcasti32x2": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.q",
            "reg.x, reg.q, reg.x"
        ]
    },
    "fxsave64": {
        "detail": [
            "Save x87 FPU, MMX Technology, and SSE State"
        ],
        "description": [
            "mem.[4096], reg"
        ]
    },
    "vbroadcasti32x4": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "description": [
            "reg.z, mem.x",
            "reg.z, reg.q, mem.x"
        ]
    },
    "vbroadcasti32x8": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "description": [
            "reg.z, mem.y",
            "reg.z, reg.q, mem.y"
        ]
    },
    "vaeskeygenassist": {
        "detail": [
            "AES Round Key Generation Assist"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "wrgsbase": {
        "detail": [
            "Write FS/GS Segment Base"
        ],
        "description": [
            "reg.d, reg.d"
        ]
    },
    "vmovlhps": {
        "detail": [
            "Move Packed Single-Precision Floating-Point Values Low to High"
        ],
        "description": [
            "reg.x, reg.q, reg.q"
        ]
    },
    "clrssbsy": {
        "detail": [
            ""
        ],
        "description": [
            "mem.q"
        ]
    },
    "vcompresspd": {
        "detail": [
            "Store Sparse Packed Double-Precision Floating-Point Values into Dense Memory"
        ],
        "description": [
            "reg.z, reg.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vpandd": {
        "detail": [
            "Logical AND"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "pxor": {
        "detail": [
            "Logical Exclusive OR"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpandn": {
        "detail": [
            "Logical AND NOT"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vcompressps": {
        "detail": [
            "Store Sparse Packed Single-Precision Floating-Point Values into Dense Memory"
        ],
        "description": [
            "reg.z, reg.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vpandq": {
        "detail": [
            "Logical AND"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "unpckhpd": {
        "detail": [
            "Unpack and Interleave High Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.q"
        ]
    },
    "repne cmpsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.b, mem.b, reg.q"
        ]
    },
    "repne cmpsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.d, mem.d, reg.q"
        ]
    },
    "vdpbf16ps": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vprotb": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "vprotd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "repne scasb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.b, reg.q"
        ]
    },
    "repne scasd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.d, reg.q"
        ]
    },
    "unpckhps": {
        "detail": [
            "Unpack and Interleave High Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "repne cmpsq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.q, mem.q, reg.q"
        ]
    },
    "vpunpckhqdq": {
        "detail": [
            "Unpack High Data"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "repne cmpsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.w, mem.w, reg.q"
        ]
    },
    "roundsd": {
        "detail": [
            "Round Scalar Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.q, reg.q, imm.b",
            "reg.q, mem.q, imm.b"
        ]
    },
    "vphsubsw": {
        "detail": [
            "Packed Horizontal Subtract and Saturate"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "cvtsd2si": {
        "detail": [
            "Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer"
        ],
        "description": [
            "reg.d, mem.q",
            "reg.d, reg.q"
        ]
    },
    "vphaddbd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "repne scasq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.q, reg.q"
        ]
    },
    "vprotq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "vprotw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "vpaddusb": {
        "detail": [
            "Add Packed Unsigned Integers with Unsigned Saturation"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "repne scasw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.w, reg.q"
        ]
    },
    "cvtsd2ss": {
        "detail": [
            "Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.d, mem.q",
            "reg.d, reg.q"
        ]
    },
    "vphaddbq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "pfcmpge": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "lfence": {
        "detail": [
            "Load Fence"
        ],
        "description": [
            ""
        ]
    },
    "roundss": {
        "detail": [
            "Round Scalar Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.d, reg.d, imm.b",
            "reg.d, mem.d, imm.b"
        ]
    },
    "vphaddbw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "packssdw": {
        "detail": [
            "Pack with Signed Saturation"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpmaxub": {
        "detail": [
            "Maximum of Packed Unsigned Integers"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpmaxud": {
        "detail": [
            "Maximum of Packed Unsigned Integers"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "lldt": {
        "detail": [
            "Load Local Descriptor Table Register"
        ],
        "description": [
            "reg.w, reg",
            "mem.w, reg"
        ]
    },
    "vpaddusw": {
        "detail": [
            "Add Packed Unsigned Integers with Unsigned Saturation"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "pfcmpgt": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpshufbitqmb": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.q, reg.x, mem.x",
            "reg.q, reg.x, reg.x"
        ]
    },
    "vpmaxuq": {
        "detail": [
            "Maximum of Packed Unsigned Integers"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "xsaveopt": {
        "detail": [
            "Save Processor Extended States Optimized"
        ],
        "description": [
            "mem.z[4096], reg, reg, reg"
        ]
    },
    "vpmaxuw": {
        "detail": [
            "Maximum of Packed Unsigned Integers"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vgatherdpd": {
        "detail": [
            "Gather Packed Single, Packed Double with Signed Dword"
        ],
        "description": [
            "reg.z, reg.q, mem.q",
            "reg.y, mem.q, reg.y"
        ]
    },
    "vshufi32x4": {
        "detail": [
            "Shuffle Packed Values at 128-bit Granularity"
        ],
        "description": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ]
    },
    "vpslld": {
        "detail": [
            "Shift Packed Data Left Logical"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.z, reg.q, reg.z, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "cmppd": {
        "detail": [
            "Compare Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "enqcmd": {
        "detail": [
            ""
        ],
        "description": [
            "reg, mem.z"
        ]
    },
    "lock xadd": {
        "detail": [
            "Exchange and Add"
        ],
        "description": [
            "mem.b, reg.b"
        ]
    },
    "vgatherdps": {
        "detail": [
            "Gather Packed Single, Packed Double with Signed Dword"
        ],
        "description": [
            "reg.z, reg.q, mem.d",
            "reg.y, mem.d, reg.y"
        ]
    },
    "vfmadd213sd": {
        "detail": [
            "Fused Multiply-Add of Scalar Double- Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpsllq": {
        "detail": [
            "Shift Packed Data Left Logical"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.z, reg.q, reg.z, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "loopne": {
        "detail": [
            "Loop According to ECX Counter"
        ],
        "description": [
            "relbr.b, reg.q, reg.q"
        ]
    },
    "vfnmaddpd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "vpsllw": {
        "detail": [
            "Shift Packed Data Left Logical"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, mem.x, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.x, reg.q, reg.x, imm.b"
        ]
    },
    "cmpps": {
        "detail": [
            "Compare Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "vfmadd213ss": {
        "detail": [
            "Fused Multiply-Add of Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "aesdecwide128kl": {
        "detail": [
            ""
        ],
        "description": [
            "mem.xy, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x"
        ]
    },
    "vfnmaddps": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "vandpd": {
        "detail": [
            "Bitwise Logical AND of Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpmuludq": {
        "detail": [
            "Multiply Packed Unsigned Doubleword Integers"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vandps": {
        "detail": [
            "Bitwise Logical AND of Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "xstore": {
        "detail": [
            ""
        ],
        "description": [
            "mem.b, reg, reg.d, reg.d"
        ]
    },
    "insb": {
        "detail": [
            "Input from Port to String"
        ],
        "description": [
            "mem.b, reg"
        ]
    },
    "cdqe": {
        "detail": [
            "Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword"
        ],
        "description": [
            "reg, reg"
        ]
    },
    "insd": {
        "detail": [
            "Input from Port to String"
        ],
        "description": [
            "mem.d, reg"
        ]
    },
    "movdq2q": {
        "detail": [
            "Move Quadword from XMM to MMX Technology Register"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "ficom": {
        "detail": [
            "Compare Integer"
        ],
        "description": [
            "reg.wq, mem.w, reg"
        ]
    },
    "vpord": {
        "detail": [
            "Bitwise Logical OR"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vphadddq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "stac": {
        "detail": [
            "Set AC Flag in EFLAGS Register"
        ],
        "description": [
            ""
        ]
    },
    "insw": {
        "detail": [
            "Input from Port to String"
        ],
        "description": [
            "mem.w, reg"
        ]
    },
    "vporq": {
        "detail": [
            "Bitwise Logical OR"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "blcmsk": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "fabs": {
        "detail": [
            "Absolute Value"
        ],
        "description": [
            "reg.wq, reg"
        ]
    },
    "vpunpckhwd": {
        "detail": [
            "Unpack High Data"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "lock cmpxchg16b": {
        "detail": [
            "Compare and Exchange Bytes"
        ],
        "description": [
            "mem.x, reg, reg, reg, reg"
        ]
    },
    "vpscatterdd": {
        "detail": [
            "Scatter Packed Dword, Packed Qword with Signed Dword, Signed Qword Indices"
        ],
        "description": [
            "mem.d, reg.q, reg.z"
        ]
    },
    "int3": {
        "detail": [
            "Call to Interrupt Procedure"
        ],
        "description": [
            "reg.q"
        ]
    },
    "fnclex": {
        "detail": [
            "Clear Exceptions"
        ],
        "description": [
            "reg"
        ]
    },
    "vpscatterdq": {
        "detail": [
            "Scatter Packed Dword, Packed Qword with Signed Dword, Signed Qword Indices"
        ],
        "description": [
            "mem.q, reg.q, reg.z"
        ]
    },
    "vpgatherqd": {
        "detail": [
            "Gather Packed Dword, Packed Qword with Signed Qword Indices"
        ],
        "description": [
            "reg.y, reg.q, mem.d",
            "reg.x, mem.d, reg.x"
        ]
    },
    "maskmovq": {
        "detail": [
            "Store Selected Bytes of Quadword"
        ],
        "description": [
            "reg.q, reg.q, mem.q"
        ]
    },
    "vdivpd": {
        "detail": [
            "Divide Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vextracti32x4": {
        "detail": [
            "Extract packed Integer Values"
        ],
        "description": [
            "mem.x, reg.q, reg.z, imm.b",
            "reg.x, reg.z, imm.b",
            "reg.x, reg.q, reg.z, imm.b",
            "mem.x, reg.z, imm.b"
        ]
    },
    "vextracti32x8": {
        "detail": [
            "Extract packed Integer Values"
        ],
        "description": [
            "mem.y, reg.q, reg.z, imm.b",
            "reg.y, reg.z, imm.b",
            "reg.y, reg.q, reg.z, imm.b",
            "mem.y, reg.z, imm.b"
        ]
    },
    "vmovhpd": {
        "detail": [
            "Move High Packed Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.q, mem.q",
            "mem.q, reg.x"
        ]
    },
    "vpgatherqq": {
        "detail": [
            "Gather Packed Dword, Packed Qword with Signed Qword Indices"
        ],
        "description": [
            "reg.z, reg.q, mem.q",
            "reg.y, mem.q, reg.y"
        ]
    },
    "lock neg": {
        "detail": [
            "Two's Complement Negation"
        ],
        "description": [
            "mem.b"
        ]
    },
    "vdivps": {
        "detail": [
            "Divide Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vrsqrtps": {
        "detail": [
            "Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "call": {
        "detail": [
            "Call Procedure"
        ],
        "description": [
            "reg.q, reg.q, reg.q, mem.q",
            "mem.q, reg.q, reg.q, mem.q",
            "relbr.d, reg.q, reg.q, mem.q"
        ]
    },
    "vmaxpd": {
        "detail": [
            "Maximum of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vmovhps": {
        "detail": [
            "Move High Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, mem.q",
            "mem.q, reg.x"
        ]
    },
    "pfmul": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "in": {
        "detail": [
            "Input from Port"
        ],
        "description": [
            "reg, reg",
            "reg, imm.b"
        ]
    },
    "invlpgb": {
        "detail": [
            ""
        ],
        "description": [
            "reg, reg, reg"
        ]
    },
    "fist": {
        "detail": [
            "Store Integer"
        ],
        "description": [
            "mem.d, reg.wq, reg"
        ]
    },
    "invlpga": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, reg"
        ]
    },
    "fdiv": {
        "detail": [
            "Divide"
        ],
        "description": [
            "reg.wq, mem.d, reg",
            "reg.wq, reg.wq, reg"
        ]
    },
    "vpmuldq": {
        "detail": [
            "Multiply Packed Doubleword Integers"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "insertq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, reg.q, imm.b, imm.b",
            "reg.q, reg.x"
        ]
    },
    "vblendpd": {
        "detail": [
            "Blend Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vmaxps": {
        "detail": [
            "Maximum of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "fyl2x": {
        "detail": [
            "Compute y * log2x"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg"
        ]
    },
    "vblendmpd": {
        "detail": [
            "Blend Float64/Float32 Vectors Using an OpMask Control"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vblendps": {
        "detail": [
            "Blend Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vphsubwd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vptestmb": {
        "detail": [
            "Logical AND and Set Mask"
        ],
        "description": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.q, reg.x, mem.x",
            "reg.q, reg.x, reg.x"
        ]
    },
    "vptestmd": {
        "detail": [
            "Logical AND and Set Mask"
        ],
        "description": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.q, reg.z, mem.z",
            "reg.q, reg.z, reg.z"
        ]
    },
    "vblendmps": {
        "detail": [
            "Blend Float64/Float32 Vectors Using an OpMask Control"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vbroadcasti64x2": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "description": [
            "reg.y, mem.x",
            "reg.y, reg.q, mem.x"
        ]
    },
    "cmpsd": {
        "detail": [
            "Compare String Operands"
        ],
        "description": [
            "mem.d, mem.d",
            "reg.q, reg.q, imm.b",
            "reg.q, mem.q, imm.b"
        ]
    },
    "vbroadcasti64x4": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "description": [
            "reg.z, mem.y",
            "reg.z, reg.q, mem.y"
        ]
    },
    "vptestmq": {
        "detail": [
            "Logical AND and Set Mask"
        ],
        "description": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.q, reg.z, mem.z",
            "reg.q, reg.z, reg.z"
        ]
    },
    "cmpsb": {
        "detail": [
            "Compare String Operands"
        ],
        "description": [
            "mem.b, mem.b"
        ]
    },
    "vptestmw": {
        "detail": [
            "Logical AND and Set Mask"
        ],
        "description": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.q, reg.x, mem.x",
            "reg.q, reg.x, reg.x"
        ]
    },
    "scasb": {
        "detail": [
            "Scan String"
        ],
        "description": [
            "reg, mem.b"
        ]
    },
    "jb": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "vfnmaddsd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.q, mem.q",
            "reg.x, reg.q, reg.q, reg.q",
            "reg.x, reg.q, mem.q, reg.q"
        ]
    },
    "cmpsq": {
        "detail": [
            "Compare String Operands"
        ],
        "description": [
            "mem.q, mem.q"
        ]
    },
    "scasd": {
        "detail": [
            "Scan String"
        ],
        "description": [
            "reg, mem.d"
        ]
    },
    "cmpss": {
        "detail": [
            "Compare Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.d, reg.d, imm.b",
            "reg.d, mem.d, imm.b"
        ]
    },
    "fadd": {
        "detail": [
            "Add"
        ],
        "description": [
            "reg.wq, mem.d, reg",
            "reg.wq, reg.wq, reg"
        ]
    },
    "cmpsw": {
        "detail": [
            "Compare String Operands"
        ],
        "description": [
            "mem.w, mem.w"
        ]
    },
    "jl": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "jo": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "jp": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "scasq": {
        "detail": [
            "Scan String"
        ],
        "description": [
            "reg, mem.q"
        ]
    },
    "js": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "xrstors64": {
        "detail": [
            "Restore Processor Extended States Supervisor"
        ],
        "description": [
            "mem.z[4096], reg, reg, reg"
        ]
    },
    "scasw": {
        "detail": [
            "Scan String"
        ],
        "description": [
            "reg, mem.w"
        ]
    },
    "vfnmaddss": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.d, reg.d, mem.d",
            "reg.x, reg.d, reg.d, reg.d",
            "reg.x, reg.d, mem.d, reg.d"
        ]
    },
    "jz": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "fchs": {
        "detail": [
            "Change Sign"
        ],
        "description": [
            "reg.wq, reg"
        ]
    },
    "vpshldd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "cmovbe": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "vpackusdw": {
        "detail": [
            "Pack with Unsigned Saturation"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpshldq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vpshldw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "invd": {
        "detail": [
            "Invalidate Internal Caches"
        ],
        "description": [
            ""
        ]
    },
    "vgf2p8affineinvqb": {
        "detail": [
            "Galois Field Affine Transformation Inverse"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "korb": {
        "detail": [
            "Bitwise Logical OR Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "kord": {
        "detail": [
            "Bitwise Logical OR Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "psignd": {
        "detail": [
            "Packed SIGN"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "psignb": {
        "detail": [
            "Packed SIGN"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "fsubrp": {
        "detail": [
            "Reverse Subtract"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg"
        ]
    },
    "fisttp": {
        "detail": [
            "Store Integer with Truncation"
        ],
        "description": [
            "mem.d, reg.wq, reg, reg"
        ]
    },
    "korq": {
        "detail": [
            "Bitwise Logical OR Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "loop": {
        "detail": [
            "Loop According to ECX Counter"
        ],
        "description": [
            "relbr.b, reg.q, reg.q"
        ]
    },
    "mfence": {
        "detail": [
            "Memory Fence"
        ],
        "description": [
            ""
        ]
    },
    "korw": {
        "detail": [
            "Bitwise Logical OR Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "psignw": {
        "detail": [
            "Packed SIGN"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vrcpps": {
        "detail": [
            "Compute Reciprocals of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "movbe": {
        "detail": [
            "Move Data After Swapping Bytes"
        ],
        "description": [
            "reg.w, mem.w",
            "mem.w, reg.w"
        ]
    },
    "vshufi64x2": {
        "detail": [
            "Shuffle Packed Values at 128-bit Granularity"
        ],
        "description": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ]
    },
    "kxorb": {
        "detail": [
            "Bitwise Logical XOR Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "vcvttsd2usi": {
        "detail": [
            "Convert with Truncation Scalar Double-Precision Floating-Point Value to Unsigned Integer"
        ],
        "description": [
            "reg.d, mem.q",
            "reg.d, reg.x"
        ]
    },
    "kxord": {
        "detail": [
            "Bitwise Logical XOR Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "addpd": {
        "detail": [
            "Add Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vdivsd": {
        "detail": [
            "Divide Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ]
    },
    "vmlaunch": {
        "detail": [
            "Launch/Resume Virtual Machine"
        ],
        "description": [
            ""
        ]
    },
    "kxorq": {
        "detail": [
            "Bitwise Logical XOR Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "repe lodsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.b, reg.q"
        ]
    },
    "ud2": {
        "detail": [
            "Undefined Instruction"
        ],
        "description": [
            ""
        ]
    },
    "repe lodsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.d, reg.q"
        ]
    },
    "vdivss": {
        "detail": [
            "Divide Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ]
    },
    "vrsqrtss": {
        "detail": [
            "Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ]
    },
    "kxorw": {
        "detail": [
            "Bitwise Logical XOR Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "imul": {
        "detail": [
            "Signed Multiply"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, reg.w, imm.w",
            "reg.w, mem.w",
            "reg.b, reg, reg",
            "reg.w, mem.w, imm.w",
            "mem.b, reg, reg"
        ]
    },
    "vmaxsd": {
        "detail": [
            "Return Maximum Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ]
    },
    "sha1rnds4": {
        "detail": [
            "Perform Four Rounds of SHA1 Operation"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "fcmovnb": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "cldemote": {
        "detail": [
            "Cache Line Demote"
        ],
        "description": [
            "mem.b"
        ]
    },
    "addps": {
        "detail": [
            "Add Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "fcmovne": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "frndint": {
        "detail": [
            "Round to Integer"
        ],
        "description": [
            "reg.wq, reg"
        ]
    },
    "vpalignr": {
        "detail": [
            "Packed Align Right"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "repe lodsq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.q, reg.q"
        ]
    },
    "packusdw": {
        "detail": [
            "Pack with Unsigned Saturation"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "lidt": {
        "detail": [
            "Load Global/Interrupt Descriptor Table Register"
        ],
        "description": [
            "mem.wq, reg"
        ]
    },
    "vmaxss": {
        "detail": [
            "Return Maximum Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ]
    },
    "repe lodsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.w, reg.q"
        ]
    },
    "fcmovnu": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "vpshldvd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpshldvq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpshldvw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "fsqrt": {
        "detail": [
            "Square Root"
        ],
        "description": [
            "reg.wq, reg"
        ]
    },
    "vpmovd2m": {
        "detail": [
            "Convert a Vector Register to a Mask"
        ],
        "description": [
            "reg.q, reg.x"
        ]
    },
    "psubb": {
        "detail": [
            "Subtract Packed Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "psubd": {
        "detail": [
            "Subtract Packed Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vcvtpd2ps": {
        "detail": [
            "Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.y, reg.q, mem.z",
            "reg.y, reg.q, reg.z"
        ]
    },
    "vpmulhw": {
        "detail": [
            "Multiply Packed Signed Integers and Store High Result"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "monitor": {
        "detail": [
            "Set Up Monitor Address"
        ],
        "description": [
            "reg, reg, reg"
        ]
    },
    "psubq": {
        "detail": [
            "Subtract Packed Quadword Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "sar": {
        "detail": [
            "Shift"
        ],
        "description": [
            "mem.b, imm.b",
            "reg.b, reg",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg"
        ]
    },
    "psubw": {
        "detail": [
            "Subtract Packed Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpmovsqb": {
        "detail": [
            "Down Convert QWord to Byte"
        ],
        "description": [
            "reg.x, reg.z",
            "mem.q, reg.q, reg.z",
            "mem.q, reg.z",
            "reg.x, reg.q, reg.z"
        ]
    },
    "vextracti64x2": {
        "detail": [
            "Extract packed Integer Values"
        ],
        "description": [
            "mem.x, reg.q, reg.y, imm.b",
            "reg.x, reg.y, imm.b",
            "reg.x, reg.q, reg.y, imm.b",
            "mem.x, reg.y, imm.b"
        ]
    },
    "vpmovsqd": {
        "detail": [
            "Down Convert QWord to DWord"
        ],
        "description": [
            "reg.y, reg.z",
            "mem.y, reg.q, reg.z",
            "mem.y, reg.z",
            "reg.y, reg.q, reg.z"
        ]
    },
    "vextracti64x4": {
        "detail": [
            "Extract packed Integer Values"
        ],
        "description": [
            "mem.y, reg.q, reg.z, imm.b",
            "reg.y, reg.z, imm.b",
            "reg.y, reg.q, reg.z, imm.b",
            "mem.y, reg.z, imm.b"
        ]
    },
    "vmovmskpd": {
        "detail": [
            "Extract Packed Double-Precision Floating-Point Sign Mask"
        ],
        "description": [
            "reg.d, reg.x"
        ]
    },
    "vaesdeclast": {
        "detail": [
            "Perform Last Round of an AES Decryption Flow"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vfmadd231pd": {
        "detail": [
            "Fused Multiply-Add of Packed Double- Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "pabsb": {
        "detail": [
            "Packed Absolute Value"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "pabsd": {
        "detail": [
            "Packed Absolute Value"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpmovsqw": {
        "detail": [
            "Down Convert QWord to Word"
        ],
        "description": [
            "reg.x, reg.z",
            "mem.x, reg.q, reg.z",
            "mem.x, reg.z",
            "reg.x, reg.q, reg.z"
        ]
    },
    "vmovmskps": {
        "detail": [
            "Extract Packed Single-Precision Floating-Point Sign Mask"
        ],
        "description": [
            "reg.d, reg.x"
        ]
    },
    "vcvtusi2sd": {
        "detail": [
            "Convert Unsigned Integer to Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ]
    },
    "stgi": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "vfmadd231ps": {
        "detail": [
            "Fused Multiply-Add of Packed Single- Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vfmaddsubpd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "repe xsha1": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg.q, reg, mem.b, mem.b"
        ]
    },
    "vrcpss": {
        "detail": [
            "Compute Reciprocal of Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ]
    },
    "vcvtpd2qq": {
        "detail": [
            "Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "pabsw": {
        "detail": [
            "Packed Absolute Value"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "sbb": {
        "detail": [
            "Integer Subtraction with Borrow"
        ],
        "description": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "fincstp": {
        "detail": [
            "Increment Stack-Top Pointer"
        ],
        "description": [
            "reg"
        ]
    },
    "gf2p8mulb": {
        "detail": [
            "Galois Field Multiply Bytes"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vcvtusi2ss": {
        "detail": [
            "Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ]
    },
    "vphadduwq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vphadduwd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vfmaddsubps": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "vstmxcsr": {
        "detail": [
            "Store MXCSR Register State"
        ],
        "description": [
            "mem.d, reg"
        ]
    },
    "aesenclast": {
        "detail": [
            "Perform Last Round of an AES Encryption Flow"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "kandnd": {
        "detail": [
            "Bitwise Logical AND NOT Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "kandnb": {
        "detail": [
            "Bitwise Logical AND NOT Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "vpshlb": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "paddsb": {
        "detail": [
            "Add Packed Signed Integers with Signed Saturation"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "cmovb": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "addsd": {
        "detail": [
            "Add Scalar Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "pfnacc": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpshld": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "lock sub": {
        "detail": [
            "Subtract"
        ],
        "description": [
            "mem.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "kandnq": {
        "detail": [
            "Bitwise Logical AND NOT Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "cmovl": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "cmovo": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "kandnw": {
        "detail": [
            "Bitwise Logical AND NOT Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "cmovp": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "addss": {
        "detail": [
            "Add Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ]
    },
    "cmovs": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "cvtpd2pi": {
        "detail": [
            "Convert Packed Double-Precision FP Values to Packed Dword Integers"
        ],
        "description": [
            "reg.q, mem.x",
            "reg.q, reg.x"
        ]
    },
    "push": {
        "detail": [
            "Push Word, Doubleword or Quadword Onto the Stack"
        ],
        "description": [
            "mem.w, reg.q, mem.w",
            "reg.w, reg.q, mem.w",
            "imm.d, reg.q, mem.q"
        ]
    },
    "paddsw": {
        "detail": [
            "Add Packed Signed Integers with Signed Saturation"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "orpd": {
        "detail": [
            "Bitwise Logical OR of Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "rdtscp": {
        "detail": [
            "Read Time-Stamp Counter and Processor ID"
        ],
        "description": [
            "reg, reg, reg, reg, reg"
        ]
    },
    "cmovz": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "cvtpd2ps": {
        "detail": [
            "Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "pfacc": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vrndscalepd": {
        "detail": [
            "Round Packed Float64 Values To Include A Given Number Of Fraction Bits"
        ],
        "description": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "kaddb": {
        "detail": [
            "ADD Two Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "kaddd": {
        "detail": [
            "ADD Two Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "vreducepd": {
        "detail": [
            "Perform Reduction Transformation on Packed Float64 Values"
        ],
        "description": [
            "reg.x, reg.q, mem.x, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, imm.b"
        ]
    },
    "wrmsr": {
        "detail": [
            "Write to Model Specific Register"
        ],
        "description": [
            "reg, reg, reg, reg"
        ]
    },
    "or": {
        "detail": [
            "Logical Inclusive OR"
        ],
        "description": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "vfmsubadd213pd": {
        "detail": [
            "Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "movlhps": {
        "detail": [
            "Move Packed Single-Precision Floating-Point Values Low to High"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "vpshlw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "orps": {
        "detail": [
            "Bitwise Logical OR of Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vrndscaleps": {
        "detail": [
            "Round Packed Float32 Values To Include A Given Number Of Fraction Bits"
        ],
        "description": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "popfq": {
        "detail": [
            "Pop Stack into EFLAGS Register"
        ],
        "description": [
            "reg.q, mem.q"
        ]
    },
    "kaddq": {
        "detail": [
            "ADD Two Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "vinserti32x4": {
        "detail": [
            "Insert Packed Integer Values"
        ],
        "description": [
            "reg.z, reg.z, mem.x, imm.b",
            "reg.z, reg.q, reg.z, reg.x, imm.b",
            "reg.z, reg.q, reg.z, mem.x, imm.b",
            "reg.z, reg.z, reg.x, imm.b"
        ]
    },
    "vreduceps": {
        "detail": [
            "Perform Reduction Transformation on Packed Float32 Values"
        ],
        "description": [
            "reg.x, reg.q, mem.x, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, imm.b"
        ]
    },
    "vandnpd": {
        "detail": [
            "Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "kaddw": {
        "detail": [
            "ADD Two Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "vfmsubadd213ps": {
        "detail": [
            "Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vinserti32x8": {
        "detail": [
            "Insert Packed Integer Values"
        ],
        "description": [
            "reg.z, reg.z, mem.y, imm.b",
            "reg.z, reg.q, reg.z, reg.y, imm.b",
            "reg.z, reg.q, reg.z, mem.y, imm.b",
            "reg.z, reg.z, reg.y, imm.b"
        ]
    },
    "popfw": {
        "detail": [
            "Pop Stack into EFLAGS Register"
        ],
        "description": [
            "reg.q, mem.w"
        ]
    },
    "vpshlq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "vmresume": {
        "detail": [
            "Launch/Resume Virtual Machine"
        ],
        "description": [
            ""
        ]
    },
    "movmskpd": {
        "detail": [
            "Extract Packed Double-Precision Floating-Point Sign Mask"
        ],
        "description": [
            "reg.d, reg.x"
        ]
    },
    "vandnps": {
        "detail": [
            "Bitwise Logical AND NOT of Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "fsincos": {
        "detail": [
            "Sine and Cosine"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "vpsravd": {
        "detail": [
            "Variable Bit Shift Right Arithmetic"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "fldpi": {
        "detail": [
            "Load Constant"
        ],
        "description": [
            "reg.wq, reg, reg"
        ]
    },
    "movmskps": {
        "detail": [
            "Extract Packed Single-Precision Floating-Point Sign Mask"
        ],
        "description": [
            "reg.d, reg.x"
        ]
    },
    "fbld": {
        "detail": [
            "Load Binary Coded Decimal"
        ],
        "description": [
            "reg.wq, mem.wq, reg, reg"
        ]
    },
    "vfmadd132pd": {
        "detail": [
            "Fused Multiply-Add of Packed Double- Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vcvttss2usi": {
        "detail": [
            "Convert with Truncation Scalar Single-Precision Floating-Point Value to Unsigned Integer"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.x"
        ]
    },
    "vpsravq": {
        "detail": [
            "Variable Bit Shift Right Arithmetic"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vpsravw": {
        "detail": [
            "Variable Bit Shift Right Arithmetic"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "pfadd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "phsubsw": {
        "detail": [
            "Packed Horizontal Subtract and Saturate"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "aesdecwide256kl": {
        "detail": [
            ""
        ],
        "description": [
            "mem.z, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x"
        ]
    },
    "vfmadd132ps": {
        "detail": [
            "Fused Multiply-Add of Packed Single- Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "ktestb": {
        "detail": [
            "Packed Bit Test Masks and Set Flags"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "ktestd": {
        "detail": [
            "Packed Bit Test Masks and Set Flags"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "paddusb": {
        "detail": [
            "Add Packed Unsigned Integers with Unsigned Saturation"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "lgdt": {
        "detail": [
            "Load Global/Interrupt Descriptor Table Register"
        ],
        "description": [
            "mem.wq, reg"
        ]
    },
    "ktestq": {
        "detail": [
            "Packed Bit Test Masks and Set Flags"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "bzhi": {
        "detail": [
            "Zero High Bits Starting with Specified Bit Position"
        ],
        "description": [
            "reg.d, mem.d, reg.d",
            "reg.d, reg.d, reg.d"
        ]
    },
    "ktestw": {
        "detail": [
            "Packed Bit Test Masks and Set Flags"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "paddusw": {
        "detail": [
            "Add Packed Unsigned Integers with Unsigned Saturation"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "lock cmpxchg8b": {
        "detail": [
            "Compare and Exchange Bytes"
        ],
        "description": [
            "mem.q, reg, reg, reg, reg"
        ]
    },
    "rex64 xstore": {
        "detail": [
            ""
        ],
        "description": [
            "mem.b, reg, reg.q, reg.q"
        ]
    },
    "pclmulqdq": {
        "detail": [
            "Carry-Less Multiplication Quadword"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "vbroadcastf32x2": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "description": [
            "reg.y, mem.q",
            "reg.y, reg.x",
            "reg.y, reg.q, mem.q",
            "reg.y, reg.q, reg.x"
        ]
    },
    "vbroadcastf32x4": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "description": [
            "reg.z, mem.x",
            "reg.z, reg.q, mem.x"
        ]
    },
    "aesimc": {
        "detail": [
            "Perform the AES InvMixColumn Transformation"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vbroadcastf32x8": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "description": [
            "reg.z, mem.y",
            "reg.z, reg.q, mem.y"
        ]
    },
    "vfmadd231sd": {
        "detail": [
            "Fused Multiply-Add of Scalar Double- Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpmulld": {
        "detail": [
            "Multiply Packed Integers and Store Low Result"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "fcom": {
        "detail": [
            "Compare Floating Point Values"
        ],
        "description": [
            "reg.wq, mem.d, reg",
            "reg.wq, reg.wq, reg"
        ]
    },
    "enterw": {
        "detail": [
            "Make Stack Frame for Procedure Parameters"
        ],
        "description": [
            "imm.w, imm.b, reg.q, reg.w, mem.w"
        ]
    },
    "fcos": {
        "detail": [
            "Cosine"
        ],
        "description": [
            "reg.wq, reg"
        ]
    },
    "vfmadd231ss": {
        "detail": [
            "Fused Multiply-Add of Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpmovb2m": {
        "detail": [
            "Convert a Vector Register to a Mask"
        ],
        "description": [
            "reg.q, reg.x"
        ]
    },
    "fscale": {
        "detail": [
            "Scale"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "vpmullq": {
        "detail": [
            "Multiply Packed Integers and Store Low Result"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpmullw": {
        "detail": [
            "Multiply Packed Signed Integers and Store Low Result"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "rcl": {
        "detail": [
            "Rotate"
        ],
        "description": [
            "mem.b, imm.b",
            "reg.b, reg",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg"
        ]
    },
    "xor": {
        "detail": [
            "Logical Exclusive OR"
        ],
        "description": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "vp2intersectd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, reg.x, mem.x",
            "reg.q, reg.x, reg.x"
        ]
    },
    "vfnmadd213pd": {
        "detail": [
            "Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "prefetch": {
        "detail": [
            ""
        ],
        "description": [
            "mem.z"
        ]
    },
    "pavgusb": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "tdpbusd": {
        "detail": [
            ""
        ],
        "description": [
            "reg, reg, reg"
        ]
    },
    "lwpval": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.d, imm.d",
            "reg.d, mem.d, imm.d"
        ]
    },
    "rcr": {
        "detail": [
            "Rotate"
        ],
        "description": [
            "mem.b, imm.b",
            "reg.b, reg",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg"
        ]
    },
    "vp2intersectq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, reg.x, mem.x",
            "reg.q, reg.x, reg.x"
        ]
    },
    "repe xstore": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.b, reg, reg.d, reg.d"
        ]
    },
    "vzeroupper": {
        "detail": [
            "Zero Upper Bits of YMM Registers"
        ],
        "description": [
            ""
        ]
    },
    "vfnmadd213ps": {
        "detail": [
            "Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "pmuludq": {
        "detail": [
            "Multiply Packed Unsigned Doubleword Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpperm": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "vmovdqa": {
        "detail": [
            "Move Aligned Packed Integer Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ]
    },
    "vpunpcklqdq": {
        "detail": [
            "Unpack Low Data"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vfmsub213pd": {
        "detail": [
            "Fused Multiply-Subtract of Packed Double- Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vpermb": {
        "detail": [
            "Permute Packed Bytes Elements"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "repe cmpsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.b, mem.b, reg.q"
        ]
    },
    "vpermd": {
        "detail": [
            "Permute Packed Doublewords/Words Elements"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.y, reg.y, mem.y",
            "reg.y, reg.y, reg.y"
        ]
    },
    "vrndscalesd": {
        "detail": [
            "Round Scalar Float64 Value To Include A Given Number Of Fraction Bits"
        ],
        "description": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vmovdqu": {
        "detail": [
            "Move Unaligned Packed Integer Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ]
    },
    "vpcomb": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "repe cmpsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.d, mem.d, reg.q"
        ]
    },
    "vreducesd": {
        "detail": [
            "Perform a Reduction Transformation on a Scalar Float64 Value"
        ],
        "description": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vpcomd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "idiv": {
        "detail": [
            "Signed Divide"
        ],
        "description": [
            "reg.b, reg",
            "reg.w, reg.w, reg.w",
            "mem.b, reg",
            "mem.w, reg.w, reg.w"
        ]
    },
    "repe scasb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.b, reg.q"
        ]
    },
    "vfmsub213ps": {
        "detail": [
            "Fused Multiply-Subtract of Packed Single- Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vpermq": {
        "detail": [
            "Qwords Element Permutation"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.y, reg.y, imm.b",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.y, mem.y, imm.b",
            "reg.z, reg.z, reg.z",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "vpmovusdb": {
        "detail": [
            "Down Convert DWord to Byte"
        ],
        "description": [
            "reg.x, reg.z",
            "mem.x, reg.q, reg.z",
            "mem.x, reg.z",
            "reg.x, reg.q, reg.z"
        ]
    },
    "vptestnmb": {
        "detail": [
            "Logical NAND and Set"
        ],
        "description": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.q, reg.x, mem.x",
            "reg.q, reg.x, reg.x"
        ]
    },
    "vrndscaless": {
        "detail": [
            "Round Scalar Float32 Value To Include A Given Number Of Fraction Bits"
        ],
        "description": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vptestnmd": {
        "detail": [
            "Logical NAND and Set"
        ],
        "description": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.q, reg.z, mem.z",
            "reg.q, reg.z, reg.z"
        ]
    },
    "repe scasd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.d, reg.q"
        ]
    },
    "vpermw": {
        "detail": [
            "Permute Packed Doublewords/Words Elements"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vreducess": {
        "detail": [
            "Perform a Reduction Transformation on a Scalar Float32 Value"
        ],
        "description": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "repe cmpsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.w, mem.w, reg.q"
        ]
    },
    "psrldq": {
        "detail": [
            "Shift Double Quadword Right Logical"
        ],
        "description": [
            "reg.x, imm.b"
        ]
    },
    "vpmacssdd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "repe cmpsq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.q, mem.q, reg.q"
        ]
    },
    "psrad": {
        "detail": [
            "Shift Packed Data Right Arithmetic"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ]
    },
    "repe scasq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.q, reg.q"
        ]
    },
    "vpcomq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vpcomw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "psraw": {
        "detail": [
            "Shift Packed Data Right Arithmetic"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ]
    },
    "vptestnmq": {
        "detail": [
            "Logical NAND and Set"
        ],
        "description": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.q, reg.z, mem.z",
            "reg.q, reg.z, reg.z"
        ]
    },
    "repe scasw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.w, reg.q"
        ]
    },
    "vpmovusdw": {
        "detail": [
            "Down Convert DWord to Word"
        ],
        "description": [
            "reg.y, reg.z",
            "mem.y, reg.q, reg.z",
            "mem.y, reg.z",
            "reg.y, reg.q, reg.z"
        ]
    },
    "vptestnmw": {
        "detail": [
            "Logical NAND and Set"
        ],
        "description": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.q, reg.x, mem.x",
            "reg.q, reg.x, reg.x"
        ]
    },
    "vshuff32x4": {
        "detail": [
            "Shuffle Packed Values at 128-bit Granularity"
        ],
        "description": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ]
    },
    "vmclear": {
        "detail": [
            "Clear Virtual-Machine Control Structure"
        ],
        "description": [
            "mem.q"
        ]
    },
    "crc32": {
        "detail": [
            "Accumulate CRC32 Value"
        ],
        "description": [
            "reg.d, mem.b",
            "reg.d, reg.b"
        ]
    },
    "vpmacswd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "hsubpd": {
        "detail": [
            "Packed Double-FP Horizontal Subtract"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vmread": {
        "detail": [
            "Read Field from Virtual-Machine Control Structure"
        ],
        "description": [
            "reg.q, reg.q",
            "mem.q, reg.q"
        ]
    },
    "tdcall": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q"
        ]
    },
    "aesdec": {
        "detail": [
            "Perform One Round of an AES Decryption Flow"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vfmadd132sd": {
        "detail": [
            "Fused Multiply-Add of Scalar Double- Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "call far": {
        "detail": [
            "Call Procedure"
        ],
        "description": [
            "mem.d, reg.q, reg.q, mem.d"
        ]
    },
    "vcvtsi2sd": {
        "detail": [
            "Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ]
    },
    "vxorpd": {
        "detail": [
            "Bitwise Logical XOR of Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "hsubps": {
        "detail": [
            "Packed Single-FP Horizontal Subtract"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "lock not": {
        "detail": [
            "One's Complement Negation"
        ],
        "description": [
            "mem.b"
        ]
    },
    "vpmacsww": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "vfmadd132ss": {
        "detail": [
            "Fused Multiply-Add of Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "lmsw": {
        "detail": [
            "Load Machine Status Word"
        ],
        "description": [
            "reg.w, reg",
            "mem.w, reg"
        ]
    },
    "vcvtsi2ss": {
        "detail": [
            "Convert Doubleword Integer to Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ]
    },
    "vxorps": {
        "detail": [
            "Bitwise Logical XOR of Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "rsqrtps": {
        "detail": [
            "Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "ret": {
        "detail": [
            "Return from Procedure"
        ],
        "description": [
            "reg.q, reg.q, mem.q",
            "imm.w, reg.q, reg.q, mem.q"
        ]
    },
    "tdpbuud": {
        "detail": [
            ""
        ],
        "description": [
            "reg, reg, reg"
        ]
    },
    "blendpd": {
        "detail": [
            "Blend Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "vpmovswb": {
        "detail": [
            "Down Convert Word to Byte"
        ],
        "description": [
            "reg.x, reg.x",
            "mem.q, reg.q, reg.x",
            "mem.q, reg.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "blendps": {
        "detail": [
            "Blend Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "vpsubsb": {
        "detail": [
            "Subtract Packed Signed Integers with Signed Saturation"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vscatterqpd": {
        "detail": [
            "Scatter Packed Single, Packed Double with Signed Dword and Qword Indices"
        ],
        "description": [
            "mem.q, reg.q, reg.z"
        ]
    },
    "mwait": {
        "detail": [
            "Monitor Wait"
        ],
        "description": [
            "reg, reg"
        ]
    },
    "vpsubsw": {
        "detail": [
            "Subtract Packed Signed Integers with Signed Saturation"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vscatterqps": {
        "detail": [
            "Scatter Packed Single, Packed Double with Signed Dword and Qword Indices"
        ],
        "description": [
            "mem.d, reg.q, reg.y"
        ]
    },
    "cmovle": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "shl": {
        "detail": [
            "Shift"
        ],
        "description": [
            "mem.b, imm.b",
            "reg.b, reg",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg"
        ]
    },
    "vinserti64x2": {
        "detail": [
            "Insert Packed Integer Values"
        ],
        "description": [
            "reg.y, reg.y, mem.x, imm.b",
            "reg.y, reg.q, reg.y, reg.x, imm.b",
            "reg.y, reg.q, reg.y, mem.x, imm.b",
            "reg.y, reg.y, reg.x, imm.b"
        ]
    },
    "vfnmadd213sd": {
        "detail": [
            "Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vinserti64x4": {
        "detail": [
            "Insert Packed Integer Values"
        ],
        "description": [
            "reg.z, reg.z, mem.y, imm.b",
            "reg.z, reg.q, reg.z, reg.y, imm.b",
            "reg.z, reg.q, reg.z, mem.y, imm.b",
            "reg.z, reg.z, reg.y, imm.b"
        ]
    },
    "shr": {
        "detail": [
            "Shift"
        ],
        "description": [
            "mem.b, imm.b",
            "reg.b, reg",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg"
        ]
    },
    "vpbroadcastmw2d": {
        "detail": [
            "Broadcast Mask to Vector Register"
        ],
        "description": [
            "reg.z, reg.q"
        ]
    },
    "vfnmadd213ss": {
        "detail": [
            "Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vextractf32x4": {
        "detail": [
            "Extra ct Packed Floating-Point Values"
        ],
        "description": [
            "mem.x, reg.q, reg.z, imm.b",
            "reg.x, reg.z, imm.b",
            "reg.x, reg.q, reg.z, imm.b",
            "mem.x, reg.z, imm.b"
        ]
    },
    "cvtsi2sd": {
        "detail": [
            "Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.q, mem.d",
            "reg.q, reg.d"
        ]
    },
    "vextractf32x8": {
        "detail": [
            "Extra ct Packed Floating-Point Values"
        ],
        "description": [
            "mem.y, reg.q, reg.z, imm.b",
            "reg.y, reg.z, imm.b",
            "reg.y, reg.q, reg.z, imm.b",
            "mem.y, reg.z, imm.b"
        ]
    },
    "movd": {
        "detail": [
            "Move Doubleword/Move Quadword"
        ],
        "description": [
            "reg.q, mem.d",
            "reg.q, reg.d",
            "mem.d, reg.d"
        ]
    },
    "vfmsub213sd": {
        "detail": [
            "Fused Multiply-Subtract of Scalar Double- Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "fldlg2": {
        "detail": [
            "Load Constant"
        ],
        "description": [
            "reg.wq, reg, reg"
        ]
    },
    "cvtsi2ss": {
        "detail": [
            "Convert Doubleword Integer to Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ]
    },
    "vpcompressb": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x",
            "mem.x, reg.q, reg.x",
            "mem.x, reg.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "movq": {
        "detail": [
            "Move Quadword"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "mem.q, reg.q"
        ]
    },
    "vpcompressd": {
        "detail": [
            "Store Sparse Packed Doubleword Integer Values into Dense Memory/Register"
        ],
        "description": [
            "reg.z, reg.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vpmovsxwd": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ]
    },
    "vrcp28pd": {
        "detail": [
            "Approximation to the Reciprocal of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vpexpandb": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vpexpandd": {
        "detail": [
            "Load Sparse Packed Doubleword Integer Values from Dense Memory / Register"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vfmsub213ss": {
        "detail": [
            "Fused Multiply-Subtract of Scalar Single- Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vphminposuw": {
        "detail": [
            "Packed Horizontal Word Minimum"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "xresldtrk": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "vpcompressq": {
        "detail": [
            "Store Sparse Packed Quadword Integer Values into Dense Memory/Register"
        ],
        "description": [
            "reg.z, reg.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vpscatterqd": {
        "detail": [
            "Scatter Packed Dword, Packed Qword with Signed Dword, Signed Qword Indices"
        ],
        "description": [
            "mem.d, reg.q, reg.y"
        ]
    },
    "vpmovsxwq": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "description": [
            "reg.x, mem.d",
            "reg.x, reg.d",
            "reg.z, reg.q, mem.x",
            "reg.z, reg.q, reg.x"
        ]
    },
    "vpmovzxbd": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "description": [
            "reg.x, mem.d",
            "reg.x, reg.d",
            "reg.z, reg.q, mem.x",
            "reg.z, reg.q, reg.x"
        ]
    },
    "vpcompressw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x",
            "mem.x, reg.q, reg.x",
            "mem.x, reg.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vrcp28ps": {
        "detail": [
            "Approximation to the Reciprocal of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vpexpandq": {
        "detail": [
            "Load Sparse Packed Quadword Integer Values from Dense Memory / Register"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "prefetchwt1": {
        "detail": [
            "Prefetch Vector Data Into Caches with Intent to Write and T1 Hint"
        ],
        "description": [
            "mem.b"
        ]
    },
    "cwde": {
        "detail": [
            "Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword"
        ],
        "description": [
            "reg, reg"
        ]
    },
    "tdpbssd": {
        "detail": [
            ""
        ],
        "description": [
            "reg, reg, reg"
        ]
    },
    "vpexpandw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vpscatterqq": {
        "detail": [
            "Scatter Packed Dword, Packed Qword with Signed Dword, Signed Qword Indices"
        ],
        "description": [
            "mem.q, reg.q, reg.z"
        ]
    },
    "vpmovzxbq": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "description": [
            "reg.x, mem.w",
            "reg.x, reg.w",
            "reg.z, reg.q, mem.q",
            "reg.z, reg.q, reg.x"
        ]
    },
    "wbnoinvd": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "tdpbf16ps": {
        "detail": [
            ""
        ],
        "description": [
            "reg, reg, reg"
        ]
    },
    "vpmovzxbw": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.x, reg.q, mem.q",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vpxord": {
        "detail": [
            "Logical Exclusive OR"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vbroadcastf64x2": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "description": [
            "reg.y, mem.x",
            "reg.y, reg.q, mem.x"
        ]
    },
    "vbroadcastf64x4": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "description": [
            "reg.z, mem.y",
            "reg.z, reg.q, mem.y"
        ]
    },
    "vmxoff": {
        "detail": [
            "Leave VMX Operation"
        ],
        "description": [
            ""
        ]
    },
    "vpshufhw": {
        "detail": [
            "Shuffle Packed High Words"
        ],
        "description": [
            "reg.x, reg.q, mem.x, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, imm.b"
        ]
    },
    "vpxorq": {
        "detail": [
            "Logical Exclusive OR"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "getsec": {
        "detail": [
            ""
        ],
        "description": [
            "reg, reg"
        ]
    },
    "vpsubusb": {
        "detail": [
            "Subtract Packed Unsigned Integers with Unsigned Saturation"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "cmovnb": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "rsqrtss": {
        "detail": [
            "Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ]
    },
    "cmovnl": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "cmovno": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "vpsubusw": {
        "detail": [
            "Subtract Packed Unsigned Integers with Unsigned Saturation"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vscatterpf0qpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint with Intent to Write"
        ],
        "description": [
            "mem.q, reg.q"
        ]
    },
    "cmovnp": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "cmovns": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "sha256msg1": {
        "detail": [
            "Perform an Intermediate Calculation for the Next Four SHA256 Message Dwords"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "mwaitx": {
        "detail": [
            ""
        ],
        "description": [
            "reg, reg"
        ]
    },
    "sha256msg2": {
        "detail": [
            "Perform a Final Calculation for the Next Four SHA256 Message Dwords"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vpslldq": {
        "detail": [
            "Shift Double Quadword Left Logical"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "cmovnz": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "cvttps2dq": {
        "detail": [
            "Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vscatterpf0qps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint with Intent to Write"
        ],
        "description": [
            "mem.d, reg.q"
        ]
    },
    "palignr": {
        "detail": [
            "Packed Align Right"
        ],
        "description": [
            "reg.q, reg.q, imm.b",
            "reg.q, mem.q, imm.b"
        ]
    },
    "vmovapd": {
        "detail": [
            "Move Aligned Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.x, reg.x",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vpacksswb": {
        "detail": [
            "Pack with Signed Saturation"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "tilestored": {
        "detail": [
            ""
        ],
        "description": [
            "mem, reg"
        ]
    },
    "vexp2pd": {
        "detail": [
            "Approximation to the Exponential 2^x of Packed Double-Precision Floating-Point Values with Less Than 2^-23 Relative Error"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "pmovsxwd": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ]
    },
    "vphaddsw": {
        "detail": [
            "Packed Horizontal Add and Saturate"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "tlbsync": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "vmovaps": {
        "detail": [
            "Move Aligned Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.x, reg.x",
            "reg.z, reg.q, reg.z"
        ]
    },
    "minpd": {
        "detail": [
            "Minimum of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "pmovsxwq": {
        "detail": [
            "Packed Move with Sign Extend"
        ],
        "description": [
            "reg.x, mem.d",
            "reg.x, reg.d"
        ]
    },
    "vexp2ps": {
        "detail": [
            "Approximation to the Exponential 2^x of Packed Single-Precision Floating-Point Values with Less Than 2^-23 Relative Error"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "pushfq": {
        "detail": [
            "Push EFLAGS Register onto the Stack"
        ],
        "description": [
            "reg.q, mem.q"
        ]
    },
    "f2xm1": {
        "detail": [
            "Compute 2x-1"
        ],
        "description": [
            "reg.wq, reg"
        ]
    },
    "pmovzxbd": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "description": [
            "reg.x, mem.d",
            "reg.x, reg.d"
        ]
    },
    "ffree": {
        "detail": [
            "Free Floating-Point Register"
        ],
        "description": [
            "reg.wq, reg"
        ]
    },
    "pushfw": {
        "detail": [
            "Push EFLAGS Register onto the Stack"
        ],
        "description": [
            "reg.q, mem.w"
        ]
    },
    "minps": {
        "detail": [
            "Minimum of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "pmovzxbq": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "description": [
            "reg.x, mem.w",
            "reg.x, reg.w"
        ]
    },
    "tdpbsud": {
        "detail": [
            ""
        ],
        "description": [
            "reg, reg, reg"
        ]
    },
    "vfmsubpd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "pmovzxbw": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ]
    },
    "vpmovzxdq": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ]
    },
    "t1mskc": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "maskmovdqu": {
        "detail": [
            "Store Selected Bytes of Double Quadword"
        ],
        "description": [
            "reg.x, reg.x, mem.x"
        ]
    },
    "vshuff64x2": {
        "detail": [
            "Shuffle Packed Values at 128-bit Granularity"
        ],
        "description": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ]
    },
    "iretd": {
        "detail": [
            "Interrupt Return"
        ],
        "description": [
            "reg.q, reg.q, mem.dx"
        ]
    },
    "vfmsubps": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "repne movsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.b, mem.b, reg.q"
        ]
    },
    "encodekey128": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.d, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x"
        ]
    },
    "repne movsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.d, mem.d, reg.q"
        ]
    },
    "iretq": {
        "detail": [
            "Interrupt Return"
        ],
        "description": [
            "reg.q, reg.q, mem.wq"
        ]
    },
    "iretw": {
        "detail": [
            "Interrupt Return"
        ],
        "description": [
            "reg.q, reg.q, mem.wq"
        ]
    },
    "encls": {
        "detail": [
            "Execute an Enclave System Function of Specified Leaf Number"
        ],
        "description": [
            "reg, reg, reg, reg"
        ]
    },
    "enclu": {
        "detail": [
            "Execute an Enclave User Function of Specified Leaf Number"
        ],
        "description": [
            "reg, reg, reg, reg"
        ]
    },
    "repne movsq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.q, mem.q, reg.q"
        ]
    },
    "vrcp28sd": {
        "detail": [
            "Approximation to the Reciprocal of Scalar Double-Precision Floating-Point Value with Less Than 2^-28 Relative Error"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "repne insb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.b, reg, reg.q"
        ]
    },
    "repne insd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.d, reg, reg.q"
        ]
    },
    "repne movsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.w, mem.w, reg.q"
        ]
    },
    "syscall": {
        "detail": [
            "Fast System Call"
        ],
        "description": [
            "reg.q, reg, reg"
        ]
    },
    "popw": {
        "detail": [
            "Pop a Value from the Stack"
        ],
        "description": [
            "reg, reg.q, mem.w"
        ]
    },
    "fbstp": {
        "detail": [
            "Store BCD Integer and Pop"
        ],
        "description": [
            "mem.wq, reg.wq, reg, reg"
        ]
    },
    "sttilecfg": {
        "detail": [
            ""
        ],
        "description": [
            "mem.z"
        ]
    },
    "vpcmov": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "vcvtpd2udq": {
        "detail": [
            "Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers"
        ],
        "description": [
            "reg.y, mem.z",
            "reg.y, reg.z",
            "reg.y, reg.q, mem.z",
            "reg.y, reg.q, reg.z"
        ]
    },
    "vrcp28ss": {
        "detail": [
            "Approximation to the Reciprocal of Scalar Single-Precision Floating-Point Value with Less Than 2^-28 Relative Error"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "repne insw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.w, reg, reg.q"
        ]
    },
    "lock cmpxchg": {
        "detail": [
            "Compare and Exchange"
        ],
        "description": [
            "mem.b, reg.b, reg"
        ]
    },
    "vsubpd": {
        "detail": [
            "Subtract Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "packsswb": {
        "detail": [
            "Pack with Signed Saturation"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "rdsspd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.q"
        ]
    },
    "encodekey256": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.d, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x, reg.x"
        ]
    },
    "stmxcsr": {
        "detail": [
            "Store MXCSR Register State"
        ],
        "description": [
            "mem.d, reg"
        ]
    },
    "vsubps": {
        "detail": [
            "Subtract Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "setnbe": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "rdsspq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "movupd": {
        "detail": [
            "Move Unaligned Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ]
    },
    "vpcmpb": {
        "detail": [
            "Compare Packed Byte Values Into Mask"
        ],
        "description": [
            "reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.q, reg.x, reg.x, imm.b",
            "reg.q, reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.x, reg.x, imm.b"
        ]
    },
    "bndcl": {
        "detail": [
            "Check Lower Bound"
        ],
        "description": [
            "reg, reg.q",
            "reg, agen"
        ]
    },
    "vpcmpd": {
        "detail": [
            "Compare Packed Integer Values into Mask"
        ],
        "description": [
            "reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.q, reg.z, reg.z, imm.b",
            "reg.q, reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.z, reg.z, imm.b"
        ]
    },
    "bndcn": {
        "detail": [
            "Check Upper Bound"
        ],
        "description": [
            "reg, reg.q",
            "reg, agen"
        ]
    },
    "vpaddb": {
        "detail": [
            "Add Packed Integers"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpaddd": {
        "detail": [
            "Add Packed Integers"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "bndcu": {
        "detail": [
            "Check Upper Bound"
        ],
        "description": [
            "reg, reg.q",
            "reg, agen"
        ]
    },
    "movups": {
        "detail": [
            "Move Unaligned Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "mem.x, reg.x"
        ]
    },
    "vpcmpq": {
        "detail": [
            "Compare Packed Integer Values into Mask"
        ],
        "description": [
            "reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.q, reg.z, reg.z, imm.b",
            "reg.q, reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.z, reg.z, imm.b"
        ]
    },
    "vfmsubadd231pd": {
        "detail": [
            "Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vcvtph2ps": {
        "detail": [
            "Convert 16-bit FP values to Single-Precision FP values"
        ],
        "description": [
            "reg.z, mem.y",
            "reg.z, reg.y",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ]
    },
    "fdecstp": {
        "detail": [
            "Decrement Stack-Top Pointer"
        ],
        "description": [
            "reg"
        ]
    },
    "vpaddq": {
        "detail": [
            "Add Packed Integers"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpcmpw": {
        "detail": [
            "Compare Packed Word Values Into Mask"
        ],
        "description": [
            "reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.q, reg.x, reg.x, imm.b",
            "reg.q, reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.x, reg.x, imm.b"
        ]
    },
    "cvttss2si": {
        "detail": [
            "Convert with Truncation Scalar Single-Precision Floating-Point Value to Integer"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ]
    },
    "pmovzxdq": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ]
    },
    "vpaddw": {
        "detail": [
            "Add Packed Integers"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vscatterpf1qpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint with Intent to Write"
        ],
        "description": [
            "mem.q, reg.q"
        ]
    },
    "vfmsubadd231ps": {
        "detail": [
            "Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "setbe": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "pvalidate": {
        "detail": [
            ""
        ],
        "description": [
            "reg, reg, reg"
        ]
    },
    "fxam": {
        "detail": [
            "Examine Floating-Point"
        ],
        "description": [
            "reg.wq, reg"
        ]
    },
    "swapgs": {
        "detail": [
            "Swap GS Base Register"
        ],
        "description": [
            ""
        ]
    },
    "vscatterpf1qps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint with Intent to Write"
        ],
        "description": [
            "mem.d, reg.q"
        ]
    },
    "pextrb": {
        "detail": [
            "Extract Byte/Dword/Qword"
        ],
        "description": [
            "reg.d, reg.x, imm.b",
            "mem.b, reg.x, imm.b"
        ]
    },
    "pextrd": {
        "detail": [
            "Extract Byte/Dword/Qword"
        ],
        "description": [
            "reg.d, reg.x, imm.b",
            "mem.d, reg.x, imm.b"
        ]
    },
    "vextractf64x2": {
        "detail": [
            "Extra ct Packed Floating-Point Values"
        ],
        "description": [
            "mem.x, reg.q, reg.y, imm.b",
            "reg.x, reg.y, imm.b",
            "reg.x, reg.q, reg.y, imm.b",
            "mem.x, reg.y, imm.b"
        ]
    },
    "aesenc": {
        "detail": [
            "Perform One Round of an AES Encryption Flow"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vpshuflw": {
        "detail": [
            "Shuffle Packed Low Words"
        ],
        "description": [
            "reg.x, reg.q, mem.x, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, imm.b"
        ]
    },
    "vextractf64x4": {
        "detail": [
            "Extra ct Packed Floating-Point Values"
        ],
        "description": [
            "mem.y, reg.q, reg.z, imm.b",
            "reg.y, reg.z, imm.b",
            "reg.y, reg.q, reg.z, imm.b",
            "mem.y, reg.z, imm.b"
        ]
    },
    "pextrq": {
        "detail": [
            "Extract Byte/Dword/Qword"
        ],
        "description": [
            "reg.q, reg.x, imm.b",
            "mem.q, reg.x, imm.b"
        ]
    },
    "pminsb": {
        "detail": [
            "Minimum of Packed Signed Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "pminsd": {
        "detail": [
            "Minimum of Packed Signed Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "pextrw": {
        "detail": [
            "Extract Word"
        ],
        "description": [
            "reg.d, reg.q, imm.b",
            "mem.w, reg.x, imm.b"
        ]
    },
    "extrq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, reg.x",
            "reg.q, imm.b, imm.b"
        ]
    },
    "xabort": {
        "detail": [
            "Transactional Abort"
        ],
        "description": [
            "reg, imm.b"
        ]
    },
    "minsd": {
        "detail": [
            "Return Minimum Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vrcp14pd": {
        "detail": [
            "Compute Approximate Reciprocals of Packed Float64 Values"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "fcomip": {
        "detail": [
            "Compare Floating Point Values and Set EFLAGS"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg"
        ]
    },
    "vgatherpf0dpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint"
        ],
        "description": [
            "mem.q, reg.q"
        ]
    },
    "pminsw": {
        "detail": [
            "Minimum of Packed Signed Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "minss": {
        "detail": [
            "Return Minimum Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ]
    },
    "vrcp14ps": {
        "detail": [
            "Compute Approximate Reciprocals of Packed Float32 Values"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vgatherpf0dps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint"
        ],
        "description": [
            "mem.d, reg.q"
        ]
    },
    "vfmsubsd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.q, mem.q",
            "reg.x, reg.q, reg.q, reg.q",
            "reg.x, reg.q, mem.q, reg.q"
        ]
    },
    "pavgb": {
        "detail": [
            "Average Packed Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "fninit": {
        "detail": [
            "Initialize Floating-Point Unit"
        ],
        "description": [
            "reg, reg, reg"
        ]
    },
    "repe xcryptofb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.b, reg, reg.d, reg, reg.q, mem.b"
        ]
    },
    "vphaddwd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vpblendmb": {
        "detail": [
            "Blend Byte/Word Vectors Using an Opmask Control"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vfmsubss": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.d, reg.d, mem.d",
            "reg.x, reg.d, reg.d, reg.d",
            "reg.x, reg.d, mem.d, reg.d"
        ]
    },
    "vpblendmd": {
        "detail": [
            "Blend Int32/Int64 Vectors Using an OpMask Control"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "sha1nexte": {
        "detail": [
            "Calculate SHA1 State Variable E after Four Rounds"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "blcic": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "pavgw": {
        "detail": [
            "Average Packed Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vphaddwq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "fucomip": {
        "detail": [
            "Compare Floating Point Values and Set EFLAGS"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg"
        ]
    },
    "vpblendmq": {
        "detail": [
            "Blend Int32/Int64 Vectors Using an OpMask Control"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "invlpg": {
        "detail": [
            "Invalidate TLB Entries"
        ],
        "description": [
            "mem.b"
        ]
    },
    "vpblendmw": {
        "detail": [
            "Blend Byte/Word Vectors Using an Opmask Control"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "phaddd": {
        "detail": [
            "Packed Horizontal Add"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vfmsubadd132pd": {
        "detail": [
            "Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "neg": {
        "detail": [
            "Two's Complement Negation"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "sldt": {
        "detail": [
            "Store Local Descriptor Table Register"
        ],
        "description": [
            "reg.w, reg",
            "mem.w, reg"
        ]
    },
    "phaddw": {
        "detail": [
            "Packed Horizontal Add"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vfnmadd231pd": {
        "detail": [
            "Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vinsertf32x4": {
        "detail": [
            "Insert Packed Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.z, mem.x, imm.b",
            "reg.z, reg.q, reg.z, reg.x, imm.b",
            "reg.z, reg.q, reg.z, mem.x, imm.b",
            "reg.z, reg.z, reg.x, imm.b"
        ]
    },
    "lar": {
        "detail": [
            "Load Access Rights Byte"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "vfmsubadd132ps": {
        "detail": [
            "Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vinsertf32x8": {
        "detail": [
            "Insert Packed Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.z, mem.y, imm.b",
            "reg.z, reg.q, reg.z, reg.y, imm.b",
            "reg.z, reg.q, reg.z, mem.y, imm.b",
            "reg.z, reg.z, reg.y, imm.b"
        ]
    },
    "fxch": {
        "detail": [
            "Exchange Register Contents"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "vsubsd": {
        "detail": [
            "Subtract Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ]
    },
    "vfnmadd231ps": {
        "detail": [
            "Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vmovntdqa": {
        "detail": [
            "Load Double Quadword Non-Temporal Aligned Hint"
        ],
        "description": [
            "reg.x, mem.x"
        ]
    },
    "lock inc": {
        "detail": [
            "Increment by 1"
        ],
        "description": [
            "mem.b"
        ]
    },
    "vsubss": {
        "detail": [
            "Subtract Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ]
    },
    "pminub": {
        "detail": [
            "Minimum of Packed Unsigned Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "pminud": {
        "detail": [
            "Minimum of Packed Unsigned Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "fldln2": {
        "detail": [
            "Load Constant"
        ],
        "description": [
            "reg.wq, reg, reg"
        ]
    },
    "jrcxz": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg, reg.q"
        ]
    },
    "stui": {
        "detail": [
            ""
        ],
        "description": [
            "reg.1"
        ]
    },
    "vfmsub231pd": {
        "detail": [
            "Fused Multiply-Subtract of Packed Double- Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "movsb": {
        "detail": [
            "Move Data from String to String"
        ],
        "description": [
            "mem.b, mem.b"
        ]
    },
    "fnstenv": {
        "detail": [
            "Store x87 FPU Environment"
        ],
        "description": [
            "mem.wdq, reg"
        ]
    },
    "movsd": {
        "detail": [
            "Move or Merge Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, mem.q",
            "mem.d, mem.d",
            "reg.q, reg.q",
            "mem.q, reg.q"
        ]
    },
    "vmfunc": {
        "detail": [
            "Invoke VM function"
        ],
        "description": [
            "reg"
        ]
    },
    "kortestb": {
        "detail": [
            "OR Masks And Set Flags"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "vgf2p8mulb": {
        "detail": [
            "Galois Field Multiply Bytes"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "kortestd": {
        "detail": [
            "OR Masks And Set Flags"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "pminuw": {
        "detail": [
            "Minimum of Packed Unsigned Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vfmsub231ps": {
        "detail": [
            "Fused Multiply-Subtract of Packed Single- Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "fcomi": {
        "detail": [
            "Compare Floating Point Values and Set EFLAGS"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "movsq": {
        "detail": [
            "Move Data from String to String"
        ],
        "description": [
            "mem.q, mem.q"
        ]
    },
    "movss": {
        "detail": [
            "Move or Merge Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, mem.d",
            "reg.d, reg.d",
            "mem.d, reg.d"
        ]
    },
    "fcomp": {
        "detail": [
            "Compare Floating Point Values"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg",
            "reg.wq, mem.q, reg, reg"
        ]
    },
    "movsw": {
        "detail": [
            "Move Data from String to String"
        ],
        "description": [
            "mem.w, mem.w"
        ]
    },
    "movsx": {
        "detail": [
            "Move with Sign-Extension"
        ],
        "description": [
            "reg.w, mem.b",
            "reg.w, reg.b"
        ]
    },
    "kortestq": {
        "detail": [
            "OR Masks And Set Flags"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "kortestw": {
        "detail": [
            "OR Masks And Set Flags"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "clflushopt": {
        "detail": [
            "Flush Cache Line Optimized"
        ],
        "description": [
            "mem.z"
        ]
    },
    "vcvtps2udq": {
        "detail": [
            "Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vmulpd": {
        "detail": [
            "Multiply Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "repne stosb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.b, reg, reg.q"
        ]
    },
    "repne stosd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.d, reg, reg.q"
        ]
    },
    "fcmovb": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "lock dec": {
        "detail": [
            "Decrement by 1"
        ],
        "description": [
            "mem.b"
        ]
    },
    "vpackuswb": {
        "detail": [
            "Pack with Unsigned Saturation"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "fcmove": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "vmulps": {
        "detail": [
            "Multiply Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "repne stosq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.q, reg, reg.q"
        ]
    },
    "repne stosw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.w, reg, reg.q"
        ]
    },
    "vrcp14sd": {
        "detail": [
            "Compute Approximate Reciprocal of Scalar Float64 Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "psrld": {
        "detail": [
            "Shift Packed Data Right Logical"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ]
    },
    "vpdpbusds": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "fcmovu": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "vgatherpf1dpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint"
        ],
        "description": [
            "mem.q, reg.q"
        ]
    },
    "rol": {
        "detail": [
            "Rotate"
        ],
        "description": [
            "mem.b, imm.b",
            "reg.b, reg",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg"
        ]
    },
    "psrlq": {
        "detail": [
            "Shift Packed Data Right Logical"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ]
    },
    "ror": {
        "detail": [
            "Rotate"
        ],
        "description": [
            "mem.b, imm.b",
            "reg.b, reg",
            "mem.b, imm.b",
            "reg.b, imm.b",
            "reg.b, imm.b",
            "mem.b, reg"
        ]
    },
    "vrcp14ss": {
        "detail": [
            "Compute Approximate Reciprocal of Scalar Float32 Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "psrlw": {
        "detail": [
            "Shift Packed Data Right Logical"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ]
    },
    "vfnmadd132pd": {
        "detail": [
            "Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vgatherpf1dps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint"
        ],
        "description": [
            "mem.d, reg.q"
        ]
    },
    "pushw": {
        "detail": [
            "Push Word, Doubleword or Quadword Onto the Stack"
        ],
        "description": [
            "reg, reg.q, mem.w",
            "imm.w, reg.q, mem.w"
        ]
    },
    "enqcmds": {
        "detail": [
            ""
        ],
        "description": [
            "reg, mem.z"
        ]
    },
    "movntdqa": {
        "detail": [
            "Load Double Quadword Non-Temporal Aligned Hint"
        ],
        "description": [
            "reg.x, mem.x"
        ]
    },
    "vfnmadd132ps": {
        "detail": [
            "Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vp4dpwssd": {
        "detail": [
            "Dot Product of Signed Words with Dword Accumulation (4-iterations)"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.z, mem.x"
        ]
    },
    "cvtpi2pd": {
        "detail": [
            "Convert Packed Dword Integers to Packed Double-Precision FP Values"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ]
    },
    "vfmsub132pd": {
        "detail": [
            "Fused Multiply-Subtract of Packed Double- Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "cvtpi2ps": {
        "detail": [
            "Convert Packed Dword Integers to Packed Single-Precision FP Values"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vfmsub132ps": {
        "detail": [
            "Fused Multiply-Subtract of Packed Single- Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "punpcklbw": {
        "detail": [
            "Unpack Low Data"
        ],
        "description": [
            "reg.q, mem.d",
            "reg.q, reg.d"
        ]
    },
    "vfnmadd231sd": {
        "detail": [
            "Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpshrdvd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "ficomp": {
        "detail": [
            "Compare Integer"
        ],
        "description": [
            "reg.wq, mem.d, reg, reg"
        ]
    },
    "vpermi2pd": {
        "detail": [
            "Full Permute From Two Tables Overwriting the Index"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vextractf128": {
        "detail": [
            "Extra ct Packed Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "mem.x, reg.x, imm.b"
        ]
    },
    "vpclmulqdq": {
        "detail": [
            "Carry-Less Multiplication Quadword"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vfnmadd231ss": {
        "detail": [
            "Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpshrdvq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpermt2d": {
        "detail": [
            "Full Permute from Two Tables Overwriting one Table"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vpermt2b": {
        "detail": [
            "Full Permute of Bytes from Two Tables Overwriting a Table"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpshrdvw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "packuswb": {
        "detail": [
            "Pack with Unsigned Saturation"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "fnsave": {
        "detail": [
            "Store x87 FPU State"
        ],
        "description": [
            "mem.wdqxz, reg, reg, reg"
        ]
    },
    "vpermi2ps": {
        "detail": [
            "Full Permute From Two Tables Overwriting the Index"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vptest": {
        "detail": [
            "Logical Compare"
        ],
        "description": [
            "reg.x, reg.x",
            "reg.x, mem.x"
        ]
    },
    "vpermt2q": {
        "detail": [
            "Full Permute from Two Tables Overwriting one Table"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vcvtudq2pd": {
        "detail": [
            "Convert Packed Unsigned Doubleword Integers to Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, mem.y",
            "reg.z, reg.y",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ]
    },
    "vpermt2w": {
        "detail": [
            "Full Permute from Two Tables Overwriting one Table"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vfmsub231sd": {
        "detail": [
            "Fused Multiply-Subtract of Scalar Double- Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vfixupimmpd": {
        "detail": [
            "Fix Up Special Packed Float64 Values"
        ],
        "description": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ]
    },
    "extractps": {
        "detail": [
            "Extract Packed Floating-Point Values"
        ],
        "description": [
            "reg.d, reg.x, imm.b",
            "mem.d, reg.x, imm.b"
        ]
    },
    "aesdec128kl": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.xy"
        ]
    },
    "vcvtudq2ps": {
        "detail": [
            "Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vpmovusqb": {
        "detail": [
            "Down Convert QWord to Byte"
        ],
        "description": [
            "reg.x, reg.z",
            "mem.q, reg.q, reg.z",
            "mem.q, reg.z",
            "reg.x, reg.q, reg.z"
        ]
    },
    "vpmovusqd": {
        "detail": [
            "Down Convert QWord to DWord"
        ],
        "description": [
            "reg.y, reg.z",
            "mem.y, reg.q, reg.z",
            "mem.y, reg.z",
            "reg.y, reg.q, reg.z"
        ]
    },
    "vfmsub231ss": {
        "detail": [
            "Fused Multiply-Subtract of Scalar Single- Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "lea": {
        "detail": [
            "Load Effective Address"
        ],
        "description": [
            "reg.w, agen"
        ]
    },
    "vmaskmovpd": {
        "detail": [
            "Conditional SIMD Packed Loads and Stores"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "mem.x, reg.x, reg.x"
        ]
    },
    "vfixupimmps": {
        "detail": [
            "Fix Up Special Packed Float32 Values"
        ],
        "description": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ]
    },
    "vpdpbusd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vmwrite": {
        "detail": [
            "Write Field to Virtual-Machine Control Structure"
        ],
        "description": [
            "reg.q, reg.q",
            "reg.q, mem.q"
        ]
    },
    "vpmovusqw": {
        "detail": [
            "Down Convert QWord to Word"
        ],
        "description": [
            "reg.x, reg.z",
            "mem.x, reg.q, reg.z",
            "mem.x, reg.z",
            "reg.x, reg.q, reg.z"
        ]
    },
    "vmaskmovps": {
        "detail": [
            "Conditional SIMD Packed Loads and Stores"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "mem.x, reg.x, reg.x"
        ]
    },
    "vpcmpestriq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, imm.b, reg, reg, reg",
            "reg.x, mem.x, imm.b, reg, reg, reg"
        ]
    },
    "vfnmsub213pd": {
        "detail": [
            "Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vmulsd": {
        "detail": [
            "Multiply Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ]
    },
    "punpckhqdq": {
        "detail": [
            "Unpack High Data"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.q"
        ]
    },
    "vfnmsub213ps": {
        "detail": [
            "Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vmulss": {
        "detail": [
            "Multiply Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ]
    },
    "vgetmantpd": {
        "detail": [
            "Extract Float64 Vector of Normalized Mantissas from Float64 Vector"
        ],
        "description": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "vmovdqu8": {
        "detail": [
            "Move Unaligned Packed Integer Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "mem.x, reg.q, reg.x",
            "mem.x, reg.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vpand": {
        "detail": [
            "Logical AND"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "lahf": {
        "detail": [
            "Load Status Flags into AH Register"
        ],
        "description": [
            "reg"
        ]
    },
    "stc": {
        "detail": [
            "Set Carry Flag"
        ],
        "description": [
            ""
        ]
    },
    "std": {
        "detail": [
            "Set Direction Flag"
        ],
        "description": [
            ""
        ]
    },
    "pshufhw": {
        "detail": [
            "Shuffle Packed High Words"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "vgetmantps": {
        "detail": [
            "Extract Float32 Vector of Normalized Mantissas from Float32 Vector"
        ],
        "description": [
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "sti": {
        "detail": [
            "Set Interrupt Flag"
        ],
        "description": [
            ""
        ]
    },
    "punpckldq": {
        "detail": [
            "Unpack Low Data"
        ],
        "description": [
            "reg.q, mem.d",
            "reg.q, reg.d"
        ]
    },
    "llwpcb": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d"
        ]
    },
    "jbe": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "rorx": {
        "detail": [
            "Rotate Right Logical Without Affecting Flags"
        ],
        "description": [
            "reg.d, reg.d, imm.b",
            "reg.d, mem.d, imm.b"
        ]
    },
    "str": {
        "detail": [
            "Store Task Register"
        ],
        "description": [
            "reg.w, reg",
            "mem.w, reg"
        ]
    },
    "pconfig": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.q, reg.q, reg.q"
        ]
    },
    "psubusb": {
        "detail": [
            "Subtract Packed Unsigned Integers with Unsigned Saturation"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vdppd": {
        "detail": [
            "Dot Product of Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vfnmadd132sd": {
        "detail": [
            "Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vinsertf64x2": {
        "detail": [
            "Insert Packed Floating-Point Values"
        ],
        "description": [
            "reg.y, reg.y, mem.x, imm.b",
            "reg.y, reg.q, reg.y, reg.x, imm.b",
            "reg.y, reg.q, reg.y, mem.x, imm.b",
            "reg.y, reg.y, reg.x, imm.b"
        ]
    },
    "vinsertf64x4": {
        "detail": [
            "Insert Packed Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.z, mem.y, imm.b",
            "reg.z, reg.q, reg.z, reg.y, imm.b",
            "reg.z, reg.q, reg.z, mem.y, imm.b",
            "reg.z, reg.z, reg.y, imm.b"
        ]
    },
    "lfs": {
        "detail": [
            "Load Far Pointer"
        ],
        "description": [
            "reg.w, mem.d, reg"
        ]
    },
    "ldtilecfg": {
        "detail": [
            ""
        ],
        "description": [
            "mem.z"
        ]
    },
    "vdpps": {
        "detail": [
            "Dot Product of Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vfnmadd132ss": {
        "detail": [
            "Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "psubusw": {
        "detail": [
            "Subtract Packed Unsigned Integers with Unsigned Saturation"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "cmpxchg8b": {
        "detail": [
            "Compare and Exchange Bytes"
        ],
        "description": [
            "mem.q, reg, reg, reg, reg"
        ]
    },
    "clzero": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q"
        ]
    },
    "stosb": {
        "detail": [
            "Store String"
        ],
        "description": [
            "mem.b, reg"
        ]
    },
    "vfmsub132sd": {
        "detail": [
            "Fused Multiply-Subtract of Scalar Double- Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "stosd": {
        "detail": [
            "Store String"
        ],
        "description": [
            "mem.d, reg"
        ]
    },
    "cmovnbe": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "sub": {
        "detail": [
            "Subtract"
        ],
        "description": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "jmp far": {
        "detail": [
            "Jump"
        ],
        "description": [
            "mem.d, reg.q"
        ]
    },
    "fcompp": {
        "detail": [
            "Compare Floating Point Values"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg"
        ]
    },
    "kxnorb": {
        "detail": [
            "Bitwise Logical XNOR Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "kxnord": {
        "detail": [
            "Bitwise Logical XNOR Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "vpsignb": {
        "detail": [
            "Packed SIGN"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "rsm": {
        "detail": [
            "Resume from System Management Mode"
        ],
        "description": [
            "reg.q"
        ]
    },
    "vpsignd": {
        "detail": [
            "Packed SIGN"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vfmsub132ss": {
        "detail": [
            "Fused Multiply-Subtract of Scalar Single- Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "stosq": {
        "detail": [
            "Store String"
        ],
        "description": [
            "mem.q, reg"
        ]
    },
    "sidt": {
        "detail": [
            "Store Interrupt Descriptor Table Register"
        ],
        "description": [
            "mem.wq, reg"
        ]
    },
    "pop": {
        "detail": [
            "Pop a Value from the Stack"
        ],
        "description": [
            "mem.w, reg.q, mem.w",
            "reg.w, reg.q, mem.w"
        ]
    },
    "stosw": {
        "detail": [
            "Store String"
        ],
        "description": [
            "mem.w, reg"
        ]
    },
    "por": {
        "detail": [
            "Bitwise Logical OR"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "xtest": {
        "detail": [
            "Test If In Transactional Execution"
        ],
        "description": [
            ""
        ]
    },
    "lddqu": {
        "detail": [
            "Load Unaligned Integer 128 Bits"
        ],
        "description": [
            "reg.x, mem.x"
        ]
    },
    "kxnorq": {
        "detail": [
            "Bitwise Logical XNOR Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "lgs": {
        "detail": [
            "Load Far Pointer"
        ],
        "description": [
            "reg.w, mem.d, reg"
        ]
    },
    "phaddsw": {
        "detail": [
            "Packed Horizontal Add and Saturate"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "kxnorw": {
        "detail": [
            "Bitwise Logical XNOR Masks"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "vpsignw": {
        "detail": [
            "Packed SIGN"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "andn": {
        "detail": [
            "Logical AND NOT"
        ],
        "description": [
            "reg.d, reg.d, reg.d",
            "reg.d, reg.d, mem.d"
        ]
    },
    "mcommit": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "retfq": {
        "detail": [
            "Return from Procedure"
        ],
        "description": [
            "reg.q, reg.q, mem.x",
            "imm.w, reg.q, reg.q, mem.x"
        ]
    },
    "testui": {
        "detail": [
            ""
        ],
        "description": [
            "reg.1"
        ]
    },
    "retfw": {
        "detail": [
            "Return from Procedure"
        ],
        "description": [
            "reg.q, reg.q, mem.d",
            "imm.w, reg.q, reg.q, mem.d"
        ]
    },
    "fucompp": {
        "detail": [
            "Unordered Compare Floating Point Values"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg"
        ]
    },
    "lock adc": {
        "detail": [
            "Add with Carry"
        ],
        "description": [
            "mem.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "lock add": {
        "detail": [
            "Add"
        ],
        "description": [
            "mem.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "vpconflictd": {
        "detail": [
            "Detect Conflicts Within a Vector of Packed Dword/Qword Values into Dense Memory/ Register"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vpcmpub": {
        "detail": [
            "Compare Packed Byte Values Into Mask"
        ],
        "description": [
            "reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.q, reg.x, reg.x, imm.b",
            "reg.q, reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.x, reg.x, imm.b"
        ]
    },
    "rdpkru": {
        "detail": [
            "Read Protection Key Rights for User Pages"
        ],
        "description": [
            "reg, reg, reg"
        ]
    },
    "vpcmpud": {
        "detail": [
            "Compare Packed Integer Values into Mask"
        ],
        "description": [
            "reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.q, reg.z, reg.z, imm.b",
            "reg.q, reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.z, reg.z, imm.b"
        ]
    },
    "lzcnt": {
        "detail": [
            "Count the Number of Leading Zero Bits"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "vpdpwssd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vfixupimmsd": {
        "detail": [
            "Fix Up Special Scalar Float64 Value"
        ],
        "description": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vpconflictq": {
        "detail": [
            "Detect Conflicts Within a Vector of Packed Dword/Qword Values into Dense Memory/ Register"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vpcmpuq": {
        "detail": [
            "Compare Packed Integer Values into Mask"
        ],
        "description": [
            "reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.q, reg.z, reg.z, imm.b",
            "reg.q, reg.q, reg.z, mem.z, imm.b",
            "reg.q, reg.z, reg.z, imm.b"
        ]
    },
    "vaddsubpd": {
        "detail": [
            "Packed Double-FP Add/Subtract"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpcmpuw": {
        "detail": [
            "Compare Packed Word Values Into Mask"
        ],
        "description": [
            "reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.q, reg.x, reg.x, imm.b",
            "reg.q, reg.q, reg.x, mem.x, imm.b",
            "reg.q, reg.x, reg.x, imm.b"
        ]
    },
    "vfixupimmss": {
        "detail": [
            "Fix Up Special Scalar Float32 Value"
        ],
        "description": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vmmcall": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "cvttps2pi": {
        "detail": [
            "Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vaddsubps": {
        "detail": [
            "Packed Single-FP Add/Subtract"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "frstor": {
        "detail": [
            "Restore x87 FPU State"
        ],
        "description": [
            "mem.wdqxz, reg"
        ]
    },
    "vfnmsub213sd": {
        "detail": [
            "Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vbroadcastf128": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "description": [
            "reg.y, mem.x"
        ]
    },
    "vfnmsub213ss": {
        "detail": [
            "Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "setnle": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "vgetmantsd": {
        "detail": [
            "Extract Float64 of Normalized Mantissas from Float64 Scalar"
        ],
        "description": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vmovdqa32": {
        "detail": [
            "Move Aligned Packed Integer Values"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "bndmk": {
        "detail": [
            "Make Bounds"
        ],
        "description": [
            "reg, agen"
        ]
    },
    "vgetmantss": {
        "detail": [
            "Extract Float32 Vector of Normalized Mantissa from Float32 Vector"
        ],
        "description": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "pdep": {
        "detail": [
            "Parallel Bits Deposit"
        ],
        "description": [
            "reg.d, reg.d, mem.d",
            "reg.d, reg.d, reg.d"
        ]
    },
    "movzx": {
        "detail": [
            "Move with Zero-Extend"
        ],
        "description": [
            "reg.w, mem.b",
            "reg.w, reg.b"
        ]
    },
    "sysenter": {
        "detail": [
            "Fast System Call"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "faddp": {
        "detail": [
            "Add"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg"
        ]
    },
    "vpmovdb": {
        "detail": [
            "Down Convert DWord to Byte"
        ],
        "description": [
            "reg.x, reg.z",
            "mem.x, reg.q, reg.z",
            "mem.x, reg.z",
            "reg.x, reg.q, reg.z"
        ]
    },
    "setle": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "vpcmpestrmq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, imm.b, reg, reg, reg.x",
            "reg.x, mem.x, imm.b, reg, reg, reg.x"
        ]
    },
    "vpblendvb": {
        "detail": [
            "Variable Blend Packed Bytes"
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "vpmovdw": {
        "detail": [
            "Down Convert DWord to Word"
        ],
        "description": [
            "reg.y, reg.z",
            "mem.y, reg.q, reg.z",
            "mem.y, reg.z",
            "reg.y, reg.q, reg.z"
        ]
    },
    "vcvtdq2pd": {
        "detail": [
            "Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ]
    },
    "haddpd": {
        "detail": [
            "Packed Double-FP Horizontal Add"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vcvtdq2ps": {
        "detail": [
            "Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "addsubpd": {
        "detail": [
            "Packed Double-FP Add/Subtract"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "pshuflw": {
        "detail": [
            "Shuffle Packed Low Words"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "haddps": {
        "detail": [
            "Packed Single-FP Horizontal Add"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "addsubps": {
        "detail": [
            "Packed Single-FP Add/Subtract"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "repe movsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.b, mem.b, reg.q"
        ]
    },
    "pshufb": {
        "detail": [
            "Packed Shuffle Bytes"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "repe movsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.d, mem.d, reg.q"
        ]
    },
    "pshufd": {
        "detail": [
            "Shuffle Packed Doublewords"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "vcvttps2dq": {
        "detail": [
            "Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "repe movsq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.q, mem.q, reg.q"
        ]
    },
    "vpmadcsswd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "xsaves64": {
        "detail": [
            "Save Processor Extended States Supervisor"
        ],
        "description": [
            "mem.z[4096], reg, reg, reg"
        ]
    },
    "v4fnmaddps": {
        "detail": [
            "Packed Single-Precision Floating-Point Fused Multiply-Add (4-iterations)"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.z, mem.x"
        ]
    },
    "repe movsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.w, mem.w, reg.q"
        ]
    },
    "pshufw": {
        "detail": [
            "Shuffle Packed Words"
        ],
        "description": [
            "reg.q, reg.q, imm.b",
            "reg.q, mem.q, imm.b"
        ]
    },
    "uiret": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, reg.q, mem.w"
        ]
    },
    "vcmppd": {
        "detail": [
            "Compare Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.q, reg.q, reg.z, reg.z, imm.b",
            "reg.q, reg.q, reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "movsxd": {
        "detail": [
            "Move with Sign-Extension"
        ],
        "description": [
            "reg.q, mem.d",
            "reg.q, reg.d"
        ]
    },
    "vpaddsb": {
        "detail": [
            "Add Packed Signed Integers with Signed Saturation"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "clflush": {
        "detail": [
            "Flush Cache Line"
        ],
        "description": [
            "mem.z"
        ]
    },
    "vcmpps": {
        "detail": [
            "Compare Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.q, reg.q, reg.z, reg.z, imm.b",
            "reg.q, reg.q, reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "sqrtpd": {
        "detail": [
            "Square Root of Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "fyl2xp1": {
        "detail": [
            "Compute y * log2(x +1)"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg"
        ]
    },
    "vpmacsswd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "vpmovuswb": {
        "detail": [
            "Down Convert Word to Byte"
        ],
        "description": [
            "reg.x, reg.x",
            "mem.q, reg.q, reg.x",
            "mem.q, reg.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vpaddsw": {
        "detail": [
            "Add Packed Signed Integers with Signed Saturation"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vcvtpd2uqq": {
        "detail": [
            "Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "sqrtps": {
        "detail": [
            "Square Root of Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "sgdt": {
        "detail": [
            "Store Global Descriptor Table Register"
        ],
        "description": [
            "mem.wq, reg"
        ]
    },
    "nop": {
        "detail": [
            "No Operation"
        ],
        "description": [
            "",
            "mem.w",
            "reg.w"
        ]
    },
    "not": {
        "detail": [
            "One's Complement Negation"
        ],
        "description": [
            "mem.b",
            "reg.b"
        ]
    },
    "vpmacssww": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "setnb": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "pblendvb": {
        "detail": [
            "Variable Blend Packed Bytes"
        ],
        "description": [
            "reg.x, reg.x, reg.x",
            "reg.x, mem.x, reg.x"
        ]
    },
    "pfrsqrt": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "setnl": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "cvtdq2pd": {
        "detail": [
            "Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ]
    },
    "setno": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "setnp": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "setns": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "setnz": {
        "detail": [
            "Set Byte on Condition"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "repne outsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.b, reg.q"
        ]
    },
    "cvtdq2ps": {
        "detail": [
            "Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "repne outsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.d, reg.q"
        ]
    },
    "vmovdqa64": {
        "detail": [
            "Move Aligned Packed Integer Values"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.z, reg.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "ptwrite": {
        "detail": [
            "Write Data to a Processor Trace Packet"
        ],
        "description": [
            "mem.d",
            "reg.d"
        ]
    },
    "xbegin": {
        "detail": [
            "Transactional Begin"
        ],
        "description": [
            "relbr.w, reg.q, reg"
        ]
    },
    "repne outsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.w, reg.q"
        ]
    },
    "pcmpistri": {
        "detail": [
            "Packed Compare Implicit Length Strings, Return Index"
        ],
        "description": [
            "reg.x, reg.x, imm.b, reg",
            "reg.x, mem.x, imm.b, reg"
        ]
    },
    "punpckhbw": {
        "detail": [
            "Unpack High Data"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.d"
        ]
    },
    "pcmpistrm": {
        "detail": [
            "Packed Compare Implicit Length Strings, Return Mask"
        ],
        "description": [
            "reg.x, reg.x, imm.b, reg.x",
            "reg.x, mem.x, imm.b, reg.x"
        ]
    },
    "femms": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "vfpclasspd": {
        "detail": [
            "Tests Types Of a Packed Float64 Values"
        ],
        "description": [
            "reg.q, reg.q, mem.x, imm.b",
            "reg.q, reg.x, imm.b",
            "reg.q, mem.x, imm.b",
            "reg.q, reg.q, reg.x, imm.b"
        ]
    },
    "vfpclassps": {
        "detail": [
            "Tests Types Of a Packed Float32 Values"
        ],
        "description": [
            "reg.q, reg.q, mem.x, imm.b",
            "reg.q, reg.x, imm.b",
            "reg.q, mem.x, imm.b",
            "reg.q, reg.q, reg.x, imm.b"
        ]
    },
    "fnstcw": {
        "detail": [
            "Store x87 FPU Control Word"
        ],
        "description": [
            "mem.w, reg, reg"
        ]
    },
    "fpatan": {
        "detail": [
            "Partial Arctangent"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg"
        ]
    },
    "comisd": {
        "detail": [
            "Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS"
        ],
        "description": [
            "reg.q, reg.q",
            "reg.q, mem.q"
        ]
    },
    "fcmovnbe": {
        "detail": [
            "Floating-Point Conditional Move"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "vaesimc": {
        "detail": [
            "Perform the AES InvMixColumn Transformation"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vpor": {
        "detail": [
            "Bitwise Logical OR"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vcvttss2si": {
        "detail": [
            "Convert with Truncation Scalar Single-Precision Floating-Point Value to Integer"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ]
    },
    "vmptrld": {
        "detail": [
            "Load Pointer to Virtual-Machine Control Structure"
        ],
        "description": [
            "mem.q"
        ]
    },
    "xlat": {
        "detail": [
            "Table Look-up Translation"
        ],
        "description": [
            "mem.b, reg"
        ]
    },
    "comiss": {
        "detail": [
            "Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS"
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "bextr": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.d, imm.d",
            "reg.d, mem.d, reg.d",
            "reg.d, reg.d, reg.d",
            "reg.d, mem.d, imm.d"
        ]
    },
    "mov": {
        "detail": [
            "Move"
        ],
        "description": [
            "reg.b, mem.b",
            "mem.b, imm.b",
            "reg.b, reg.b",
            "mem.b, reg.b",
            "reg.q, imm.d"
        ]
    },
    "skinit": {
        "detail": [
            ""
        ],
        "description": [
            "reg"
        ]
    },
    "blci": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "vmovntdq": {
        "detail": [
            "Store Packed Integers Using Non-Temporal Hint"
        ],
        "description": [
            "mem.x, reg.x"
        ]
    },
    "vpmovw2m": {
        "detail": [
            "Convert a Vector Register to a Mask"
        ],
        "description": [
            "reg.q, reg.x"
        ]
    },
    "vextracti128": {
        "detail": [
            "Extract packed Integer Values"
        ],
        "description": [
            "reg.x, reg.y, imm.b",
            "mem.x, reg.y, imm.b"
        ]
    },
    "v4fnmaddss": {
        "detail": [
            "Scalar Single-Precision Floating-Point Fused Multiply-Add (4-iterations)"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.x, mem.x"
        ]
    },
    "prefetchnta": {
        "detail": [
            ""
        ],
        "description": [
            "mem.z"
        ]
    },
    "pandn": {
        "detail": [
            "Logical AND NOT"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "blcs": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "vcmpsd": {
        "detail": [
            "Compare Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.x, mem.q, imm.b",
            "reg.q, reg.q, reg.x, reg.x, imm.b",
            "reg.q, reg.q, reg.x, mem.q, imm.b",
            "reg.x, reg.x, reg.q, imm.b"
        ]
    },
    "aesdeclast": {
        "detail": [
            "Perform Last Round of an AES Decryption Flow"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "psmash": {
        "detail": [
            ""
        ],
        "description": [
            "reg"
        ]
    },
    "vcmpss": {
        "detail": [
            "Compare Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.q, reg.q, reg.x, reg.x, imm.b",
            "reg.q, reg.q, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.d, imm.b"
        ]
    },
    "sqrtsd": {
        "detail": [
            "Compute Square Root of Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpopcntb": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vpopcntd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "aesdec256kl": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.z"
        ]
    },
    "punpckhdq": {
        "detail": [
            "Unpack High Data"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.d"
        ]
    },
    "vpsllvd": {
        "detail": [
            "Variable Bit Shift Left Logical"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "smsw": {
        "detail": [
            "Store Machine Status Word"
        ],
        "description": [
            "reg.w, reg",
            "mem.w, reg"
        ]
    },
    "sqrtss": {
        "detail": [
            "Compute Square Root of Scalar Single-Precision Value"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ]
    },
    "vmovshdup": {
        "detail": [
            "Replicate Single FP Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vzeroall": {
        "detail": [
            "Zero All YMM Registers"
        ],
        "description": [
            ""
        ]
    },
    "vpopcntq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vpopcntw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vpsllvq": {
        "detail": [
            "Variable Bit Shift Left Logical"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "clac": {
        "detail": [
            "Clear AC Flag in EFLAGS Register"
        ],
        "description": [
            ""
        ]
    },
    "vfmaddsub213pd": {
        "detail": [
            "Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "pause": {
        "detail": [
            "Spin Loop Hint"
        ],
        "description": [
            ""
        ]
    },
    "vpsllvw": {
        "detail": [
            "Variable Bit Shift Left Logical"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpmadd52luq": {
        "detail": [
            "Packed Multiply of Unsigned 52-bit Integers and Add the Low 52-bit Products to Qword Accumulators"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpsrldq": {
        "detail": [
            "Shift Double Quadword Right Logical"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "vfmaddpd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "vfmaddsub213ps": {
        "detail": [
            "Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "setssbsy": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "vfmaddps": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "vldmxcsr": {
        "detail": [
            "Load MXCSR Register"
        ],
        "description": [
            "mem.d, reg"
        ]
    },
    "xsave": {
        "detail": [
            "Save Processor Extended States"
        ],
        "description": [
            "mem.z[4096], reg, reg, reg"
        ]
    },
    "pslld": {
        "detail": [
            "Shift Packed Data Left Logical"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ]
    },
    "vhsubpd": {
        "detail": [
            "Packed Double-FP Horizontal Subtract"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "invept": {
        "detail": [
            "Invalidate Translations Derived from EPT"
        ],
        "description": [
            "reg.q, mem.x"
        ]
    },
    "invvpid": {
        "detail": [
            "Invalidate Translations Based on VPID"
        ],
        "description": [
            "reg.q, mem.x"
        ]
    },
    "sfence": {
        "detail": [
            "Store Fence"
        ],
        "description": [
            ""
        ]
    },
    "vaesdec": {
        "detail": [
            "Perform One Round of an AES Decryption Flow"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vprorvd": {
        "detail": [
            "Bit Rotate Right"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "out": {
        "detail": [
            "Output to Port"
        ],
        "description": [
            "reg, reg",
            "imm.b, reg"
        ]
    },
    "repe stosb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.b, reg, reg.q"
        ]
    },
    "vhsubps": {
        "detail": [
            "Packed Single-FP Horizontal Subtract"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "repe stosd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.d, reg, reg.q"
        ]
    },
    "vfpclasssd": {
        "detail": [
            "Tests Types Of a Scalar Float64 Values"
        ],
        "description": [
            "reg.q, reg.q, mem.q, imm.b",
            "reg.q, reg.x, imm.b",
            "reg.q, mem.q, imm.b",
            "reg.q, reg.q, reg.x, imm.b"
        ]
    },
    "psllq": {
        "detail": [
            "Shift Packed Data Left Logical"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ]
    },
    "psllw": {
        "detail": [
            "Shift Packed Data Left Logical"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "reg.q, imm.b"
        ]
    },
    "vprorvq": {
        "detail": [
            "Bit Rotate Right"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "rdpid": {
        "detail": [
            "Read Processor ID"
        ],
        "description": [
            "reg.q, reg.d"
        ]
    },
    "vcvtps2uqq": {
        "detail": [
            "Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.q",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vfnmsub231pd": {
        "detail": [
            "Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "repe stosq": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.q, reg, reg.q"
        ]
    },
    "vfpclassss": {
        "detail": [
            "Tests Types Of a Scalar Float32 Values"
        ],
        "description": [
            "reg.q, reg.q, mem.d, imm.b",
            "reg.q, reg.x, imm.b",
            "reg.q, mem.d, imm.b",
            "reg.q, reg.q, reg.x, imm.b"
        ]
    },
    "repe stosw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.w, reg, reg.q"
        ]
    },
    "vaddpd": {
        "detail": [
            "Add Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "andpd": {
        "detail": [
            "Bitwise Logical AND of Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vfnmsub231ps": {
        "detail": [
            "Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "rdseed": {
        "detail": [
            "Read Random SEED"
        ],
        "description": [
            "reg.w"
        ]
    },
    "vaddps": {
        "detail": [
            "Add Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "cvttpd2dq": {
        "detail": [
            "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vpermpd": {
        "detail": [
            "Permute Double-Precision Floating-Point Elements"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.y, reg.y, imm.b",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.y, mem.y, imm.b",
            "reg.z, reg.z, reg.z",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "andps": {
        "detail": [
            "Bitwise Logical AND of Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "outsb": {
        "detail": [
            "Output String to Port"
        ],
        "description": [
            "reg, mem.b"
        ]
    },
    "outsd": {
        "detail": [
            "Output String to Port"
        ],
        "description": [
            "reg, mem.d"
        ]
    },
    "movshdup": {
        "detail": [
            "Replicate Single FP Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "fxrstor64": {
        "detail": [
            "Restore x87 FPU, MMX, XMM, and MXCSR State"
        ],
        "description": [
            "mem.[4096], reg"
        ]
    },
    "jle": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "vpmovzxwd": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q",
            "reg.z, reg.q, mem.y",
            "reg.z, reg.q, reg.y"
        ]
    },
    "vpermps": {
        "detail": [
            "Permute Single-Precision Floating-Point Elements"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.y, reg.y, mem.y",
            "reg.y, reg.y, reg.y"
        ]
    },
    "vpmovzxwq": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "description": [
            "reg.x, mem.d",
            "reg.x, reg.d",
            "reg.z, reg.q, mem.x",
            "reg.z, reg.q, reg.x"
        ]
    },
    "outsw": {
        "detail": [
            "Output String to Port"
        ],
        "description": [
            "reg, mem.w"
        ]
    },
    "vcvtneps2bf16": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "fldenv": {
        "detail": [
            "Load x87 FPU Environment"
        ],
        "description": [
            "mem.wdq, reg"
        ]
    },
    "vmxon": {
        "detail": [
            "Enter VMX Operation"
        ],
        "description": [
            "mem.q"
        ]
    },
    "cmovnle": {
        "detail": [
            "Conditional Move"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "shld": {
        "detail": [
            "Double Precision Shift Left"
        ],
        "description": [
            "reg.w, reg.w, imm.b",
            "reg.w, reg.w, imm.b",
            "mem.w, reg.w, imm.b",
            "reg.w, reg.w, reg",
            "mem.w, reg.w, reg",
            "mem.w, reg.w, imm.b"
        ]
    },
    "movlpd": {
        "detail": [
            "Move Low Packed Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.q, mem.q",
            "mem.q, reg.q"
        ]
    },
    "movnti": {
        "detail": [
            "Store Doubleword Using Non-Temporal Hint"
        ],
        "description": [
            "mem.d, reg.d"
        ]
    },
    "vpermilpd": {
        "detail": [
            "Permute In-Lane of Pairs of Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "loope": {
        "detail": [
            "Loop According to ECX Counter"
        ],
        "description": [
            "relbr.b, reg.q, reg.q"
        ]
    },
    "movntq": {
        "detail": [
            "Store of Quadword Using Non-Temporal Hint"
        ],
        "description": [
            "mem.q, reg.q"
        ]
    },
    "movlps": {
        "detail": [
            "Move Low Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.q, mem.q",
            "mem.q, reg.q"
        ]
    },
    "vpsubb": {
        "detail": [
            "Subtract Packed Integers"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vcvtuqq2pd": {
        "detail": [
            "Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vpsubd": {
        "detail": [
            "Subtract Packed Integers"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "shlx": {
        "detail": [
            "Shift Without Affecting Flags"
        ],
        "description": [
            "reg.d, reg.d, reg.d",
            "reg.d, mem.d, reg.d"
        ]
    },
    "vpermilps": {
        "detail": [
            "Permute In-Lane of Quadruples of Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "jmp": {
        "detail": [
            "Jump"
        ],
        "description": [
            "reg.q, reg.q",
            "mem.q, reg.q",
            "relbr.d, reg.q"
        ]
    },
    "divpd": {
        "detail": [
            "Divide Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "rdtsc": {
        "detail": [
            "Read Time-Stamp Counter"
        ],
        "description": [
            "reg, reg, reg"
        ]
    },
    "divps": {
        "detail": [
            "Divide Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vpsubq": {
        "detail": [
            "Subtract Packed Quadword Integers"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vcvtuqq2ps": {
        "detail": [
            "Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "maxpd": {
        "detail": [
            "Maximum of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vpsubw": {
        "detail": [
            "Subtract Packed Integers"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "fsin": {
        "detail": [
            "Sine"
        ],
        "description": [
            "reg.wq, reg"
        ]
    },
    "vfnmsub132pd": {
        "detail": [
            "Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vfmaddsd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.q, reg.q, mem.q",
            "reg.x, reg.q, reg.q, reg.q",
            "reg.x, reg.q, mem.q, reg.q"
        ]
    },
    "repe xcryptecb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.b, reg, reg.d, reg, mem.b"
        ]
    },
    "vbroadcasti128": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "description": [
            "reg.y, mem.x"
        ]
    },
    "maxps": {
        "detail": [
            "Maximum of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "wbinvd": {
        "detail": [
            "Write Back and Invalidate Cache"
        ],
        "description": [
            ""
        ]
    },
    "punpcklqdq": {
        "detail": [
            "Unpack Low Data"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.q"
        ]
    },
    "vfnmsub132ps": {
        "detail": [
            "Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "lock and": {
        "detail": [
            "Logical AND"
        ],
        "description": [
            "mem.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "vfmaddss": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.d, reg.d, mem.d",
            "reg.x, reg.d, reg.d, reg.d",
            "reg.x, reg.d, mem.d, reg.d"
        ]
    },
    "fucom": {
        "detail": [
            "Unordered Compare Floating Point Values"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "vpabsb": {
        "detail": [
            "Packed Absolute Value"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vpabsd": {
        "detail": [
            "Packed Absolute Value"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "pmovzxwd": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.q"
        ]
    },
    "jnb": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "vpabsq": {
        "detail": [
            "Packed Absolute Value"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vpunpcklbw": {
        "detail": [
            "Unpack Low Data"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "pmovzxwq": {
        "detail": [
            "Packed Move with Zero Extend"
        ],
        "description": [
            "reg.x, mem.d",
            "reg.x, reg.d"
        ]
    },
    "jnl": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "vpabsw": {
        "detail": [
            "Packed Absolute Value"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "jno": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "jnp": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "jns": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "xrstor64": {
        "detail": [
            "Restore Processor Extended States"
        ],
        "description": [
            "mem.z[4096], reg, reg, reg"
        ]
    },
    "jnz": {
        "detail": [
            "Jump if Condition Is Met"
        ],
        "description": [
            "relbr.b, reg.q"
        ]
    },
    "lock or": {
        "detail": [
            "Logical Inclusive OR"
        ],
        "description": [
            "mem.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "vfnmsub231sd": {
        "detail": [
            "Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "cvttsd2si": {
        "detail": [
            "Convert with Truncation Scalar Double-Precision Floating-Point Value to Signed Integer"
        ],
        "description": [
            "reg.d, mem.q",
            "reg.d, reg.q"
        ]
    },
    "vaddsd": {
        "detail": [
            "Add Scalar Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.q"
        ]
    },
    "vfnmsub231ss": {
        "detail": [
            "Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "incsspd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.q"
        ]
    },
    "vpcmpgtb": {
        "detail": [
            "Compare Packed Signed Integers for Greater Than"
        ],
        "description": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "kunpckbw": {
        "detail": [
            "Unpack for Mask Registers"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "vaddss": {
        "detail": [
            "Add Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ]
    },
    "vpcmpgtd": {
        "detail": [
            "Compare Packed Signed Integers for Greater Than"
        ],
        "description": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "umwait": {
        "detail": [
            "User Level Monitor Wait"
        ],
        "description": [
            "reg.d, reg.d, reg.d"
        ]
    },
    "vextractps": {
        "detail": [
            "Extract Packed Floating-Point Values"
        ],
        "description": [
            "reg.d, reg.x, imm.b",
            "mem.d, reg.x, imm.b"
        ]
    },
    "gf2p8affineinvqb": {
        "detail": [
            "Galois Field Affine Transformation Inverse"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "prefetcht0": {
        "detail": [
            ""
        ],
        "description": [
            "mem.z"
        ]
    },
    "vgatherqpd": {
        "detail": [
            "Gather Packed Single, Packed Double with Signed Qword Indices"
        ],
        "description": [
            "reg.z, reg.q, mem.q",
            "reg.y, mem.q, reg.y"
        ]
    },
    "incsspq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "vrsqrt28pd": {
        "detail": [
            "Approximation to the Reciprocal Square Root of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "prefetcht1": {
        "detail": [
            ""
        ],
        "description": [
            "mem.z"
        ]
    },
    "vpcmpgtq": {
        "detail": [
            "Compare Packed Data for Greater Than"
        ],
        "description": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "mul": {
        "detail": [
            "Unsigned Multiply"
        ],
        "description": [
            "reg.b, reg, reg",
            "mem.b, reg, reg"
        ]
    },
    "lsl": {
        "detail": [
            "Load Segment Limit"
        ],
        "description": [
            "reg.w, reg.w",
            "reg.w, mem.w"
        ]
    },
    "phsubd": {
        "detail": [
            "Packed Horizontal Subtract"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "pfrcpit1": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "pfrcpit2": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpcmpgtw": {
        "detail": [
            "Compare Packed Signed Integers for Greater Than"
        ],
        "description": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vmload": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q"
        ]
    },
    "lss": {
        "detail": [
            "Load Far Pointer"
        ],
        "description": [
            "reg.w, mem.d, reg"
        ]
    },
    "vgatherqps": {
        "detail": [
            "Gather Packed Single, Packed Double with Signed Qword Indices"
        ],
        "description": [
            "reg.y, reg.q, mem.d",
            "reg.x, mem.d, reg.x"
        ]
    },
    "prefetcht2": {
        "detail": [
            ""
        ],
        "description": [
            "mem.z"
        ]
    },
    "vrsqrt28ps": {
        "detail": [
            "Approximation to the Reciprocal Square Root of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "seamcall": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q"
        ]
    },
    "repe xsha256": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg.q, reg, mem.b, mem.b"
        ]
    },
    "vfmsubaddpd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "fmulp": {
        "detail": [
            "Multiply"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg"
        ]
    },
    "rdpmc": {
        "detail": [
            "Read Performance-Monitoring Counters"
        ],
        "description": [
            "reg, reg, reg, reg"
        ]
    },
    "fistp": {
        "detail": [
            "Store Integer"
        ],
        "description": [
            "mem.d, reg.wq, reg, reg"
        ]
    },
    "vpblendd": {
        "detail": [
            "Blend Packed Dwords"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "fptan": {
        "detail": [
            "Partial Tangent"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "phsubw": {
        "detail": [
            "Packed Horizontal Subtract"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "saveprevssp": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q"
        ]
    },
    "vfmsubaddps": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "rcpps": {
        "detail": [
            "Compute Reciprocals of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "shufpd": {
        "detail": [
            "Packed Interleave Shuffle of Pairs of Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "psadbw": {
        "detail": [
            "Compute Sum of Absolute Differences"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "pfrcp": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpblendw": {
        "detail": [
            "Blend Packed Words"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "sysexit": {
        "detail": [
            "Fast Return from Fast System Call"
        ],
        "description": [
            "reg.q, reg.q, reg, reg"
        ]
    },
    "repe insb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.b, reg, reg.q"
        ]
    },
    "repe insd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.d, reg, reg.q"
        ]
    },
    "vscatterdpd": {
        "detail": [
            "Scatter Packed Single, Packed Double with Signed Dword and Qword Indices"
        ],
        "description": [
            "mem.q, reg.q, reg.z"
        ]
    },
    "shufps": {
        "detail": [
            "Packed Interleave Shuffle of Quadruplets of Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "vpcmpeqb": {
        "detail": [
            "Compare Packed Data for Equal"
        ],
        "description": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpcomub": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vpcmpeqd": {
        "detail": [
            "Compare Packed Data for Equal"
        ],
        "description": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpcomud": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "pinsrb": {
        "detail": [
            "Insert Byte/Dword/Qword"
        ],
        "description": [
            "reg.x, reg.d, imm.b",
            "reg.x, mem.b, imm.b"
        ]
    },
    "pinsrd": {
        "detail": [
            "Insert Byte/Dword/Qword"
        ],
        "description": [
            "reg.x, reg.d, imm.b",
            "reg.x, mem.d, imm.b"
        ]
    },
    "fisub": {
        "detail": [
            "Subtract"
        ],
        "description": [
            "reg.wq, mem.d, reg"
        ]
    },
    "vpunpckldq": {
        "detail": [
            "Unpack Low Data"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "inc": {
        "detail": [
            "Increment by 1"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "vscatterdps": {
        "detail": [
            "Scatter Packed Single, Packed Double with Signed Dword and Qword Indices"
        ],
        "description": [
            "mem.d, reg.q, reg.z"
        ]
    },
    "repe insw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.w, reg, reg.q"
        ]
    },
    "divsd": {
        "detail": [
            "Divide Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpcmpeqq": {
        "detail": [
            "Compare Packed Qword Data for Equal"
        ],
        "description": [
            "reg.q, reg.q, reg.z, mem.z",
            "reg.q, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpcomuq": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "pinsrq": {
        "detail": [
            "Insert Byte/Dword/Qword"
        ],
        "description": [
            "reg.x, reg.q, imm.b",
            "reg.x, mem.q, imm.b"
        ]
    },
    "vpcmpeqw": {
        "detail": [
            "Compare Packed Data for Equal"
        ],
        "description": [
            "reg.q, reg.q, reg.x, mem.x",
            "reg.q, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "ltr": {
        "detail": [
            "Load Task Register"
        ],
        "description": [
            "reg.w, reg",
            "mem.w, reg"
        ]
    },
    "vpcomuw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vcvttpd2udq": {
        "detail": [
            "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers"
        ],
        "description": [
            "reg.y, mem.z",
            "reg.y, reg.z",
            "reg.y, reg.q, mem.z",
            "reg.y, reg.q, reg.z"
        ]
    },
    "pinsrw": {
        "detail": [
            "Insert Word"
        ],
        "description": [
            "reg.q, reg.d, imm.b",
            "reg.q, mem.w, imm.b"
        ]
    },
    "int": {
        "detail": [
            "Call to Interrupt Procedure"
        ],
        "description": [
            "imm.b, reg.q"
        ]
    },
    "hlt": {
        "detail": [
            "Halt"
        ],
        "description": [
            ""
        ]
    },
    "vcvtps2dq": {
        "detail": [
            "Convert Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "divss": {
        "detail": [
            "Divide Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ]
    },
    "pmaxsb": {
        "detail": [
            "Maximum of Packed Signed Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "maxsd": {
        "detail": [
            "Return Maximum Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "clgi": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "cbw": {
        "detail": [
            "Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword"
        ],
        "description": [
            "reg, reg"
        ]
    },
    "pmaxsd": {
        "detail": [
            "Maximum of Packed Signed Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vfnmsub132sd": {
        "detail": [
            "Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vmptrst": {
        "detail": [
            "Store Pointer to Virtual-Machine Control Structure"
        ],
        "description": [
            "mem.q"
        ]
    },
    "repe xcryptcbc": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.b, reg, reg.d, reg, reg.q, mem.b"
        ]
    },
    "fucomi": {
        "detail": [
            "Compare Floating Point Values and Set EFLAGS"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "pmaxsw": {
        "detail": [
            "Maximum of Packed Signed Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "maxss": {
        "detail": [
            "Return Maximum Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ]
    },
    "fucomp": {
        "detail": [
            "Unordered Compare Floating Point Values"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg"
        ]
    },
    "vfnmsub132ss": {
        "detail": [
            "Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "kunpckdq": {
        "detail": [
            "Unpack for Mask Registers"
        ],
        "description": [
            "reg.q, reg.q, reg.q"
        ]
    },
    "leave": {
        "detail": [
            "High Level Procedure Exit"
        ],
        "description": [
            "mem.q, reg.q, reg.q"
        ]
    },
    "rex64 xbegin": {
        "detail": [
            "Transactional Begin"
        ],
        "description": [
            "relbr.d, reg.q, reg"
        ]
    },
    "kmovb": {
        "detail": [
            "Move from and to Mask Registers"
        ],
        "description": [
            "reg.q, mem.b",
            "reg.q, reg.q",
            "mem.b, reg.q"
        ]
    },
    "kmovd": {
        "detail": [
            "Move from and to Mask Registers"
        ],
        "description": [
            "reg.q, mem.d",
            "reg.q, reg.q",
            "mem.d, reg.q"
        ]
    },
    "dec": {
        "detail": [
            "Decrement by 1"
        ],
        "description": [
            "reg.b",
            "mem.b"
        ]
    },
    "phminposuw": {
        "detail": [
            "Packed Horizontal Word Minimum"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "kmovq": {
        "detail": [
            "Move from and to Mask Registers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q",
            "mem.q, reg.q"
        ]
    },
    "aeskeygenassist": {
        "detail": [
            "AES Round Key Generation Assist"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "vmovupd": {
        "detail": [
            "Move Unaligned Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.x, reg.x",
            "reg.z, reg.q, reg.z"
        ]
    },
    "pfpnacc": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "kmovw": {
        "detail": [
            "Move from and to Mask Registers"
        ],
        "description": [
            "reg.q, mem.w",
            "reg.q, reg.q",
            "mem.w, reg.q"
        ]
    },
    "enter": {
        "detail": [
            "Make Stack Frame for Procedure Parameters"
        ],
        "description": [
            "imm.w, imm.b, reg.q, reg.q, mem.q"
        ]
    },
    "vmovups": {
        "detail": [
            "Move Unaligned Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "mem.z, reg.q, reg.z",
            "mem.x, reg.x",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vmpsadbw": {
        "detail": [
            "Compute Multiple Packed Sums of Absolute Difference"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "lock btc": {
        "detail": [
            "Bit Test and Complement"
        ],
        "description": [
            "mem.w, imm.b",
            "mem.w, reg.w"
        ]
    },
    "vperm2f128": {
        "detail": [
            "Permute Floating-Point Values"
        ],
        "description": [
            "reg.y, reg.y, mem.y, imm.b",
            "reg.y, reg.y, reg.y, imm.b"
        ]
    },
    "lock btr": {
        "detail": [
            "Bit Test and Reset"
        ],
        "description": [
            "mem.w, imm.b",
            "mem.w, reg.w"
        ]
    },
    "lock bts": {
        "detail": [
            "Bit Test and Set"
        ],
        "description": [
            "mem.w, imm.b",
            "mem.w, reg.w"
        ]
    },
    "vpextrb": {
        "detail": [
            "Extract Byte/Dword/Qword"
        ],
        "description": [
            "reg.d, reg.x, imm.b",
            "mem.b, reg.x, imm.b"
        ]
    },
    "vpextrd": {
        "detail": [
            "Extract Byte/Dword/Qword"
        ],
        "description": [
            "reg.d, reg.x, imm.b",
            "mem.d, reg.x, imm.b"
        ]
    },
    "knotb": {
        "detail": [
            "NOT Mask Register"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "vcvtqq2pd": {
        "detail": [
            "Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "knotd": {
        "detail": [
            "NOT Mask Register"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "vrsqrt28sd": {
        "detail": [
            "Approximation to the Reciprocal Square Root of Scalar Double-Precision Floating-Point Value with Less Than 2^-28 Relative Error"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "fwait": {
        "detail": [
            "Wait"
        ],
        "description": [
            ""
        ]
    },
    "vaesenc": {
        "detail": [
            "Perform One Round of an AES Encryption Flow"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "cvtps2dq": {
        "detail": [
            "Convert Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vpextrq": {
        "detail": [
            "Extract Byte/Dword/Qword"
        ],
        "description": [
            "reg.q, reg.x, imm.b",
            "mem.q, reg.x, imm.b"
        ]
    },
    "vpminsb": {
        "detail": [
            "Minimum of Packed Signed Integers"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpminsd": {
        "detail": [
            "Minimum of Packed Signed Integers"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vcvtqq2ps": {
        "detail": [
            "Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.x",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vpmovqb": {
        "detail": [
            "Down Convert QWord to Byte"
        ],
        "description": [
            "reg.x, reg.z",
            "mem.q, reg.q, reg.z",
            "mem.q, reg.z",
            "reg.x, reg.q, reg.z"
        ]
    },
    "vpextrw": {
        "detail": [
            "Extract Word"
        ],
        "description": [
            "reg.d, reg.x, imm.b",
            "mem.w, reg.x, imm.b"
        ]
    },
    "vpmovqd": {
        "detail": [
            "Down Convert QWord to DWord"
        ],
        "description": [
            "reg.y, reg.z",
            "mem.y, reg.q, reg.z",
            "mem.y, reg.z",
            "reg.y, reg.q, reg.z"
        ]
    },
    "aesenc128kl": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.xy"
        ]
    },
    "knotw": {
        "detail": [
            "NOT Mask Register"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "vpsrad": {
        "detail": [
            "Shift Packed Data Right Arithmetic"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.z, reg.q, reg.z, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.z, mem.z, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "vscatterpf0dpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint with Intent to Write"
        ],
        "description": [
            "mem.q, reg.q"
        ]
    },
    "vrsqrt28ss": {
        "detail": [
            "Approximation to the Reciprocal Square Root of Scalar Single-Precision Floating- Point Value with Less Than 2^-28 Relative Error"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpsraq": {
        "detail": [
            "Shift Packed Data Right Arithmetic"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.x",
            "reg.z, reg.q, mem.z, imm.b",
            "reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, reg.x",
            "reg.z, reg.z, mem.x",
            "reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.x",
            "reg.z, reg.q, reg.z, imm.b"
        ]
    },
    "pmaxub": {
        "detail": [
            "Maximum of Packed Unsigned Integers"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "pfrsqit1": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vpminsq": {
        "detail": [
            "Minimum of Packed Signed Integers"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "knotq": {
        "detail": [
            "NOT Mask Register"
        ],
        "description": [
            "reg.q, reg.q"
        ]
    },
    "vpsraw": {
        "detail": [
            "Shift Packed Data Right Arithmetic"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, mem.x, imm.b",
            "reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x",
            "reg.x, reg.q, reg.x, imm.b"
        ]
    },
    "vpmadd52huq": {
        "detail": [
            "Packed Multiply of Unsigned 52-bit Unsigned Integers and Add High 52-bit Products to 64-bit Accumulators"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpminsw": {
        "detail": [
            "Minimum of Packed Signed Integers"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vscatterpf0dps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint with Intent to Write"
        ],
        "description": [
            "mem.d, reg.q"
        ]
    },
    "vpmovqw": {
        "detail": [
            "Down Convert QWord to Word"
        ],
        "description": [
            "reg.x, reg.z",
            "mem.x, reg.q, reg.z",
            "mem.x, reg.z",
            "reg.x, reg.q, reg.z"
        ]
    },
    "pmaxuw": {
        "detail": [
            "Maximum of Packed Unsigned Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "rcpss": {
        "detail": [
            "Compute Reciprocal of Scalar Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ]
    },
    "cdq": {
        "detail": [
            "Convert Word to Doubleword/Convert Doubleword to Quadword"
        ],
        "description": [
            "reg, reg"
        ]
    },
    "pmaxud": {
        "detail": [
            "Maximum of Packed Unsigned Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "leavew": {
        "detail": [
            "High Level Procedure Exit"
        ],
        "description": [
            "mem.w, reg.w, reg.w"
        ]
    },
    "shrd": {
        "detail": [
            "Double Precision Shift Right"
        ],
        "description": [
            "reg.w, reg.w, imm.b",
            "reg.w, reg.w, imm.b",
            "mem.w, reg.w, imm.b",
            "reg.w, reg.w, reg",
            "mem.w, reg.w, reg",
            "mem.w, reg.w, imm.b"
        ]
    },
    "vcvtss2sd": {
        "detail": [
            "Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.d"
        ]
    },
    "rdfsbase": {
        "detail": [
            "Read FS/GS Segment Base"
        ],
        "description": [
            "reg.d, reg.d"
        ]
    },
    "vcvtss2si": {
        "detail": [
            "Convert Scalar Single-Precision Floating-Point Value to Doubleword Integer"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ]
    },
    "invpcid": {
        "detail": [
            "Invalidate Process-Context Identifier"
        ],
        "description": [
            "reg.q, mem.x"
        ]
    },
    "vexpandpd": {
        "detail": [
            "Load Sparse Packed Double-Precision Floating-Point Values from Dense Memory"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "shrx": {
        "detail": [
            "Shift Without Affecting Flags"
        ],
        "description": [
            "reg.d, reg.d, reg.d",
            "reg.d, mem.d, reg.d"
        ]
    },
    "vplzcntd": {
        "detail": [
            "Count the Number of Leading Zero Bits for Packed Dword, Packed Qword Values"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vmovhlps": {
        "detail": [
            "Move Packed Single-Precision Floating-Point Values High to Low"
        ],
        "description": [
            "reg.x, reg.x, reg.x"
        ]
    },
    "vcvttps2qq": {
        "detail": [
            "Convert with Truncation Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values"
        ],
        "description": [
            "reg.x, mem.q",
            "reg.x, reg.x",
            "reg.x, reg.q, mem.q",
            "reg.x, reg.q, reg.x"
        ]
    },
    "vphaddd": {
        "detail": [
            "Packed Horizontal Add"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vexpandps": {
        "detail": [
            "Load Sparse Packed Single-Precision Floating-Point Values from Dense Memory"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vpmadcswd": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, reg.x, reg.x, reg.x",
            "reg.x, reg.x, mem.x, reg.x"
        ]
    },
    "vplzcntq": {
        "detail": [
            "Count the Number of Leading Zero Bits for Packed Dword, Packed Qword Values"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "xgetbv": {
        "detail": [
            "Get Value of Extended Control Register"
        ],
        "description": [
            "reg, reg, reg, reg"
        ]
    },
    "seamret": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "vphaddw": {
        "detail": [
            "Packed Horizontal Add"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "movntdq": {
        "detail": [
            "Store Packed Integers Using Non-Temporal Hint"
        ],
        "description": [
            "mem.x, reg.x"
        ]
    },
    "vdbpsadbw": {
        "detail": [
            "Double Block Packed Sum-Absolute-Differences (SAD) on Unsigned Bytes"
        ],
        "description": [
            "reg.x, reg.x, mem.x, imm.b",
            "reg.x, reg.q, reg.x, reg.x, imm.b",
            "reg.x, reg.q, reg.x, mem.x, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "pand": {
        "detail": [
            "Logical AND"
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vrsqrt14pd": {
        "detail": [
            "Compute Approximate Reciprocals of Square Roots of Packed Float64 Values"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "fld": {
        "detail": [
            "Load Floating Point Value"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg",
            "reg.wq, mem.d, reg, reg"
        ]
    },
    "vinsertf128": {
        "detail": [
            "Insert Packed Floating-Point Values"
        ],
        "description": [
            "reg.y, reg.y, mem.x, imm.b",
            "reg.y, reg.y, reg.x, imm.b"
        ]
    },
    "fxrstor": {
        "detail": [
            "Restore x87 FPU, MMX, XMM, and MXCSR State"
        ],
        "description": [
            "mem.[4096], reg"
        ]
    },
    "vpminub": {
        "detail": [
            "Minimum of Packed Unsigned Integers"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpminud": {
        "detail": [
            "Minimum of Packed Unsigned Integers"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpmulhuw": {
        "detail": [
            "Multiply Packed Unsigned Integers and Store High Result"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "dppd": {
        "detail": [
            "Dot Product of Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "vrsqrt14ps": {
        "detail": [
            "Compute Approximate Reciprocals of Square Roots of Packed Float32 Values"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "repe outsb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.b, reg.q"
        ]
    },
    "repe outsd": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.d, reg.q"
        ]
    },
    "vfmaddsub231pd": {
        "detail": [
            "Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vpminuq": {
        "detail": [
            "Minimum of Packed Unsigned Integers"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "valignd": {
        "detail": [
            "Align Doubleword/Quadword Vectors"
        ],
        "description": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ]
    },
    "dpps": {
        "detail": [
            "Dot Product of Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, reg.x, imm.b",
            "reg.x, mem.x, imm.b"
        ]
    },
    "vpminuw": {
        "detail": [
            "Minimum of Packed Unsigned Integers"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "repe xcryptcfb": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "mem.b, reg, reg.d, reg, reg.q, mem.b"
        ]
    },
    "vcvttps2udq": {
        "detail": [
            "Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values"
        ],
        "description": [
            "reg.z, mem.z",
            "reg.z, reg.z",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vmsave": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "vfmaddsub231ps": {
        "detail": [
            "Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "valignq": {
        "detail": [
            "Align Doubleword/Quadword Vectors"
        ],
        "description": [
            "reg.z, reg.z, mem.z, imm.b",
            "reg.z, reg.q, reg.z, reg.z, imm.b",
            "reg.z, reg.q, reg.z, mem.z, imm.b",
            "reg.z, reg.z, reg.z, imm.b"
        ]
    },
    "repe outsw": {
        "detail": [
            "Repeat String Operation Prefix"
        ],
        "description": [
            "reg, mem.w, reg.q"
        ]
    },
    "rdpru": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.d, reg.d"
        ]
    },
    "punpcklwd": {
        "detail": [
            "Unpack Low Data"
        ],
        "description": [
            "reg.q, mem.d",
            "reg.q, reg.d"
        ]
    },
    "cvtss2sd": {
        "detail": [
            "Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.q, mem.d",
            "reg.q, reg.d"
        ]
    },
    "cvtss2si": {
        "detail": [
            "Convert Scalar Single-Precision Floating-Point Value to Doubleword Integer"
        ],
        "description": [
            "reg.d, mem.d",
            "reg.d, reg.d"
        ]
    },
    "movhpd": {
        "detail": [
            "Move High Packed Double-Precision Floating-Point Value"
        ],
        "description": [
            "reg.q, mem.q",
            "mem.q, reg.q"
        ]
    },
    "pf2id": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vtestpd": {
        "detail": [
            "Packed Bit Test"
        ],
        "description": [
            "reg.x, reg.x",
            "reg.x, mem.x"
        ]
    },
    "ldmxcsr": {
        "detail": [
            "Load MXCSR Register"
        ],
        "description": [
            "mem.d, reg"
        ]
    },
    "tzmsk": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "movhps": {
        "detail": [
            "Move High Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.q, mem.q",
            "mem.q, reg.x"
        ]
    },
    "vmovntpd": {
        "detail": [
            "Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint"
        ],
        "description": [
            "mem.x, reg.x"
        ]
    },
    "pf2iw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vtestps": {
        "detail": [
            "Packed Bit Test"
        ],
        "description": [
            "reg.x, reg.x",
            "reg.x, mem.x"
        ]
    },
    "pmuldq": {
        "detail": [
            "Multiply Packed Doubleword Integers"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "endbr32": {
        "detail": [
            ""
        ],
        "description": [
            ""
        ]
    },
    "vscatterpf1dpd": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint with Intent to Write"
        ],
        "description": [
            "mem.q, reg.q"
        ]
    },
    "vmovntps": {
        "detail": [
            "Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint"
        ],
        "description": [
            "mem.x, reg.x"
        ]
    },
    "div": {
        "detail": [
            "Unsigned Divide"
        ],
        "description": [
            "reg.b, reg",
            "reg.w, reg.w, reg.w",
            "mem.b, reg",
            "mem.w, reg.w, reg.w"
        ]
    },
    "ftst": {
        "detail": [
            "TEST"
        ],
        "description": [
            "reg.wq, reg"
        ]
    },
    "vpmovq2m": {
        "detail": [
            "Convert a Vector Register to a Mask"
        ],
        "description": [
            "reg.q, reg.x"
        ]
    },
    "vscatterpf1dps": {
        "detail": [
            "Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint with Intent to Write"
        ],
        "description": [
            "mem.d, reg.q"
        ]
    },
    "vpxor": {
        "detail": [
            "Logical Exclusive OR"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpmaddwd": {
        "detail": [
            "Multiply and Add Packed Integers"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vbroadcastsd": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "description": [
            "reg.y, mem.q",
            "reg.y, reg.x",
            "reg.z, reg.q, mem.q",
            "reg.z, reg.q, reg.x"
        ]
    },
    "vbroadcastss": {
        "detail": [
            "Load with Broadcast Floating-Point Data"
        ],
        "description": [
            "reg.x, mem.d",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.d",
            "reg.z, reg.q, reg.x"
        ]
    },
    "pext": {
        "detail": [
            "Parallel Bits Extract"
        ],
        "description": [
            "reg.d, reg.d, mem.d",
            "reg.d, reg.d, reg.d"
        ]
    },
    "fld1": {
        "detail": [
            "Load Constant"
        ],
        "description": [
            "reg.wq, reg, reg"
        ]
    },
    "vpcmpistri": {
        "detail": [
            "Packed Compare Implicit Length Strings, Return Index"
        ],
        "description": [
            "reg.x, reg.x, imm.b, reg",
            "reg.x, mem.x, imm.b, reg"
        ]
    },
    "adc": {
        "detail": [
            "Add with Carry"
        ],
        "description": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "add": {
        "detail": [
            "Add"
        ],
        "description": [
            "reg.b, reg.b",
            "mem.b, imm.b",
            "reg.b, mem.b",
            "reg.b, imm.b",
            "mem.b, reg.b"
        ]
    },
    "vpunpckhbw": {
        "detail": [
            "Unpack High Data"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpcmpistrm": {
        "detail": [
            "Packed Compare Implicit Length Strings, Return Mask"
        ],
        "description": [
            "reg.x, reg.x, imm.b, reg.x",
            "reg.x, mem.x, imm.b, reg.x"
        ]
    },
    "fdivp": {
        "detail": [
            "Divide"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg"
        ]
    },
    "fdivr": {
        "detail": [
            "Reverse Divide"
        ],
        "description": [
            "reg.wq, mem.d, reg",
            "reg.wq, reg.wq, reg"
        ]
    },
    "vmovsldup": {
        "detail": [
            "Replicate Single FP Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x",
            "reg.z, reg.q, mem.z",
            "reg.z, reg.q, reg.z"
        ]
    },
    "vinsertps": {
        "detail": [
            "Insert Scalar Single-Precision Floating-Point Value"
        ],
        "description": [
            "reg.x, reg.x, mem.d, imm.b",
            "reg.x, reg.x, reg.x, imm.b"
        ]
    },
    "vfmaddsub132pd": {
        "detail": [
            "Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "xrstors": {
        "detail": [
            "Restore Processor Extended States Supervisor"
        ],
        "description": [
            "mem.z[4096], reg, reg, reg"
        ]
    },
    "xsavec": {
        "detail": [
            "Save Processor Extended States with Compaction"
        ],
        "description": [
            "mem.z[4096], reg, reg, reg"
        ]
    },
    "vpermi2b": {
        "detail": [
            "Full Permute of Bytes from Two Tables Overwriting the Index"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vpermi2d": {
        "detail": [
            "Full Permute From Two Tables Overwriting the Index"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vfmaddsub132ps": {
        "detail": [
            "Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "adcx": {
        "detail": [
            "Unsigned Integer Addition of Two Operands with Carry Flag"
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "fldz": {
        "detail": [
            "Load Constant"
        ],
        "description": [
            "reg.wq, reg, reg"
        ]
    },
    "xsaves": {
        "detail": [
            "Save Processor Extended States Supervisor"
        ],
        "description": [
            "mem.z[4096], reg, reg, reg"
        ]
    },
    "vpermi2q": {
        "detail": [
            "Full Permute From Two Tables Overwriting the Index"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "vpermi2w": {
        "detail": [
            "Full Permute From Two Tables Overwriting the Index"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.x",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "sahf": {
        "detail": [
            "Store AH into Flags"
        ],
        "description": [
            "reg"
        ]
    },
    "vaesenclast": {
        "detail": [
            "Perform Last Round of an AES Encryption Flow"
        ],
        "description": [
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vminpd": {
        "detail": [
            "Minimum of Packed Double-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vrsqrt14sd": {
        "detail": [
            "Compute Approximate Reciprocal of Square Root of Scalar Float64 Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.q",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.q",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vprolvd": {
        "detail": [
            "Bit Rotate Left"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "monitorx": {
        "detail": [
            ""
        ],
        "description": [
            "reg, reg, reg"
        ]
    },
    "vminps": {
        "detail": [
            "Minimum of Packed Single-Precision Floating-Point Values"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "vrsqrt14ss": {
        "detail": [
            "Compute Approximate Reciprocal of Square Root of Scalar Float32 Value"
        ],
        "description": [
            "reg.x, reg.q, reg.x, mem.d",
            "reg.x, reg.q, reg.x, reg.x",
            "reg.x, reg.x, mem.d",
            "reg.x, reg.x, reg.x"
        ]
    },
    "xorpd": {
        "detail": [
            "Bitwise Logical XOR of Packed Double Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "vprolvq": {
        "detail": [
            "Bit Rotate Left"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.z, reg.z, mem.z",
            "reg.z, reg.z, reg.z"
        ]
    },
    "fprem": {
        "detail": [
            "Partial Remainder"
        ],
        "description": [
            "reg.wq, reg.wq, reg"
        ]
    },
    "pfsubr": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "vphsubbw": {
        "detail": [
            ""
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "fsubp": {
        "detail": [
            "Subtract"
        ],
        "description": [
            "reg.wq, reg.wq, reg, reg"
        ]
    },
    "fsubr": {
        "detail": [
            "Reverse Subtract"
        ],
        "description": [
            "reg.wq, mem.d, reg",
            "reg.wq, reg.wq, reg"
        ]
    },
    "xorps": {
        "detail": [
            "Bitwise Logical XOR of Packed Single Precision Floating-Point Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "tilezero": {
        "detail": [
            ""
        ],
        "description": [
            "reg"
        ]
    },
    "cvttpd2pi": {
        "detail": [
            "Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers"
        ],
        "description": [
            "reg.q, mem.x",
            "reg.q, reg.x"
        ]
    },
    "pfmax": {
        "detail": [
            ""
        ],
        "description": [
            "reg.q, mem.q",
            "reg.q, reg.q"
        ]
    },
    "retf": {
        "detail": [
            "Return from Procedure"
        ],
        "description": [
            "reg.q, reg.q, mem.q",
            "imm.w, reg.q, reg.q, mem.q"
        ]
    },
    "rdgsbase": {
        "detail": [
            "Read FS/GS Segment Base"
        ],
        "description": [
            "reg.d, reg.d"
        ]
    },
    "vpunpckhdq": {
        "detail": [
            "Unpack High Data"
        ],
        "description": [
            "reg.z, reg.q, reg.z, mem.z",
            "reg.z, reg.q, reg.z, reg.z",
            "reg.x, reg.x, mem.x",
            "reg.x, reg.x, reg.x"
        ]
    },
    "movsldup": {
        "detail": [
            "Replicate Single FP Values"
        ],
        "description": [
            "reg.x, mem.x",
            "reg.x, reg.x"
        ]
    },
    "blcfill": {
        "detail": [
            ""
        ],
        "description": [
            "reg.d, reg.d",
            "reg.d, mem.d"
        ]
    },
    "vcvtsd2usi": {
        "detail": [
            "Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword Integer"
        ],
        "description": [
            "reg.d, mem.q",
            "reg.d, reg.x"
        ]
    }
}
