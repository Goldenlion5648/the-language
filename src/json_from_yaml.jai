#import "Basic";
#import "File";
#import "String";

#load "languages.jai";

debug :: false;

// @TODO

// Language Server
// [ ] What to do when program is not well formed?
// [x] Projects, build files, etc.
// [x] Finds idents in libraries as well as in project

// Language Server Provider Maybes
// [ ] CompletionItemProvider
// [ ] SignatureHelpProvider
// [ ] TypeDefinitionProvider
// [ ] ImplentationProvider
// [ ] DocumentHighlightProvider
// [ ] DocumentSymbolProvider
// [ ] DocumentLinkProvider
// [ ] FoldingRangeProvider

// Misc
// [ ] Generate `support.function.jai` by scraping Preload et al
// [ ] setup tasks.json for module
// [ ] whitespace before MD inner backticks behaves a bit weird
// [ ] markdown codeblock
// [ ] #expand after returns (wtf does this mean)
// [ ] rework all parentheses to begin and end correctly
// [.] `#code,null`
// [.] generate @tag comment grammar
// [x] fix `number, is_number, leading_zero, c := read_int(format, c);` not marking first two vars as decl
// [x] `#type`, `#c_call`
// [x] `context`, `#no_context`
// [x] anonymous enum/enum_flags/structs
// [x] only start #string when the label is the last thing on the line
// [x] whitespace before `/**`


in_file           :: "jai.yaml";
out_file          :: "../syntaxes/jai.json";
languages_ts_file :: "./languages.ts";


Language :: struct {
    id      : string;
    source  : string;
    pattern : string;
}


json : String_Builder;
out :: #bake_arguments print_to_builder(builder = *json);

tab :: (depth: int) #expand {
    for 0..depth  out("    ");
}


stack : [..] Node_Type;
stack_index := -1;

Node_Type :: enum {
    LIST;
    DICT;
    UNKNOWN;
}

push_stack :: (node_type: Node_Type) {
    stack_index += 1;
    if stack_index >= stack.count
        array_add(*stack, node_type);
    else
        stack[stack_index] = node_type;

}

pop_stack :: () {
    stack_index -= 1;
}

peek_stack :: () -> Node_Type {
    return stack[stack_index];
}

line_number := 0;

Replacement :: struct {
  from : string;
  to : string;
}

replacements : [..] Replacement;



main :: () {
    args :=  get_command_line_arguments();
    noisey := args.count > 1;

    yaml_file_data, success := read_entire_file(in_file);
    if !success {
        print("Failed to read %", in_file);
        exit(1);
    }

    context.print_style.log_runtime_errors = false;

    languages_ts : String_Builder;
    init_string_builder(*languages_ts);
    append(*languages_ts, "// this file is autogenerated by json_from_yaml.jai - DO NOT EDIT\n\n");
    append(*languages_ts, "export const languages = [\n");
    for language: languages
        print_to_builder(*languages_ts, "    [\"%\", /.*%/i],\n", language.id, language.pattern);
    append(*languages_ts, "];\n");
    write_entire_file(languages_ts_file, builder_to_string(*languages_ts));

    yaml : String_Builder;
    init_string_builder(*yaml);
    append(*yaml, yaml_file_data);

    append(*yaml, markdown_block_comments_header);
    for language: languages
        print_to_builder(*yaml, markdown_block_comments_language, language.pattern, language.id, language.source);
    append(*yaml, markdown_block_comments_footer);

    append(*yaml, strings_header);
    for language: languages
        print_to_builder(*yaml, strings_language, language.pattern, language.id, language.source);
    append(*yaml, strings_footer);

    init_string_builder(*json);

    depth := 0;
    previous_depth := -1;
    close_list_dict := false;
    push_stack(.DICT);
    out("{");

    preprocess : String_Builder;
    init_string_builder(*preprocess);
    line_offsets : [..] int;
    processed_line_count := 0;
    array_add(*line_offsets, 0);

    for raw_row, index: split(builder_to_string(*yaml), "\n") {
        row := raw_row;
        if row.count > 0 && row[row.count - 1] == #char "\r"
            row.count -= 1;
        line_number = index + 1;

        spaces := 0;
        while spaces < row.count && row[spaces] == #char " "
            spaces += 1;
        if spaces >= row.count {
            line_offsets[processed_line_count] += 1;
            continue;
        }

        if row[spaces] == #char "#" {
            line_offsets[processed_line_count] += 1;

            row = trim_left(advance(row, spaces + 1));
            i := find_index_from_left(row, #char ":");
            if i == -1 || i >= row.count - 2 || row[i + 1] != #char ":"
                continue;

            from : string = ---;
            from.data = row.data;
            from.count = i;
            from = trim_right(from);

            to := trim(advance(row, i + 2), " \t\n\r");

            if row != "" {
                replacement : Replacement = ---;
                replacement.from = from;
                replacement.to = to;
                i := 0;
                while i < replacements.count && replacements[i].from.count > from.count
                    i += 1;
                check := i;
                while check < replacements.count && replacements[check].from.count == from.count {
                    if replacements[check].from == from {
                        print("Duplicate variable label on line %\n", line_number);
                        exit(1);
                    }
                    check += 1;
                }
                array_insert_at(*replacements, replacement, i);
            }

            continue;
        }

        digits_start := spaces;
        digits_end := digits_start;
        while digits_end < row.count && row[digits_end] >= #char "0" && row[digits_end] <= #char "9"
            digits_end += 1;
        if digits_end > digits_start && row.count > digits_end + 1 && row[digits_end] == #char ":" {
            split_at := digits_end + 1;
            tail := trim(slice(row, split_at + 1, row.count - (split_at + 1)), " \n\r\t");
            if tail != "" {
              append(*preprocess, slice(row, 0, split_at));
              append(*preprocess, "\n");
              for 1 .. spaces + 2  append(*preprocess, " ");
              append(*preprocess, tail);
              append(*preprocess, "\n");
              array_add(*line_offsets, line_offsets[processed_line_count] - 1);
              array_add(*line_offsets, line_offsets[processed_line_count] - 1);
              processed_line_count += 2;
              continue;
            }
        }

        append(*preprocess, row);
        append(*preprocess, "\n");
        array_add(*line_offsets, line_offsets[processed_line_count]);
        processed_line_count += 1;
    }

    yaml_string := builder_to_string(*preprocess);

    for raw_row, index: split(yaml_string, "\n") {
        row := raw_row;
        line_number = index + 1 + line_offsets[index];
        if noisey  print("% %\n", line_number, row);

        spaces := 0;
        while spaces < row.count && row[spaces] == #char " "
            spaces += 1;
        if spaces >= row.count  continue;
        if spaces % 2 {
            print("Irregular tab indent on line %\n", line_number);
            exit(1);
        }
        depth = spaces / 2;

        if contains_upper_case(row) {
            for replacement: replacements
                row = replace(row, replacement.from, replacement.to);
        }

        key, value, is_list_entry := parse_row(row);

        if peek_stack() == .UNKNOWN {
            if depth <= previous_depth {
                print("Expected indent on line %\n", line_number);
                exit(1);
            }

            tab(previous_depth);

            if is_list_entry {
                stack[stack_index] = .LIST;
                out("[\n");
            }
            else {
                stack[stack_index] = .DICT;
                out("{\n");
            }
        }
        else if previous_depth == depth {
            if is_list_entry && peek_stack() == .LIST {
                out(" },\n");
            }
            else
                out(",\n");
        }
        else if depth > previous_depth && previous_depth >= 0 {
            if peek_stack() != .LIST {
                print("Unexpected indent on line %\n", line_number);
                exit(1);
            }
            out(",\n");
            push_stack(.DICT);
        }
        else {
            while previous_depth > depth {
                out("\n");
                tab(previous_depth - 1);
                if stack[previous_depth] == .LIST {
                    if close_list_dict {
                        out(" }");
                        close_list_dict = false;
                    }
                    out("]");
                }
                else
                    out("}");
                previous_depth -= 1;
                pop_stack();
            }
            if previous_depth == depth
                out(",\n");
            else
                out("\n");
        }

        tab(depth);

        close_list_dict = false;
        if value == "" {
            push_stack(.UNKNOWN);
            out("\"%\":\n", key);
        }
        else {
            if peek_stack() == .LIST {
                out("{ ");
                close_list_dict = true;
            }
            out("\"%\": \"%\"", key, value);
        }

        previous_depth = depth;
    }

    while previous_depth > 0 {
        out("\n");
        tab(previous_depth - 1);
        if stack[previous_depth] == .LIST {
            if close_list_dict {
                out(" }");
                close_list_dict = false;
            }
            out("]");
        }
        else
            out("}");
        previous_depth -= 1;
        pop_stack();
    }
    out("\n}");

    json_string := builder_to_string(*json);
    write_entire_file(out_file, json_string);

    if noisey  for replacements  print("% -> %\n", it.from, it.to);

    print("OK! (% YAML lines -> % JSON lines)\n", count(yaml_string, #char "\n"), count(json_string, #char "\n"));
}


count :: (s: string, c: u8) -> int {
    total := 0;
    for i: 0 .. s.count - 1
        if s[i] == c  total += 1;
    return total;
}


contains :: (s: string, c: u8) -> bool {
    for i: 0 .. s.count - 1
        if s[i] == c  return true;
    return false;
}


contains_upper_case :: (s: string) -> bool {
    for i: 0 .. s.count - 1
        if s[i] >= #char "A" && s[i] <= #char "Z"
            return true;
    return false;
}

parse_row :: (row_data: string) -> key: string, value: string, is_list_entry: bool {
    row := replace(trim_left(row_data), "\\", "\\\\");

    is_list_entry := false;
    if starts_with(row, "- ") {
        is_list_entry = true;
        row.data += 2;
        row.count -= 2;
    }

    colon := find_index_from_left(row, #char ":");
    if colon == -1 {
        print("Missing ':' on line %\n", line_number);
        exit(1);
    }

    key := slice(row, 0, colon);
    value := slice(row, colon + 1, row.count - (colon + 1));
    value = trim(value);

    key = fix_up(key);
    value = fix_up(value);

    return key, value, is_list_entry;


    fix_up :: (s: string) -> string {
        return replace(trim(s, "'"), "\"", "\\\"");
    }
}


// @Note bare-bones YAML parsing, so 2-space indents only!

markdown_block_comments_header :: #string ___yaml
  markdown-block-comments:
    name: meta.embedded.block.markdown
    begin: (\s*\/\*\*)
    end: (\s*\*\/)
    beginCaptures:
      1:
        name: punctuation.definition.comment.jai
    endCaptures:
      1:
        name: punctuation.definition.comment.jai
    patterns:
      - include: '#block-comments'
___yaml

markdown_block_comments_language :: #string yaml
      - begin: ((?i)```%1)
        end: (```)
        beginCaptures:
          1:
            name: markup.quote.code.comment.%2.jai
        endCaptures:
          1:
            name: markup.quote.code.comment.%2.jai
        patterns:
          - include: %3
yaml

markdown_block_comments_footer :: #string yaml
      - begin: (```)
        end: (```)
        beginCaptures:
          1:
            name: markup.quote.code.comment.jai
        endCaptures:
          1:
            name: markup.quote.code.comment.jai
        patterns:
          - include: source.jai
      - contentName: meta.embedded.block.markdown
        include: text.html.markdown
yaml


strings_header :: #string ___yaml
  strings:
    patterns:
      - name: string.quoted.double.empty.jai
        match: (")(")
        captures:
          1:
            name: punctuation.definition.string.empty.begin.jai
          2:
            name: punctuation.definition.string.empty.end.jai
      - name: string.quoted.double.jai
        begin: (")
        end: ("|$)
        beginCaptures:
          1:
            name: punctuation.definition.string.begin.jai
        endCaptures:
          1:
            name: punctuation.definition.string.end.jai
        patterns:
          - name: constant.character.escape.jai
            match: \\.
          - name: constant.other.placeholder.jai
            match: %[0-9]+
          - match: (%)%
            captures:
              '1':
                name: constant.character.escape.jai
          - name: constant.other.placeholder.jai
            match: %
___yaml

strings_language :: #string ___yaml
      - name: string.here.embed.%2.jai
        begin: (#string)\s+((?i)([A-Za-z_]\w*)?(%1))\b
        end: \s*(\3)(\4)
        beginCaptures:
          1:
            name: keyword.other.directive.string.%2.jai
          2:
            name: constant.other.stringdelimiter.here.embed.%2.jai
          4:
            name: constant.other.stringdelimiter.here.embed.language.%2.jai
        endCaptures:
          1:
            name: constant.other.stringdelimiter.here.embed.%2.jai
          2:
            name: constant.other.stringdelimiter.here.embed.language.%2.jai
        contentName: string.unquoted.here.embed.%2.jai
        patterns:
          - include: %3
___yaml

strings_footer :: #string ___yaml
      - name: string.here.jai
        begin: (#string)\s+([A-Za-z_]\w*)
        end: \s*(\2)
        beginCaptures:
          1:
            name: keyword.other.directive.string.jai
          2:
            name: constant.other.stringdelimiter.here.jai
        endCaptures:
          1:
            name: constant.other.stringdelimiter.here.jai
        contentName: string.unquoted.here.jai
___yaml
